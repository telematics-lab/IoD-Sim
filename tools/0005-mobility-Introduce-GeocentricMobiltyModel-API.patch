From 4651dbe444e40f0e4bf38004f22fa65f0686e084 Mon Sep 17 00:00:00 2001
From: Giovanni Grieco <giovanni@grieco.dev>
Date: Thu, 30 May 2024 12:22:02 +0200
Subject: [PATCH 1/3] mobility: Introduce GeocentricMobiltyModel API

---
 src/mobility/CMakeLists.txt                   |   2 +
 ...entric-constant-position-mobility-model.cc | 222 ++++--------------
 ...centric-constant-position-mobility-model.h | 103 +-------
 .../model/geocentric-mobility-model.cc        | 177 ++++++++++++++
 .../model/geocentric-mobility-model.h         | 153 ++++++++++++
 .../model/channel-condition-model.cc          |   8 +-
 .../model/three-gpp-propagation-loss-model.cc |  75 ++++--
 .../examples/three-gpp-ntn-channel-example.cc |  10 +-
 src/spectrum/model/three-gpp-channel-model.cc |  27 ++-
 9 files changed, 471 insertions(+), 306 deletions(-)
 create mode 100644 src/mobility/model/geocentric-mobility-model.cc
 create mode 100644 src/mobility/model/geocentric-mobility-model.h

diff --git a/src/mobility/CMakeLists.txt b/src/mobility/CMakeLists.txt
index 50f67040b..3e4d8cf07 100644
--- a/src/mobility/CMakeLists.txt
+++ b/src/mobility/CMakeLists.txt
@@ -11,6 +11,7 @@ build_lib(
     model/constant-velocity-mobility-model.cc
     model/gauss-markov-mobility-model.cc
     model/geocentric-constant-position-mobility-model.cc
+    model/geocentric-mobility-model.cc
     model/geographic-positions.cc
     model/hierarchical-mobility-model.cc
     model/mobility-model.cc
@@ -33,6 +34,7 @@ build_lib(
     model/constant-velocity-mobility-model.h
     model/gauss-markov-mobility-model.h
     model/geocentric-constant-position-mobility-model.h
+    model/geocentric-mobility-model.h
     model/geographic-positions.h
     model/hierarchical-mobility-model.h
     model/mobility-model.h
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.cc b/src/mobility/model/geocentric-constant-position-mobility-model.cc
index b9f3d034e..5dfb5d16f 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.cc
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.cc
@@ -15,9 +15,12 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #include "geocentric-constant-position-mobility-model.h"
 
+#include "geographic-positions.h"
+
 #include <ns3/angles.h>
 
 #include <math.h>
@@ -38,7 +41,7 @@ GeocentricConstantPositionMobilityModel::GetTypeId()
 {
     static TypeId tid =
         TypeId("ns3::GeocentricConstantPositionMobilityModel")
-            .SetParent<MobilityModel>()
+            .SetParent<GeocentricMobilityModel>()
             .SetGroupName("Mobility")
             .AddConstructor<GeocentricConstantPositionMobilityModel>()
             .AddAttribute(
@@ -48,196 +51,67 @@ GeocentricConstantPositionMobilityModel::GetTypeId()
                 "altitude",
                 Vector3DValue({0, 0, 0}),
                 MakeVector3DAccessor(&GeocentricConstantPositionMobilityModel::m_position),
-                MakeVector3DChecker())
-            .AddAttribute("GeographicReferencePoint",
-                          "The point, in meters, taken as reference when converting from "
-                          "geographic to topographic.",
-                          Vector3DValue({0, 0, 0}),
-                          MakeVector3DAccessor(
-                              &GeocentricConstantPositionMobilityModel::m_geographicReferencePoint),
-                          MakeVector3DChecker());
+                MakeVector3DChecker());
     return tid;
 }
 
 Vector
-GeocentricConstantPositionMobilityModel::GetGeographicPosition() const
+GeocentricConstantPositionMobilityModel::DoGetPosition(PositionType type) const
 {
-    return DoGetGeographicPosition();
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        return GeographicPositions::GeographicToTopocentricCoordinates(
+            m_position,
+            GetGeographicReferencePoint(),
+            GetEarthSpheroidType());
+    case PositionType::GEOCENTRIC:
+        return GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
+                                                                     m_position.y,
+                                                                     m_position.z,
+                                                                     GetEarthSpheroidType());
+    case PositionType::GEOGRAPHIC:
+        return m_position;
+    default:
+        NS_ABORT_MSG("Unknown PositionType requested");
+    }
 }
 
 void
-GeocentricConstantPositionMobilityModel::SetGeographicPosition(const Vector& latLonAlt)
+GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position, PositionType type)
 {
-    DoSetGeographicPosition(latLonAlt);
-}
+    Vector geographicCoordinates;
 
-Vector
-GeocentricConstantPositionMobilityModel::GetGeocentricPosition() const
-{
-    return DoGetGeocentricPosition();
-}
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        geographicCoordinates =
+            GeographicPositions::TopocentricToGeographicCoordinates(position,
+                                                                    GetGeographicReferencePoint(),
+                                                                    GetEarthSpheroidType());
+        m_position = geographicCoordinates;
+        break;
+    case PositionType::GEOCENTRIC:
+        geographicCoordinates =
+            GeographicPositions::CartesianToGeographicCoordinates(position, GetEarthSpheroidType());
+        m_position = geographicCoordinates;
+        break;
+    case PositionType::GEOGRAPHIC:
+        m_position = position;
+        break;
+    default:
+        NS_ABORT_MSG("Unknown PositionType requested");
+        break;
+    }
 
-void
-GeocentricConstantPositionMobilityModel::SetGeocentricPosition(const Vector& position)
-{
-    DoSetGeocentricPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    return DoGetElevationAngle(other);
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetCoordinateTranslationReferencePoint(
-    const Vector& position)
-{
-    DoSetCoordinateTranslationReferencePoint(position);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetCoordinateTranslationReferencePoint() const
-{
-    return DoGetCoordinateTranslationReferencePoint();
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetPosition() const
-{
-    return DoGetPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetPosition(const Vector& position)
-{
-    return DoSetPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    return DoGetDistanceFrom(other);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetPosition() const
-{
-    Vector topographicCoordinates =
-        GeographicPositions::GeographicToTopocentricCoordinates(m_position,
-                                                                m_geographicReferencePoint,
-                                                                GeographicPositions::SPHERE);
-    return topographicCoordinates;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position)
-{
-    Vector geographicCoordinates =
-        GeographicPositions::TopocentricToGeographicCoordinates(position,
-                                                                m_geographicReferencePoint,
-                                                                GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    Vector cartesianCoordA =
-        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
-                                                              m_position.y,
-                                                              m_position.z,
-                                                              GeographicPositions::SPHERE);
-    Vector cartesianCoordB = other->DoGetGeocentricPosition();
-
-    double distance = (cartesianCoordA - cartesianCoordB).GetLength();
-
-    return distance;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeographicPosition() const
-{
-    return m_position;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeographicPosition(const Vector& latLonAlt)
-{
-    NS_ASSERT_MSG((latLonAlt.x >= -90) && (latLonAlt.x <= 90),
+    NS_ASSERT_MSG((m_position.x >= -90) && (m_position.x <= 90),
                   "Latitude must be between -90 deg and +90 deg");
-    NS_ASSERT_MSG(latLonAlt.z >= 0, "Altitude must be higher or equal than 0 meters");
-
-    m_position = latLonAlt;
+    NS_ASSERT_MSG(m_position.z >= 0, "Altitude must be higher or equal than 0 meters");
     // Normalize longitude to [-180, 180]
     m_position.y = WrapTo180(m_position.y);
     NotifyCourseChange();
 }
 
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeocentricPosition() const
-{
-    Vector geocentricCoordinates =
-        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
-                                                              m_position.y,
-                                                              m_position.z,
-                                                              GeographicPositions::SPHERE);
-    return geocentricCoordinates;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeocentricPosition(const Vector& position)
-{
-    Vector geographicCoordinates =
-        GeographicPositions::CartesianToGeographicCoordinates(position,
-                                                              GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    Vector me = this->DoGetGeocentricPosition();
-    Vector them = other->DoGetGeocentricPosition();
-
-    // a is assumed to be the terminal with the lowest altitude
-    Vector& a = (me.z < them.z ? me : them);
-    Vector& b = (me.z < them.z ? them : me);
-
-    Vector bMinusA = b - a;
-    double numerator = std::abs(a * bMinusA);
-    double denominator = a.GetLength() * bMinusA.GetLength();
-    double x = numerator / denominator;
-
-    // Enforce the appropriate domain range ([-1, 1]) for the argument of std::asin.
-    x = std::min(x, 1.0);
-    x = std::max(x, -1.0);
-
-    // asin returns radians, we convert to degrees
-    double elevAngle = abs((180.0 * M_1_PI) * asin(x));
-
-    return elevAngle;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetCoordinateTranslationReferencePoint(
-    const Vector& refPoint)
-{
-    m_geographicReferencePoint = refPoint;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetCoordinateTranslationReferencePoint() const
-{
-    return m_geographicReferencePoint;
-}
-
 Vector
 GeocentricConstantPositionMobilityModel::DoGetVelocity() const
 {
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.h b/src/mobility/model/geocentric-constant-position-mobility-model.h
index 9579302c0..5b7201eb8 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.h
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.h
@@ -15,11 +15,12 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #ifndef GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 #define GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 
-#include "geographic-positions.h"
+#include "geocentric-mobility-model.h"
 #include "mobility-model.h"
 
 /**
@@ -34,7 +35,7 @@ namespace ns3
 /**
  * \brief Mobility model using geocentric euclidean coordinates, as defined in 38.811 chapter 6.3
  */
-class GeocentricConstantPositionMobilityModel : public MobilityModel
+class GeocentricConstantPositionMobilityModel : public GeocentricMobilityModel
 {
   public:
     /**
@@ -48,113 +49,19 @@ class GeocentricConstantPositionMobilityModel : public MobilityModel
     GeocentricConstantPositionMobilityModel() = default;
     ~GeocentricConstantPositionMobilityModel() override = default;
 
-    /**
-     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
-     * After calculating the plane perpendicular to a cartesian position vector,
-     * the elevation angle is calculated using
-     * https://www.w3schools.blog/angle-between-a-line-and-a-plane.
-     * The altitude of the position passed as a parameter must be higher than that of the reference
-     * point.
-     * \param other pointer to the HAPS/satellite mobility model
-     * \return the elevation angle
-     * in degrees
-     */
-    virtual double GetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-
-    /**
-     * \brief Get the position using geographic (geodetic) coordinates
-     * \return Vector containing (latitude (degree), longitude (degree), altitude (meter))
-     */
-    virtual Vector GetGeographicPosition() const;
-
-    /**
-     * \brief Set the position using geographic coordinates
-     *
-     * Sets the position, using geographic coordinates and asserting
-     * that the provided parameter falls within the appropriate range.
-     *
-     * \param latLonAlt pointer to a Vector containing (latitude (degree), longitude (degree),
-     * altitude (meter)). The values are expected to be in the ranges [-90, 90], [-180, 180], [0,
-     * +inf[, respectively. These assumptions are enforced with an assert for the latitude and the
-     * altitude, while the longitude is normalized to the expected range.
-     */
-    virtual void SetGeographicPosition(const Vector& latLonAlt);
-
-    /**
-     * \brief Get the position using Geocentric Cartesian coordinates
-     * \return Vector containing (x, y, z) (meter) coordinates
-     */
-    virtual Vector GetGeocentricPosition() const;
-
-    /**
-     * \brief Set the position using Geocentric Cartesian coordinates
-     * \param position pointer to a Vector containing (x, y, z) (meter) coordinates
-     */
-    virtual void SetGeocentricPosition(const Vector& position);
-
-    /**
-     * \brief Set the reference point for coordinate conversion
-     * \param refPoint vector containing the geographic reference point (meter)
-     */
-    virtual void SetCoordinateTranslationReferencePoint(const Vector& refPoint);
-
-    /**
-     * \brief Get the reference point for coordinate conversion
-     * \return Vector containing geographic reference point (meter)
-     */
-    virtual Vector GetCoordinateTranslationReferencePoint() const;
-
-    /**
-     * \return the current position
-     */
-    virtual Vector GetPosition() const;
-
-    /**
-     * \param position the position to set.
-     */
-    virtual void SetPosition(const Vector& position);
-
-    /**
-     * \param other a reference to another mobility model
-     * \return the distance between the two objects. Unit is meters.
-     */
-    double GetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
-
   private:
     /** \copydoc GetPosition() */
-    Vector DoGetPosition() const override;
+    Vector DoGetPosition(PositionType type) const override;
     /** \copydoc SetPosition() */
-    void DoSetPosition(const Vector& position) override;
+    void DoSetPosition(const Vector& position, PositionType type) override;
     /** \copydoc GetVelocity() */
     Vector DoGetVelocity() const override;
-    /** \copydoc GetDistanceFrom() */
-    double DoGetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
-    /** \copydoc GetGeographicPosition() */
-    virtual Vector DoGetGeographicPosition() const;
-    /** \copydoc SetGeographicPosition() */
-    virtual void DoSetGeographicPosition(const Vector& latLonAlt);
-    /** \copydoc GetGeocentricPosition() */
-    virtual Vector DoGetGeocentricPosition() const;
-    /** \copydoc SetGeocentricPosition() */
-    virtual void DoSetGeocentricPosition(const Vector& position);
-    /** \copydoc GetElevationAngle() */
-    virtual double DoGetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-    /** \copydoc SetCoordinateTranslationReferencePoint() */
-    virtual void DoSetCoordinateTranslationReferencePoint(const Vector& refPoint);
-    /** \copydoc GetCoordinateTranslationReferencePoint() */
-    virtual Vector DoGetCoordinateTranslationReferencePoint() const;
 
     /**
      * the constant Geographic position,, in order: latitude (degree), longitude (degree), altitude
      * (meter).
      */
     Vector m_position{0, 0, 0};
-
-    /**
-     * This is the point (meter) taken as a reference for converting
-     * from geographic to topographic (also referred to as planar Cartesian)
-     */
-    Vector m_geographicReferencePoint{0, 0, 0};
 };
 
 } // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.cc b/src/mobility/model/geocentric-mobility-model.cc
new file mode 100644
index 000000000..709383a21
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.cc
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+
+#include "geocentric-mobility-model.h"
+
+#include <ns3/enum.h>
+
+#include <math.h>
+
+namespace ns3
+{
+
+std::ostream&
+operator<<(std::ostream& os, PositionType type)
+{
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        os << "TOPOCENTRIC";
+        break;
+    case PositionType::GEOCENTRIC:
+        os << "GEOCENTRIC";
+        break;
+    case PositionType::GEOGRAPHIC:
+        os << "GEOGRAPHIC";
+        break;
+    default:
+        os << "UNKNOWN";
+        break;
+    }
+    return os;
+}
+
+NS_OBJECT_ENSURE_REGISTERED(GeocentricMobilityModel);
+
+TypeId
+GeocentricMobilityModel::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::GeocentricMobilityModel")
+            .SetParent<MobilityModel>()
+            .SetGroupName("Mobility")
+            .AddAttribute("EarthSpheroidType",
+                          "Spheroid model to use for Earth",
+                          EnumValue(GeographicPositions::WGS84),
+                          MakeEnumAccessor<GeographicPositions::EarthSpheroidType>(
+                              &GeocentricMobilityModel::m_earthSpheroidType),
+                          MakeEnumChecker(GeographicPositions::SPHERE,
+                                          "SPHERE",
+                                          GeographicPositions::GRS80,
+                                          "GRS80",
+                                          GeographicPositions::WGS84,
+                                          "WGS84"))
+            .AddAttribute(
+                "GeographicReferencePoint",
+                "The point taken as reference when converting from geographic to topographic.",
+                Vector3DValue({0, 0, 0}),
+                MakeVector3DAccessor(&GeocentricMobilityModel::m_geographicReferencePoint),
+                MakeVector3DChecker());
+    return tid;
+}
+
+Vector
+GeocentricMobilityModel::GetPosition(PositionType type) const
+{
+    return DoGetPosition(type);
+}
+
+void
+GeocentricMobilityModel::SetPosition(Vector position, PositionType type)
+{
+    DoSetPosition(position, type);
+}
+
+double
+GeocentricMobilityModel::GetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    return DoGetElevationAngle(other);
+}
+
+Vector
+GeocentricMobilityModel::GetGeographicReferencePoint() const
+{
+    return DoGetGeographicReferencePoint();
+}
+
+void
+GeocentricMobilityModel::SetGeographicReferencePoint(const Vector& position)
+{
+    DoSetGeographicReferencePoint(position);
+}
+
+GeographicPositions::EarthSpheroidType
+GeocentricMobilityModel::GetEarthSpheroidType() const
+{
+    return m_earthSpheroidType;
+}
+
+Vector
+GeocentricMobilityModel::DoGetPosition() const
+{
+    return DoGetPosition(PositionType::TOPOCENTRIC);
+}
+
+void
+GeocentricMobilityModel::DoSetPosition(const Vector& position)
+{
+    DoSetPosition(position, PositionType::GEOGRAPHIC);
+}
+
+double
+GeocentricMobilityModel::DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const
+{
+    Vector cartesianCoordA = DoGetPosition(PositionType::GEOCENTRIC);
+    Vector cartesianCoordB = other->DoGetPosition(PositionType::GEOCENTRIC);
+
+    double distance = (cartesianCoordA - cartesianCoordB).GetLength();
+
+    return distance;
+}
+
+double
+GeocentricMobilityModel::DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    Vector me = this->DoGetPosition(PositionType::GEOCENTRIC);
+    Vector them = other->DoGetPosition(PositionType::GEOCENTRIC);
+
+    // a is assumed to be the terminal with the lowest altitude
+    Vector& a = (me.z < them.z ? me : them);
+    Vector& b = (me.z < them.z ? them : me);
+
+    Vector bMinusA = b - a;
+    double numerator = std::abs(a * bMinusA);
+    double denominator = a.GetLength() * bMinusA.GetLength();
+    double x = numerator / denominator;
+
+    // Enforce the appropriate domain range ([-1, 1]) for the argument of std::asin.
+    x = std::min(x, 1.0);
+    x = std::max(x, -1.0);
+
+    // asin returns radians, we convert to degrees
+    double elevAngle = abs((180.0 * M_1_PI) * asin(x));
+
+    return elevAngle;
+}
+
+void
+GeocentricMobilityModel::DoSetGeographicReferencePoint(const Vector& refPoint)
+{
+    m_geographicReferencePoint = refPoint;
+}
+
+Vector
+GeocentricMobilityModel::DoGetGeographicReferencePoint() const
+{
+    return m_geographicReferencePoint;
+}
+
+} // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.h b/src/mobility/model/geocentric-mobility-model.h
new file mode 100644
index 000000000..baa28d4a3
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+#ifndef GEOCENTRIC_MOBILITY_MODEL_H
+#define GEOCENTRIC_MOBILITY_MODEL_H
+
+#include "geographic-positions.h"
+#include "mobility-model.h"
+
+namespace ns3
+{
+
+/**
+ * \brief The type of coordinates to use for position.
+ * \see ns3::GeographicPositions for more information on these different types of coordinates.
+ */
+enum class PositionType
+{
+    TOPOCENTRIC,
+    GEOCENTRIC,
+    GEOGRAPHIC
+};
+
+std::ostream& operator<<(std::ostream& os, PositionType type);
+
+/**
+ * \brief Abstract class to mark a mobility model that provides geocentric euclidean coordinates.
+ */
+class GeocentricMobilityModel : public MobilityModel
+{
+  public:
+    /**
+     * Register this type with the TypeId system.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+    /**
+     * Create a position located at coordinates (0,0,0)
+     */
+    GeocentricMobilityModel() = default;
+    ~GeocentricMobilityModel() override = default;
+
+    /**
+     * \brief Get the current position by specifying the type of coordinates. Defaults to
+     * TOPOCENTRIC.
+     */
+    Vector GetPosition(PositionType type = PositionType::TOPOCENTRIC) const;
+
+    /**
+     * \brief Set the position by specifying the type of coordinates. Defaults to GEOGRAPHIC.
+     */
+    void SetPosition(Vector position, PositionType type = PositionType::GEOGRAPHIC);
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane.
+     * The altitude of the node passed as parameter needs to be higher than that of the reference
+     * point. \param other pointer to the HAPS/Satellite mobility model \return the elevation angle
+     * in degrees
+     */
+    double GetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    Vector GetGeographicReferencePoint() const;
+
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    void SetGeographicReferencePoint(const Vector& refPoint);
+
+    /**
+     * \brief Get the Earth spheroid type used for this mobility model.
+     * \return Earth spheroid type
+     */
+    GeographicPositions::EarthSpheroidType GetEarthSpheroidType() const;
+
+  private:
+    /**
+     * \brief Get the TOPOCENTRIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    Vector DoGetPosition() const override;
+
+    /// \brief Get the position by specifying the type of coordinates.
+    virtual Vector DoGetPosition(PositionType type) const = 0;
+
+    /**
+     * \brief Set the GEOGRAPHIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    void DoSetPosition(const Vector& position) override;
+
+    /// \brief Set the position by specifying the type of coordinates.
+    virtual void DoSetPosition(const Vector& position, PositionType type) = 0;
+
+    /**
+     * \brief Get the distance between two nodes.
+     * \param other the mobility model for which the distance from will be calculated
+     * \return the distance in meters
+     */
+    virtual double DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const;
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher. \param other pointer to the HAPS/Satellite mobility model
+     * \return the elevation angle in degrees
+     */
+    virtual double DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    virtual void DoSetGeographicReferencePoint(const Vector& refPoint);
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    virtual Vector DoGetGeographicReferencePoint() const;
+
+    GeographicPositions::EarthSpheroidType m_earthSpheroidType; //!< Spheroid model to use for Earth
+    Vector3D m_geographicReferencePoint; //!< Reference point for coordinate translation from
+                                         //!< geographic to topographic
+};
+
+} // namespace ns3
+
+#endif /* GEOCENTRIC_MOBILITY_MODEL_H */
diff --git a/src/propagation/model/channel-condition-model.cc b/src/propagation/model/channel-condition-model.cc
index da7b5a552..f24088c40 100644
--- a/src/propagation/model/channel-condition-model.cc
+++ b/src/propagation/model/channel-condition-model.cc
@@ -20,7 +20,7 @@
 
 #include "ns3/boolean.h"
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -590,9 +590,9 @@ ThreeGppChannelConditionModel::GetQuantizedElevationAngle(Ptr<const MobilityMode
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    // check if aMob and bMob are of type GeocentricMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
     NS_ASSERT_MSG(aNTNMob && bNTNMob,
                   "Mobility Models need to be of type Geocentric for NTN scenarios");
 
diff --git a/src/propagation/model/three-gpp-propagation-loss-model.cc b/src/propagation/model/three-gpp-propagation-loss-model.cc
index 72091f86a..562c7f584 100644
--- a/src/propagation/model/three-gpp-propagation-loss-model.cc
+++ b/src/propagation/model/three-gpp-propagation-loss-model.cc
@@ -22,7 +22,7 @@
 
 #include "ns3/boolean.h"
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -33,6 +33,12 @@
 
 namespace
 {
+
+constexpr double M_C = 3.0e8;                 //!< propagation velocity in free space
+constexpr double TROPOSPHERE_MAX_ALT = 10e3;  //!< Altitude limit of the Troposphere
+constexpr double STRATOSPHERE_MAX_ALT = 50e3; //!< Altitude limit of the Stratosphere
+constexpr double IONOSPHERE_MAX_ALT = 300e3;  //!< Altitude limit of the Ionosphere
+
 /**
  * The enumerator used for code clarity when performing parameter assignment in the GetLoss Methods
  */
@@ -169,6 +175,23 @@ GetBsUtHeightsUmiStreetCanyon(double heightA, double heightB)
     return std::make_tuple(hBs, hUt);
 };
 
+/**
+ * @return The altitude of the lowest mobility model for NTN scenarios.
+ */
+double
+GetLowestNTNMobAltitude(ns3::Ptr<ns3::MobilityModel> a, ns3::Ptr<ns3::MobilityModel> b)
+{
+    auto aNTNMob = ns3::DynamicCast<ns3::GeocentricMobilityModel>(a);
+    auto bNTNMob = ns3::DynamicCast<ns3::GeocentricMobilityModel>(b);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+    auto posA = aNTNMob->GetPosition(ns3::PositionType::GEOGRAPHIC);
+    auto posB = bNTNMob->GetPosition(ns3::PositionType::GEOGRAPHIC);
+    auto lowestMobAltitude = (posA.z < posB.z) ? posA.z : posB.z;
+    return lowestMobAltitude;
+}
+
 /**
  * @brief Computes the free-space path loss using the formula described in 3GPP TR 38.811,
  * Table 6.6.2
@@ -216,15 +239,17 @@ ComputeAtmosphericAbsorptionLoss(double freq, double elevAngle)
  * @return the ionospheric plus tropospheric scintillation loss for NTN scenarios
  */
 double
-ComputeIonosphericPlusTroposphericScintillationLoss(double freq, double elevAngleQuantized)
+ComputeIonosphericPlusTroposphericScintillationLoss(double freq,
+                                                    double elevAngleQuantized,
+                                                    double lowestMobAltitude)
 {
     double loss = 0;
-    if (freq < 6e9)
+    if (freq < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         // Ionospheric
         loss = 6.22 / (pow(freq / 1e9, 1.5));
     }
-    else
+    if (freq >= 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         // Tropospheric
         loss = troposphericScintillationLoss.at(elevAngleQuantized);
@@ -263,8 +288,6 @@ ComputeClutterLoss(double freq,
     return loss;
 };
 
-constexpr double M_C = 3.0e8; //!< propagation velocity in free space
-
 } // namespace
 
 namespace ns3
@@ -1600,6 +1623,7 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1608,7 +1632,9 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1625,6 +1651,7 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1636,7 +1663,9 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1747,6 +1776,7 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1755,7 +1785,9 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1771,6 +1803,7 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1782,7 +1815,9 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1894,6 +1929,7 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1902,7 +1938,9 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
 
@@ -1920,6 +1958,7 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1931,7 +1970,9 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -2042,6 +2083,7 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -2050,7 +2092,9 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -2066,6 +2110,7 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -2077,7 +2122,9 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
diff --git a/src/spectrum/examples/three-gpp-ntn-channel-example.cc b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
index 960c435f0..70c566611 100644
--- a/src/spectrum/examples/three-gpp-ntn-channel-example.cc
+++ b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
@@ -435,14 +435,16 @@ main(int argc, char* argv[])
     Ptr<GeocentricConstantPositionMobilityModel> rxMob =
         CreateObject<GeocentricConstantPositionMobilityModel>();
 
-    txMob->SetGeographicPosition(Vector(45.40869, 11.89448, 35786000)); // GEO over Padova
-    rxMob->SetGeographicPosition(Vector(45.40869, 11.89448, 14.0));     // Padova Coordinates
+    txMob->SetPosition(Vector(45.40869, 11.89448, 35786000),
+                       PositionType::GEOGRAPHIC); // GEO over Padova
+    rxMob->SetPosition(Vector(45.40869, 11.89448, 14.0),
+                       PositionType::GEOGRAPHIC); // Padova Coordinates
 
     // This is not strictly necessary, but is useful to have "sensible" values when using
     // GetPosition()
-    txMob->SetCoordinateTranslationReferencePoint(
+    txMob->SetGeographicReferencePoint(
         Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
-    rxMob->SetCoordinateTranslationReferencePoint(
+    rxMob->SetGeographicReferencePoint(
         Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
     // End changes with respect to three-gpp-channel-example,
 
diff --git a/src/spectrum/model/three-gpp-channel-model.cc b/src/spectrum/model/three-gpp-channel-model.cc
index b9af38500..8b0d556e7 100644
--- a/src/spectrum/model/three-gpp-channel-model.cc
+++ b/src/spectrum/model/three-gpp-channel-model.cc
@@ -22,7 +22,7 @@
 #include "three-gpp-channel-model.h"
 
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/integer.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
@@ -46,6 +46,9 @@ NS_OBJECT_ENSURE_REGISTERED(ThreeGppChannelModel);
 /// Conversion factor: degrees to radians
 static constexpr double DEG2RAD = M_PI / 180.0;
 
+// Statosphere highest altitude in meters
+static constexpr double STRATOSPHERE_MAX_ALT = 50e3;
+
 /// The ray offset angles within a cluster, given for rms angle spread normalized to 1.
 /// (Table 7.5-3)
 static const double offSetAlpha[20] = {
@@ -1898,22 +1901,22 @@ ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
         Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(aMob);
         Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(bMob);
 
-        if (DynamicCast<GeocentricConstantPositionMobilityModel>(
+        if (DynamicCast<GeocentricMobilityModel>(
                 ConstCast<MobilityModel>(aMob)) && // Transform to NS_ASSERT
-            DynamicCast<GeocentricConstantPositionMobilityModel>(
+            DynamicCast<GeocentricMobilityModel>(
                 ConstCast<MobilityModel>(bMob))) // check if aMob and bMob are of type
-                                                 // GeocentricConstantPositionMobilityModel
+                                                 // GeocentricMobilityModel
         {
-            Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-            Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+            Ptr<GeocentricMobilityModel> aNTNMob =
+                DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+            Ptr<GeocentricMobilityModel> bNTNMob =
+                DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-            if (aNTNMob->GetGeographicPosition().z <
-                bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+            if (aNTNMob->GetPosition(PositionType::GEOGRAPHIC).z <
+                bNTNMob->GetPosition(PositionType::GEOGRAPHIC).z) // b is the HAPS/Satellite
             {
                 elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
-                if (bNTNMob->GetGeographicPosition().z > 50000)
+                if (bNTNMob->GetPosition(PositionType::GEOGRAPHIC).z > STRATOSPHERE_MAX_ALT)
                 {
                     isSatellite = true;
                 }
@@ -1921,7 +1924,7 @@ ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
             else // a is the HAPS/Satellite
             {
                 elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
-                if (aNTNMob->GetGeographicPosition().z > 50000)
+                if (aNTNMob->GetPosition(PositionType::GEOGRAPHIC).z > STRATOSPHERE_MAX_ALT)
                 {
                     isSatellite = true;
                 }
-- 
2.42.0

