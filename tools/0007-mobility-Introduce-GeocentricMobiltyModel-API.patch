From 3ca876e2090e1f24ab702a8ac2a61d4fa7070064 Mon Sep 17 00:00:00 2001
From: Giovanni Grieco <giovanni@grieco.dev>
Date: Sun, 3 Mar 2024 18:59:42 +0100
Subject: [PATCH 1/3] mobility: Introduce GeocentricMobiltyModel API

---
 src/mobility/CMakeLists.txt                   |   2 +
 ...entric-constant-position-mobility-model.cc | 241 +++-------
 ...centric-constant-position-mobility-model.h |  99 +---
 .../model/geocentric-mobility-model.cc        | 174 ++++++++
 .../model/geocentric-mobility-model.h         | 145 ++++++
 .../model/channel-condition-model.cc          |  42 +-
 .../model/three-gpp-propagation-loss-model.cc | 421 ++++++++----------
 .../examples/three-gpp-ntn-channel-example.cc |  10 +-
 src/spectrum/model/three-gpp-channel-model.cc |  45 +-
 9 files changed, 621 insertions(+), 558 deletions(-)
 create mode 100644 src/mobility/model/geocentric-mobility-model.cc
 create mode 100644 src/mobility/model/geocentric-mobility-model.h

diff --git a/src/mobility/CMakeLists.txt b/src/mobility/CMakeLists.txt
index 075bd53f8..d13ee893a 100644
--- a/src/mobility/CMakeLists.txt
+++ b/src/mobility/CMakeLists.txt
@@ -11,6 +11,7 @@ build_lib(
     model/constant-velocity-mobility-model.cc
     model/gauss-markov-mobility-model.cc
     model/geocentric-constant-position-mobility-model.cc
+    model/geocentric-mobility-model.cc
     model/geographic-positions.cc
     model/hierarchical-mobility-model.cc
     model/mobility-model.cc
@@ -33,6 +34,7 @@ build_lib(
     model/constant-velocity-mobility-model.h
     model/gauss-markov-mobility-model.h
     model/geocentric-constant-position-mobility-model.h
+    model/geocentric-mobility-model.h
     model/geographic-positions.h
     model/hierarchical-mobility-model.h
     model/mobility-model.h
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.cc b/src/mobility/model/geocentric-constant-position-mobility-model.cc
index 1c30fbb67..7623e808c 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.cc
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.cc
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 2006,2007 INRIA
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -14,10 +15,13 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #include "geocentric-constant-position-mobility-model.h"
 
+#include "geographic-positions.h"
+
 #include <math.h>
 
 namespace ns3
@@ -35,7 +39,7 @@ GeocentricConstantPositionMobilityModel::GetTypeId()
 {
     static TypeId tid =
         TypeId("ns3::GeocentricConstantPositionMobilityModel")
-            .SetParent<MobilityModel>()
+            .SetParent<GeocentricMobilityModel>()
             .SetGroupName("Mobility")
             .AddConstructor<GeocentricConstantPositionMobilityModel>()
             .AddAttribute(
@@ -44,13 +48,6 @@ GeocentricConstantPositionMobilityModel::GetTypeId()
                 "altitude",
                 Vector3DValue({0, 0, 0}),
                 MakeVector3DAccessor(&GeocentricConstantPositionMobilityModel::m_position),
-                MakeVector3DChecker())
-            .AddAttribute(
-                "GeographicReferencePoint",
-                "The point taken as reference when converting from geographic to topographic.",
-                Vector3DValue({0, 0, 0}),
-                MakeVector3DAccessor(
-                    &GeocentricConstantPositionMobilityModel::m_geographicReferencePoint),
                 MakeVector3DChecker());
     return tid;
 }
@@ -64,192 +61,54 @@ GeocentricConstantPositionMobilityModel::~GeocentricConstantPositionMobilityMode
 }
 
 Vector
-GeocentricConstantPositionMobilityModel::GetGeographicPosition() const
+GeocentricConstantPositionMobilityModel::DoGetPosition(PositionType type) const
 {
-    return DoGetGeographicPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetGeographicPosition(const Vector& latLonAlt)
-{
-    DoSetGeographicPosition(latLonAlt);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetGeocentricPosition() const
-{
-    return DoGetGeocentricPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetGeocentricPosition(const Vector& position)
-{
-    DoSetGeocentricPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    return DoGetElevationAngle(other);
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetCoordinateTranslationReferencePoint(
-    const Vector& position)
-{
-    DoSetCoordinateTranslationReferencePoint(position);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetCoordinateTranslationReferencePoint() const
-{
-    return DoGetCoordinateTranslationReferencePoint();
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetPosition() const
-{
-    return DoGetPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetPosition(const Vector& position)
-{
-    return DoSetPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    return DoGetDistanceFrom(other);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetPosition() const
-{
-    Vector topographicCoordinates =
-        GeographicPositions::GeographicToTopocentricCoordinates(m_position,
-                                                                m_geographicReferencePoint,
-                                                                GeographicPositions::SPHERE);
-    return topographicCoordinates;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position)
-{
-    Vector geographicCoordinates =
-        GeographicPositions::TopocentricToGeographicCoordinates(position,
-                                                                m_geographicReferencePoint,
-                                                                GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    Vector cartesianCoordA =
-        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
-                                                              m_position.y,
-                                                              m_position.z,
-                                                              GeographicPositions::SPHERE);
-    Vector cartesianCoordB = other->DoGetGeocentricPosition();
-
-    double distance = sqrt(pow(cartesianCoordA.x - cartesianCoordB.x, 2) +
-                           pow(cartesianCoordA.y - cartesianCoordB.y, 2) +
-                           pow(cartesianCoordA.z - cartesianCoordB.z, 2));
-
-    return distance;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeographicPosition() const
-{
-    return m_position;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeographicPosition(const Vector& latLonAlt)
-{
-    NS_ASSERT_MSG((latLonAlt.x >= -90) && (latLonAlt.x <= 90),
-                  "Latitude must be between -90 deg and +90 deg");
-    NS_ASSERT_MSG((latLonAlt.y >= -180) && (latLonAlt.y <= 180),
-                  "Longitude must be between -180 deg and +180 deg");
-    NS_ASSERT_MSG(latLonAlt.z >= 0, "Altitude must be higher or equal 0 meters");
-    m_position = latLonAlt;
-    NotifyCourseChange();
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeocentricPosition() const
-{
-    Vector geocentricCoordinates =
-        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
-                                                              m_position.y,
-                                                              m_position.z,
-                                                              GeographicPositions::SPHERE);
-    return geocentricCoordinates;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeocentricPosition(const Vector& position)
-{
-    Vector geographicCoordinates =
-        GeographicPositions::CartesianToGeographicCoordinates(position,
-                                                              GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    NS_ASSERT_MSG(m_position.z < 8000,
-                  "Altitude of the ground terminal needs to be lower than 8km");
-    NS_ASSERT_MSG(other->GetGeographicPosition().z >= 8000,
-                  "Altitude of the HAPS/Satellite needs to be higher than 8km");
-    NS_ASSERT_MSG(m_position.z < other->DoGetGeographicPosition().z,
-                  "Altitude of the argoument node needs to be higher than object node");
-
-    double elevAngle = 0;
-    Vector a = this->DoGetGeocentricPosition();
-    Vector b = other->DoGetGeocentricPosition();
-
-    double numerator = std::abs(a.x * (b.x - a.x) + a.y * (b.y - a.y) + a.z * (b.z - a.z));
-    double denominator = sqrt(pow(a.x, 2) + pow(a.y, 2) + pow(a.z, 2)) *
-                         sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2) + pow(b.z - a.z, 2));
-
-    double x = numerator / denominator;
-
-    // This is done to avoid the nan returned by the asin function when numbers are "almost" 1,
-    // for example 1.0000000000000002
-    if (x > 1)
+    switch (type)
     {
-        x = 1;
+    case PositionType::TOPOCENTRIC:
+        return GeographicPositions::GeographicToTopocentricCoordinates(
+            m_position,
+            GetGeographicReferencePoint(),
+            GetEarthSpheroidType());
+    case PositionType::GEOCENTRIC:
+        return GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
+                                                                     m_position.y,
+                                                                     m_position.z,
+                                                                     GetEarthSpheroidType());
+    case PositionType::GEOGRAPHIC:
+    default:
+        return m_position;
+    }
+}
+
+void
+GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position, PositionType type)
+{
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        m_position = GeographicPositions::TopocentricToGeographicCoordinates(
+            position,
+            GetGeographicReferencePoint(),
+            GetEarthSpheroidType());
+        break;
+    case PositionType::GEOCENTRIC:
+        m_position =
+            GeographicPositions::CartesianToGeographicCoordinates(position, GetEarthSpheroidType());
+        break;
+    case PositionType::GEOGRAPHIC:
+    default:
+        m_position = position;
+        break;
     }
 
-    elevAngle = abs((180.0 * M_1_PI) * asin(x)); // asin returns radians, we convert to degrees
+    NS_ASSERT_MSG((m_position.x >= -90) && (m_position.x <= 90),
+                   "Latitude must be between -90 deg and +90 deg");
+    NS_ASSERT_MSG((m_position.y >= -180) && (m_position.y <= 180),
+                   "Longitude must be between -180 deg and +180 deg");
+    NS_ASSERT_MSG(m_position.z >= 0, "Altitude must be higher or equal 0 meters");
 
-    NS_ASSERT_MSG(!(isnan(elevAngle)), "asin returned a NaN value");
-
-    return elevAngle;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetCoordinateTranslationReferencePoint(
-    const Vector& refPoint)
-{
-    m_geographicReferencePoint = refPoint;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetCoordinateTranslationReferencePoint() const
-{
-    return m_geographicReferencePoint;
+    NotifyCourseChange();
 }
 
 Vector
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.h b/src/mobility/model/geocentric-constant-position-mobility-model.h
index fb538e72e..5d3667eb5 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.h
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 2006,2007 INRIA
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -14,13 +15,14 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #ifndef GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 #define GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 
-#include "geographic-positions.h"
 #include "mobility-model.h"
+#include "geocentric-mobility-model.h"
 
 namespace ns3
 {
@@ -31,7 +33,7 @@ namespace ns3
  * Class GeocentricConstantPositionMobilityModel declaration.
  * \brief Mobility model using geocentric euclidean coordinates, as defined in 38.811 chapter 6.3
  */
-class GeocentricConstantPositionMobilityModel : public MobilityModel
+class GeocentricConstantPositionMobilityModel : public GeocentricMobilityModel
 {
   public:
     /**
@@ -43,80 +45,21 @@ class GeocentricConstantPositionMobilityModel : public MobilityModel
      * Create a position located at coordinates (0,0,0)
      */
     GeocentricConstantPositionMobilityModel();
-    ~GeocentricConstantPositionMobilityModel() override;
-
-    /**
-     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
-     * After calculating the plane perpendicular to one cartesian position vector,
-     * the elevation angle is calculated using
-     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
-     * as parameter needs to be higher.
-     * \param other pointer to the HAPS/Satellite mobility model
-     * \return the elevation angle in degrees
-     */
-    virtual double GetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-
-    /**
-     * \brief Get the position using geographic (geodetic) coordinates
-     * \return Vector containing (latitude, longitude, altitude)
-     */
-    virtual Vector GetGeographicPosition() const;
-
-    /**
-     * \brief Set the position using geographic coordinates
-     * \param position pointer to a Vector containing (latitude, longitude, altitude)
-     */
-    virtual void SetGeographicPosition(const Vector& latLonAlt);
-
-    /**
-     * \brief Get the position using Geocentric Cartesian coordinates
-     * \return Vector containing (X, Y, Z)
-     */
-    virtual Vector GetGeocentricPosition() const;
-
-    /**
-     * \brief Set the position using Geocentric Cartesian coordinates
-     * \param position pointer to a Vector containing (X, Y, Z)
-     */
-    virtual void SetGeocentricPosition(const Vector& position);
-
-    /**
-     * \brief Set the reference point for coordinate translation
-     * \param refPoint vector containing the geographic reference point
-     */
-    virtual void SetCoordinateTranslationReferencePoint(const Vector& refPoint);
-
-    /**
-     * \brief Get the reference point for coordinate translation
-     * \return Vector containing geographic reference point
-     */
-    virtual Vector GetCoordinateTranslationReferencePoint() const;
-
-    // Inherited methods
-    virtual Vector GetPosition() const;
-    virtual void SetPosition(const Vector& position);
-    double GetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
+    ~GeocentricConstantPositionMobilityModel();
 
   private:
-    // Inherited methods
-    Vector DoGetPosition() const override;
-    void DoSetPosition(const Vector& position) override;
+    /**
+     * \brief Get the position according to the specified position type.
+     */
+    Vector DoGetPosition(PositionType type) const override;
+    /**
+     * \brief Set the position according to the specified position type.
+     */
+    void DoSetPosition(const Vector& position, PositionType type);
+    /**
+     * \brief Retrieve current velocity.
+     */
     Vector DoGetVelocity() const override;
-    double DoGetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
-    /** \copydoc GetGeographicPosition() */
-    virtual Vector DoGetGeographicPosition() const;
-    /** \copydoc SetGeographicPosition() */
-    virtual void DoSetGeographicPosition(const Vector& latLonAlt);
-    /** \copydoc GetGeocentricPosition() */
-    virtual Vector DoGetGeocentricPosition() const;
-    /** \copydoc SetGeocentricPosition() */
-    virtual void DoSetGeocentricPosition(const Vector& position);
-    /** \copydoc GetElevationAngle() */
-    virtual double DoGetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-    /** \copydoc SetCoordinateTranslationReferencePoint() */
-    virtual void DoSetCoordinateTranslationReferencePoint(const Vector& refPoint);
-    /** \copydoc GetCoordinateTranslationReferencePoint() */
-    virtual Vector DoGetCoordinateTranslationReferencePoint() const;
 
     /**
      * the constant Geographic position, in degrees, in the order:
@@ -125,12 +68,6 @@ class GeocentricConstantPositionMobilityModel : public MobilityModel
      * altitude
      */
     Vector m_position{0, 0, 0};
-
-    /**
-     * This is the point taken as reference when converting
-     * from geographic to topographic (aka planar Cartesian)
-     */
-    Vector m_geographicReferencePoint{0, 0, 0};
 };
 
 } // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.cc b/src/mobility/model/geocentric-mobility-model.cc
new file mode 100644
index 000000000..7dd6f0efd
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.cc
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+
+#include "geocentric-mobility-model.h"
+
+#include <ns3/enum.h>
+
+#include <math.h>
+
+namespace ns3
+{
+
+NS_OBJECT_ENSURE_REGISTERED(GeocentricMobilityModel);
+
+TypeId
+GeocentricMobilityModel::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::GeocentricMobilityModel")
+            .SetParent<MobilityModel>()
+            .SetGroupName("Mobility")
+            .AddAttribute("EarthSpheroidType",
+                          "Spheroid model to use for Earth",
+                          EnumValue(GeographicPositions::WGS84),
+                          MakeEnumAccessor<GeographicPositions::EarthSpheroidType>(&GeocentricMobilityModel::m_earthSpheroidType),
+                          MakeEnumChecker(GeographicPositions::SPHERE,
+                                          "SPHERE",
+                                          GeographicPositions::GRS80,
+                                          "GRS80",
+                                          GeographicPositions::WGS84,
+                                          "WGS84"))
+            .AddAttribute(
+                "GeographicReferencePoint",
+                "The point taken as reference when converting from geographic to topographic.",
+                Vector3DValue({0, 0, 0}),
+                MakeVector3DAccessor(
+                    &GeocentricMobilityModel::m_geographicReferencePoint),
+                MakeVector3DChecker());
+    return tid;
+}
+
+GeocentricMobilityModel::GeocentricMobilityModel()
+    : m_earthSpheroidType(GeographicPositions::WGS84),
+      m_geographicReferencePoint({0.0, 0.0, 0.0})
+{
+}
+
+GeocentricMobilityModel::~GeocentricMobilityModel()
+{
+}
+
+Vector
+GeocentricMobilityModel::GetPosition(PositionType type) const
+{
+    return DoGetPosition(type);
+}
+
+void
+GeocentricMobilityModel::SetPosition(Vector position, PositionType type)
+{
+    DoSetPosition(position, type);
+}
+
+double
+GeocentricMobilityModel::GetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    return DoGetElevationAngle(other);
+}
+
+Vector
+GeocentricMobilityModel::GetGeographicReferencePoint() const
+{
+    return DoGetGeographicReferencePoint();
+}
+
+void
+GeocentricMobilityModel::SetGeographicReferencePoint(const Vector& position)
+{
+    DoSetGeographicReferencePoint(position);
+}
+
+GeographicPositions::EarthSpheroidType
+GeocentricMobilityModel::GetEarthSpheroidType() const
+{
+    return m_earthSpheroidType;
+}
+
+Vector
+GeocentricMobilityModel::DoGetPosition() const
+{
+    // TODO: we should implement a proper way to understand what projection to use
+    return (GetEarthSpheroidType() == GeographicPositions::EarthSpheroidType::WGS84)
+               ? DoGetPosition(PositionType::PROJECTED)
+               : DoGetPosition(PositionType::TOPOCENTRIC);
+}
+
+void
+GeocentricMobilityModel::DoSetPosition(const Vector& position)
+{
+    DoSetPosition(position, PositionType::GEOGRAPHIC);
+}
+
+double
+GeocentricMobilityModel::DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const
+{
+    Vector thisPosition = DoGetPosition(PositionType::GEOCENTRIC);
+    Vector otherPosition = other->DoGetPosition(PositionType::GEOCENTRIC);
+    return CalculateDistance(thisPosition, otherPosition);
+}
+
+double
+GeocentricMobilityModel::DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    const auto& heightA = DoGetPosition(PositionType::GEOGRAPHIC).z;
+    const auto& heightB = other->DoGetPosition(PositionType::GEOGRAPHIC).z;
+    NS_ASSERT_MSG(heightB >= 8000, "Altitude of the HAPS/Satellite needs to be higher than 8km");
+    NS_ASSERT_MSG(heightA < heightB,
+                  "Altitude of the argoument node needs to be higher than object node");
+
+    double elev_angle = 0;
+    const auto a = DoGetPosition(PositionType::GEOCENTRIC);
+    const auto b = other->DoGetPosition(PositionType::GEOCENTRIC);
+
+    double numerator = abs(a.x * (b.x - a.x) + a.y * (b.y - a.y) + a.z * (b.z - a.z));
+    double denominator = sqrt(pow(a.x, 2) + pow(a.y, 2) + pow(a.z, 2)) *
+                         sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2) + pow(b.z - a.z, 2));
+
+    double x = numerator / denominator;
+
+    // This is done to avoid the nan returned by the asin function when numbers are "almost" 1,
+    // for example 1.0000000000000002
+    if (x > 1)
+    {
+        x = 1;
+    }
+
+    elev_angle = abs((180.0 * M_1_PI) * asin(x)); // asin returns radiants, we convert to degrees
+
+    NS_ASSERT_MSG(!(isnan(elev_angle)), "asin returned a NaN value");
+
+    return elev_angle;
+}
+
+void
+GeocentricMobilityModel::DoSetGeographicReferencePoint(const Vector& refPoint)
+{
+    m_geographicReferencePoint = refPoint;
+}
+
+Vector
+GeocentricMobilityModel::DoGetGeographicReferencePoint() const
+{
+    return m_geographicReferencePoint;
+}
+
+} // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.h b/src/mobility/model/geocentric-mobility-model.h
new file mode 100644
index 000000000..483b6c340
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+#ifndef GEOCENTRIC_MOBILITY_MODEL_H
+#define GEOCENTRIC_MOBILITY_MODEL_H
+
+#include <ns3/geographic-positions.h>
+#include <ns3/mobility-model.h>
+
+namespace ns3
+{
+
+/**
+ * \ingroup mobility
+ *
+ * \brief Abstract class to mark a mobility model that provides geocentric euclidean coordinates.
+ */
+class GeocentricMobilityModel : public MobilityModel
+{
+  public:
+    /**
+     * \brief The type of coordinates to use for position.
+     * \see ns3::GeographicPositions for more information on these different types of coordinates.
+     */
+    enum class PositionType
+    {
+        TOPOCENTRIC,
+        GEOCENTRIC,
+        GEOGRAPHIC
+    };
+
+    /**
+     * Register this type with the TypeId system.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    GeocentricMobilityModel();
+    ~GeocentricMobilityModel() override = 0;
+
+    /// \brief Get the position by specifying the type of coordinates. Defaults to TOPOCENTRIC.
+    Vector GetPosition(PositionType type = PositionType::TOPOCENTRIC) const;
+
+    /// \brief Set the position by specifying the type of coordinates. Defaults to GEOGRAPHIC.
+    void SetPosition(Vector position, PositionType type = PositionType::GEOGRAPHIC);
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher.
+     * \param other pointer to the HAPS/Satellite mobility model
+     * \return the elevation angle in degrees
+     */
+    double GetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    Vector GetGeographicReferencePoint() const;
+
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    void SetGeographicReferencePoint(const Vector& refPoint);
+
+    /**
+     * \brief Get the Earth spheroid type used for this mobility model.
+     * \return Earth spheroid type
+     */
+    GeographicPositions::EarthSpheroidType GetEarthSpheroidType() const;
+
+  private:
+    /**
+     * \brief Get the TOPOCENTRIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    Vector DoGetPosition() const override;
+
+    /// \brief Get the position by specifying the type of coordinates.
+    virtual Vector DoGetPosition(PositionType type) const = 0;
+
+    /**
+     * \brief Set the GEOGRAPHIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    void DoSetPosition(const Vector& position) override;
+
+    /// \brief Set the position by specifying the type of coordinates.
+    virtual void DoSetPosition(const Vector& position, PositionType type) = 0;
+
+    /**
+     * \brief Get the distance between two nodes.
+     * \param other the mobility model for which the distance from will be calculated
+     * \return the distance in meters
+     */
+    virtual double DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const;
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher. \param other pointer to the HAPS/Satellite mobility model
+     * \return the elevation angle in degrees
+     */
+    virtual double DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    virtual void DoSetGeographicReferencePoint(const Vector& refPoint);
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    virtual Vector DoGetGeographicReferencePoint() const;
+
+    GeographicPositions::EarthSpheroidType m_earthSpheroidType; //!< Spheroid model to use for Earth
+    Vector3D m_geographicReferencePoint; //!< Reference point for coordinate translation
+};
+
+} // namespace ns3
+
+#endif /* GEOCENTRIC_MOBILITY_MODEL_H */
diff --git a/src/propagation/model/channel-condition-model.cc b/src/propagation/model/channel-condition-model.cc
index bc505d95e..f44596646 100644
--- a/src/propagation/model/channel-condition-model.cc
+++ b/src/propagation/model/channel-condition-model.cc
@@ -18,9 +18,11 @@
 
 #include "channel-condition-model.h"
 
+#include "ns3/abort.h"
 #include "ns3/boolean.h"
 #include "ns3/double.h"
 #include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -902,14 +904,14 @@ ThreeGppNTNDenseUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel>
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    // check if aMob and bMob are of type GeocentricMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
     NS_ASSERT_MSG(aNTNMob && bNTNMob,
                   "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-    if (aNTNMob->GetGeographicPosition().z <
-        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z) // b is the HAPS/Satellite
     {
         elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
     }
@@ -966,14 +968,14 @@ ThreeGppNTNUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    // check if aMob and bMob are of type GeocentricMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
     NS_ASSERT_MSG(aNTNMob && bNTNMob,
                   "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-    if (aNTNMob->GetGeographicPosition().z <
-        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z) // b is the HAPS/Satellite
     {
         elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
     }
@@ -1028,14 +1030,14 @@ ThreeGppNTNSuburbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    // check if aMob and bMob are of type GeocentricMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
     NS_ASSERT_MSG(aNTNMob && bNTNMob,
                   "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-    if (aNTNMob->GetGeographicPosition().z <
-        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z) // b is the HAPS/Satellite
     {
         elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
     }
@@ -1090,14 +1092,14 @@ ThreeGppNTNRuralChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    // check if aMob and bMob are of type GeocentricMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
     NS_ASSERT_MSG(aNTNMob && bNTNMob,
                   "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-    if (aNTNMob->GetGeographicPosition().z <
-        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z) // b is the HAPS/Satellite
     {
         elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
     }
diff --git a/src/propagation/model/three-gpp-propagation-loss-model.cc b/src/propagation/model/three-gpp-propagation-loss-model.cc
index a351d52c9..9d26b6cee 100644
--- a/src/propagation/model/three-gpp-propagation-loss-model.cc
+++ b/src/propagation/model/three-gpp-propagation-loss-model.cc
@@ -20,9 +20,10 @@
 
 #include "channel-condition-model.h"
 
+#include "ns3/abort.h"
 #include "ns3/boolean.h"
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -37,6 +38,9 @@ namespace ns3
 NS_LOG_COMPONENT_DEFINE("ThreeGppPropagationLossModel");
 
 static const double M_C = 3.0e8; //!< propagation velocity in free space
+static constexpr double TROPOSPHERE_MAX_ALT = 10e3; //!< Altitude limit of the Troposphere
+static constexpr double STRATOSPHERE_MAX_ALT = 50e3; //!< Altitude limit of the Stratosphere
+static constexpr double IONOSPHERE_MAX_ALT = 300e3; //!< Altitude limit of the Ionosphere
 
 // ------------------------------------------------------------------------- //
 
@@ -1609,28 +1613,21 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -1655,14 +1652,18 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -1685,28 +1686,21 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -1742,14 +1736,18 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -1773,28 +1771,20 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
-    }
-    else
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+    }
+    else // a is the HAPS/Satellite
+    {
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -1904,28 +1894,21 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -1950,14 +1933,18 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -1978,28 +1965,21 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -2038,14 +2018,18 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -2070,28 +2054,21 @@ ThreeGppNTNUrbanPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -2202,28 +2179,21 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -2248,14 +2218,18 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -2278,28 +2252,21 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -2338,14 +2305,18 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -2370,28 +2341,21 @@ ThreeGppNTNSuburbanPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -2501,28 +2465,21 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     NS_LOG_UNCOND("Elevation Angle: " << elev_angle);
@@ -2549,14 +2506,18 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -2577,28 +2538,21 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
@@ -2637,14 +2591,18 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
         loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
     }
 
+    const auto aPos = aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto bPos = bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC);
+    const auto lowestMobAltitude = (aPos.z < bPos.z) ? aPos.z : bPos.z;
+
     // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
-    if (m_frequency < 6e9)
+    if (m_frequency < 6e9 && lowestMobAltitude < IONOSPHERE_MAX_ALT)
     {
         loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
     }
 
     // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
-    if (m_frequency > 6e9)
+    if (m_frequency > 6e9 && lowestMobAltitude < TROPOSPHERE_MAX_ALT)
     {
         loss += troposphericScintillationLoss.at(elev_angle_quantized);
     }
@@ -2669,28 +2627,21 @@ ThreeGppNTNRuralPropagationLossModel::GetShadowingStd(
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
-        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
-            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    {
-        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-        if (aNTNMob->GetGeographicPosition().z <
-            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
-        {
-            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
-        }
-        else // a is the HAPS/Satellite
-        {
-            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
-        }
+    if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+        bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+    {
+        // b is the HAPS/Satellite
+        elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
     }
     else
     {
-        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        // a is the HAPS/Satellite
+        elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
     }
 
     int elev_angle_quantized =
diff --git a/src/spectrum/examples/three-gpp-ntn-channel-example.cc b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
index aacf38e5c..04518e0da 100644
--- a/src/spectrum/examples/three-gpp-ntn-channel-example.cc
+++ b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
@@ -397,14 +397,16 @@ main(int argc, char* argv[])
     Ptr<GeocentricConstantPositionMobilityModel> rxMob =
         CreateObject<GeocentricConstantPositionMobilityModel>();
 
-    txMob->SetGeographicPosition(Vector(45.40869, 11.89448, 35786000)); // GEO over Padova
-    rxMob->SetGeographicPosition(Vector(45.40869, 11.89448, 14.0));     // Padova Coordinates
+    txMob->SetPosition(Vector(45.40869, 11.89448, 35786000),
+                       GeocentricMobilityModel::PositionType::GEOGRAPHIC); // GEO over Padova
+    rxMob->SetPosition(Vector(45.40869, 11.89448, 14.0),
+                       GeocentricMobilityModel::PositionType::GEOGRAPHIC); // Padova Coordinates
 
     // This is not strictly necessary, but is useful to have "sensible" values when using
     // GetPosition()
-    txMob->SetCoordinateTranslationReferencePoint(
+    txMob->SetGeographicReferencePoint(
         Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
-    rxMob->SetCoordinateTranslationReferencePoint(
+    rxMob->SetGeographicReferencePoint(
         Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
 
     NS_LOG_DEBUG("TX Position: " << txMob->GetPosition());
diff --git a/src/spectrum/model/three-gpp-channel-model.cc b/src/spectrum/model/three-gpp-channel-model.cc
index 1745247f5..f5a9077ad 100644
--- a/src/spectrum/model/three-gpp-channel-model.cc
+++ b/src/spectrum/model/three-gpp-channel-model.cc
@@ -22,7 +22,7 @@
 #include "three-gpp-channel-model.h"
 
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/integer.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
@@ -2312,38 +2312,29 @@ ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
         Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(aMob);
         Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(bMob);
 
-        if (DynamicCast<GeocentricConstantPositionMobilityModel>(
-                ConstCast<MobilityModel>(aMob)) && // Transform to NS_ASSERT
-            DynamicCast<GeocentricConstantPositionMobilityModel>(
-                ConstCast<MobilityModel>(bMob))) // check if aMob and bMob are of type
-                                                 // GeocentricConstantPositionMobilityModel
-        {
-            Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-            Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+        auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+        auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
+        NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                      "Mobility Models need to be of type Geocentric for NTN scenarios");
 
-            if (aNTNMob->GetGeographicPosition().z <
-                bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z <
+            bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z)
+        {
+            // b is the HAPS/Satellite
+            elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
+            if (bNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z > 50000)
             {
-                elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
-                if (bNTNMob->GetGeographicPosition().z > 50000)
-                {
-                    isSatellite = true;
-                }
-            }
-            else // a is the HAPS/Satellite
-            {
-                elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
-                if (aNTNMob->GetGeographicPosition().z > 50000)
-                {
-                    isSatellite = true;
-                }
+                isSatellite = true;
             }
         }
         else
         {
-            NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+            // a is the HAPS/Satellite
+            elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
+            if (aNTNMob->GetPosition(GeocentricMobilityModel::PositionType::GEOGRAPHIC).z > 50000)
+            {
+                isSatellite = true;
+            }
         }
 
         int elevAngleQuantized =
-- 
2.42.0

