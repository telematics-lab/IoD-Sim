From df65e6a0ec7769aee8511fdb925a948d9d0f22fd Mon Sep 17 00:00:00 2001
From: pagmatt <mattpagg@gmail.com>
Date: Thu, 6 Jul 2023 15:57:44 -0400
Subject: [PATCH] Introduce 3GPP TR 38.811 NTN Propagation Loss Model

---
 doc/models/Makefile                           |    1 +
 scratch/.gitignore                            |    1 +
 src/antenna/CMakeLists.txt                    |    3 +
 src/antenna/doc/source/antenna-design.rst     |   83 +
 .../figures/circular-antenna-pattern.png      |  Bin 0 -> 66011 bytes
 .../model/circular-aperture-antenna-model.cc  |  237 ++
 .../model/circular-aperture-antenna-model.h   |  169 ++
 .../test/test-circular-aperture-antenna.cc    |  295 +++
 src/mobility/CMakeLists.txt                   |    2 +
 src/mobility/doc/mobility.rst                 |   37 +-
 ...entric-constant-position-mobility-model.cc |  261 +++
 ...centric-constant-position-mobility-model.h |  138 ++
 src/mobility/model/geographic-positions.cc    |  150 +-
 src/mobility/model/geographic-positions.h     |   38 +
 src/propagation/CMakeLists.txt                |    2 +-
 src/propagation/doc/propagation.rst           |   77 +
 .../model/channel-condition-model.cc          |  291 +++
 .../model/channel-condition-model.h           |  161 ++
 .../model/three-gpp-propagation-loss-model.cc | 1471 ++++++++++++-
 .../model/three-gpp-propagation-loss-model.h  |  392 +++-
 .../three-gpp-v2v-propagation-loss-model.cc   |   48 +-
 .../three-gpp-v2v-propagation-loss-model.h    |   61 +-
 ...p-ntn-propagation-loss-model-test-suite.cc |  753 +++++++
 src/spectrum/doc/spectrum.rst                 |   46 +
 src/spectrum/examples/CMakeLists.txt          |   10 +
 .../examples/three-gpp-ntn-channel-example.cc |  474 ++++
 src/spectrum/model/three-gpp-channel-model.cc | 1942 ++++++++++++++++-
 src/spectrum/model/three-gpp-channel-model.h  |   65 +-
 28 files changed, 6953 insertions(+), 255 deletions(-)
 create mode 100644 src/antenna/doc/source/figures/circular-antenna-pattern.png
 create mode 100644 src/antenna/model/circular-aperture-antenna-model.cc
 create mode 100644 src/antenna/model/circular-aperture-antenna-model.h
 create mode 100644 src/antenna/test/test-circular-aperture-antenna.cc
 create mode 100644 src/mobility/model/geocentric-constant-position-mobility-model.cc
 create mode 100644 src/mobility/model/geocentric-constant-position-mobility-model.h
 create mode 100644 src/propagation/test/three-gpp-ntn-propagation-loss-model-test-suite.cc
 create mode 100644 src/spectrum/examples/three-gpp-ntn-channel-example.cc

diff --git a/doc/models/Makefile b/doc/models/Makefile
index 2f9405c7e..00d3e1ae5 100644
--- a/doc/models/Makefile
+++ b/doc/models/Makefile
@@ -111,6 +111,7 @@ SOURCEFIGS = \
 	figures/testbed.dia \
 	figures/emulated-channel.dia \
 	$(SRC)/antenna/doc/source/figures/antenna-coordinate-system.dia	\
+	$(SRC)/antenna/doc/source/figures/circular-antenna-pattern.png	\
 	$(SRC)/applications/doc/http-embedded-object-size.png \
 	$(SRC)/applications/doc/http-main-object-size.png \
 	$(SRC)/applications/doc/http-num-of-embedded-objects.png \
diff --git a/scratch/.gitignore b/scratch/.gitignore
index 64892bfaf..cd0ce9d0f 100644
--- a/scratch/.gitignore
+++ b/scratch/.gitignore
@@ -6,3 +6,4 @@
 !subdir/
 !scratch-simulator.cc
 !CMakeLists.txt
+!ntn-test.cc
diff --git a/src/antenna/CMakeLists.txt b/src/antenna/CMakeLists.txt
index 5c38a8cf4..3b1a07535 100644
--- a/src/antenna/CMakeLists.txt
+++ b/src/antenna/CMakeLists.txt
@@ -9,6 +9,7 @@ build_lib(
     model/phased-array-model.cc
     model/three-gpp-antenna-model.cc
     model/uniform-planar-array.cc
+    model/circular-aperture-antenna-model.cc
   HEADER_FILES
     model/angles.h
     model/antenna-model.h
@@ -18,6 +19,7 @@ build_lib(
     model/phased-array-model.h
     model/three-gpp-antenna-model.h
     model/uniform-planar-array.h
+    model/circular-aperture-antenna-model.h
   LIBRARIES_TO_LINK ${libcore}
   TEST_SOURCES
     test/test-angles.cc
@@ -26,4 +28,5 @@ build_lib(
     test/test-cosine-antenna.cc
     test/test-parabolic-antenna.cc
     test/test-uniform-planar-array.cc
+    test/test-circular-aperture-antenna.cc
 )
diff --git a/src/antenna/doc/source/antenna-design.rst b/src/antenna/doc/source/antenna-design.rst
index 3d3087387..feb7d2dab 100644
--- a/src/antenna/doc/source/antenna-design.rst
+++ b/src/antenna/doc/source/antenna-design.rst
@@ -192,6 +192,87 @@ are configured through the attribute "PolSlantAngle"; while the antenna elements
 the second polarization have the polarization slant angle minus 90 degrees,
 as described in [38901]_ (i.e., :math:`{\zeta}`).
 
+CircularApertureAntennaModel
+++++++++++++++++++++++++++++
+
+This class CircularApertureAntennaModel is a generic implementation of the antenna model presented in [38811]_.
+The model represents parabolic antennas, typically deployed for long range communications, e.g. satellite links.
+This implementation does not adopt any type of approximation for the field pattern, taking benefit from the Bessel functions directly implemented into C++.
+By default the orientation is the same as the z-axis, facing the sky (z-axis positive direction), but can be changed using the AntennaInclination and AntennaAzimuth parameters.
+The antenna gain in decimal scale is determined using:
+
+.. math::
+   G \cdot 4\left | \frac{J_{1}\left ( k\cdot a\cdot sin\theta \right )}{k\cdot a\cdot sin\theta} \right |^{2}\;\;\;\;\; for\; 0<\left | \theta \right |\leq 90^{\circ} \\
+   G \cdot 1\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; for\; \theta=0
+
+Where :math:`J_{1}()` is the Bessel function of the first kind and first order, :math:`G` is the linear gain value, :math:`a` is the radius of the antenna's circular aperture,
+and given a frequency of operation :math:`f` the value :math:`k` is equal to :math:`k=\frac{2\pi f}{x}`,
+with :math:`c` the speed of light in vacuum. This type of antennas feature a symmetric radiation pattern, meaning that only one angle is enough to calculate the radiation strength in a certain direction,
+since only the angle :math:`\theta` from the bore sight is needed.
+The parameters :math:`G` (in decibel scale), :math:`a` and :math:`f` can be configured using the attributes: "AntennaMaxGainDb", "AntennaCircularApertureRadius" and "OperatingFrequency".
+
+.. _fig-circular-antenna-pattern:
+
+.. figure:: figures/circular-antenna-pattern.png
+   :align: center
+
+   Circular aperture antenna radiation pattern with gain = 38.5 dB and a = 10c/f
+
+
+CircularApertureAntennaModel
+++++++++++++++++++++++++++++
+
+This class CircularApertureAntennaModel is a generic implementation of the antenna model presented in [38811]_.
+The model represents parabolic antennas, typically deployed for long range communications, e.g. satellite links.
+This implementation does not adopt any type of approximation for the field pattern, taking benefit from the Bessel functions directly implemented into C++.
+By default the orientation is the same as the z-axis, facing the sky (z-axis positive direction), but can be changed using the AntennaInclination and AntennaAzimuth parameters.
+The antenna gain in decimal scale is determined using:
+
+.. math::
+   G \cdot 4\left | \frac{J_{1}\left ( k\cdot a\cdot sin\theta \right )}{k\cdot a\cdot sin\theta} \right |^{2}\;\;\;\;\; for\; 0<\left | \theta \right |\leq 90^{\circ} \\
+   G \cdot 1\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; for\; \theta=0
+
+Where :math:`J_{1}()` is the Bessel function of the first kind and first order, :math:`G` is the linear gain value, :math:`a` is the radius of the antenna's circular aperture,
+and given a frequency of operation :math:`f` the value :math:`k` is equal to :math:`k=\frac{2\pi f}{x}`,
+with :math:`c` the speed of light in vacuum. This type of antennas feature a symmetric radiation pattern, meaning that only one angle is enough to calculate the radiation strength in a certain direction,
+since only the angle :math:`\theta` from the bore sight is needed.
+The parameters :math:`G` (in decibel scale), :math:`a` and :math:`f` can be configured using the attributes: "AntennaMaxGainDb", "AntennaCircularApertureRadius" and "OperatingFrequency".
+
+.. _fig-circular-antenna-pattern:
+
+.. figure:: figures/circular-antenna-pattern.png
+   :align: center
+
+   Circular aperture antenna radiation pattern with gain = 38.5 dB and a = 10c/f
+
+
+CircularApertureAntennaModel
+++++++++++++++++++++++++++++
+
+This class CircularApertureAntennaModel is a generic implementation of the antenna model presented in [38811]_.
+The model represents parabolic antennas, typically deployed for long range communications, e.g. satellite links.
+This implementation does not adopt any type of approximation for the field pattern, taking benefit from the Bessel functions directly implemented into C++.
+By default the orientation is the same as the z-axis, facing the sky (z-axis positive direction), but can be changed using the AntennaInclination and AntennaAzimuth parameters.
+The antenna gain in decimal scale is determined using:
+
+.. math::
+   G \cdot 4\left | \frac{J_{1}\left ( k\cdot a\cdot sin\theta \right )}{k\cdot a\cdot sin\theta} \right |^{2}\;\;\;\;\; for\; 0<\left | \theta \right |\leq 90^{\circ} \\
+   G \cdot 1\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; for\; \theta=0
+
+Where :math:`J_{1}()` is the Bessel function of the first kind and first order, :math:`G` is the linear gain value, :math:`a` is the radius of the antenna's circular aperture,
+and given a frequency of operation :math:`f` the value :math:`k` is equal to :math:`k=\frac{2\pi f}{x}`,
+with :math:`c` the speed of light in vacuum. This type of antennas feature a symmetric radiation pattern, meaning that only one angle is enough to calculate the radiation strength in a certain direction,
+since only the angle :math:`\theta` from the bore sight is needed.
+The parameters :math:`G` (in decibel scale), :math:`a` and :math:`f` can be configured using the attributes: "AntennaMaxGainDb", "AntennaCircularApertureRadius" and "OperatingFrequency".
+
+.. _fig-circular-antenna-pattern:
+
+.. figure:: figures/circular-antenna-pattern.png
+   :align: center
+
+   Circular aperture antenna radiation pattern with gain = 38.5 dB and a = 10c/f
+
+
 
 .. [Balanis] C.A. Balanis, "Antenna Theory - Analysis and Design",  Wiley, 2nd Ed.
 
@@ -208,6 +289,8 @@ as described in [38901]_ (i.e., :math:`{\zeta}`).
 
 .. [38901] 3GPP. 2018. TR 38.901, Study on channel model for frequencies from 0.5 to 100 GHz, V15.0.0. (2018-06).
 
+.. [38811] 3GPP. 2018. TR 38.811, Study on New Radio (NR) to support non-terrestrial networks, V15.4.0. (2020-09).
+
 .. [Mailloux] Robert J. Mailloux, "Phased Array Antenna Handbook", Artech House, 2nd Ed.
 
 .. [TR36897] 3GPP. 2015. TR 36.897. Study on elevation beamforming / Full-Dimension (FD)
diff --git a/src/antenna/doc/source/figures/circular-antenna-pattern.png b/src/antenna/doc/source/figures/circular-antenna-pattern.png
new file mode 100644
index 0000000000000000000000000000000000000000..2a41bf361da45de7109fca7714b096f333f31152
GIT binary patch
literal 66011
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

literal 0
HcmV?d00001

diff --git a/src/antenna/model/circular-aperture-antenna-model.cc b/src/antenna/model/circular-aperture-antenna-model.cc
new file mode 100644
index 000000000..cf0677ad1
--- /dev/null
+++ b/src/antenna/model/circular-aperture-antenna-model.cc
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) 2022 University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ */
+
+#include "circular-aperture-antenna-model.h"
+
+#include "antenna-model.h"
+
+#include <ns3/double.h>
+#include <ns3/log.h>
+
+#include <math.h>
+
+namespace ns3
+{
+/**
+ *  \file
+ *  \ingroup antenna
+ *  Class CircularApertureAntennaModel implementation.
+ */
+
+NS_LOG_COMPONENT_DEFINE("CircularApertureAntennaModel");
+
+NS_OBJECT_ENSURE_REGISTERED(CircularApertureAntennaModel);
+
+TypeId
+CircularApertureAntennaModel::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::CircularApertureAntennaModel")
+            .SetParent<AntennaModel>()
+            .SetGroupName("Antenna")
+            .AddConstructor<CircularApertureAntennaModel>()
+            .AddAttribute("AntennaMaxGainDb",
+                          "The maximum gain value in dB of the antenna",
+                          DoubleValue(1),
+                          MakeDoubleAccessor(&CircularApertureAntennaModel::SetMaxGain),
+                          MakeDoubleChecker<double>(0.0))
+            .AddAttribute("AntennaCircularApertureRadius",
+                          "The radius of the aperture of the antenna, in meters",
+                          DoubleValue(0.5),
+                          MakeDoubleAccessor(&CircularApertureAntennaModel::SetApertureRadius),
+                          MakeDoubleChecker<double>(0.0))
+            .AddAttribute("OperatingFrequency",
+                          "The operating frequency in Hz of the antenna",
+                          DoubleValue(2e9),
+                          MakeDoubleAccessor(&CircularApertureAntennaModel::SetOperatingFrequency),
+                          MakeDoubleChecker<double>(0.0))
+            .AddAttribute("AntennaInclination",
+                          "The inclination angle in rad of the antenna",
+                          DoubleValue(0.0),
+                          MakeDoubleAccessor(&CircularApertureAntennaModel::SetInclination),
+                          MakeDoubleChecker<double>(0.0, M_PI))
+            .AddAttribute("AntennaAzimuth",
+                          "The azimuth angle in rad of the antenna",
+                          DoubleValue(0.0),
+                          MakeDoubleAccessor(&CircularApertureAntennaModel::SetAzimuth),
+                          MakeDoubleChecker<double>(-M_PI, M_PI))
+            .AddAttribute("AntennaMinGainDb",
+                          "The minimum gain value in dB of the antenna",
+                          DoubleValue(-100),
+                          MakeDoubleAccessor(&CircularApertureAntennaModel::SetMinGain),
+                          MakeDoubleChecker<double>(0.0));
+    return tid;
+}
+
+CircularApertureAntennaModel::CircularApertureAntennaModel()
+    : AntennaModel()
+{
+}
+
+CircularApertureAntennaModel::~CircularApertureAntennaModel()
+{
+}
+
+void
+CircularApertureAntennaModel::SetOrientation(Angles a)
+{
+    NS_LOG_FUNCTION(this << a);
+    m_antennaOrientation = a;
+}
+
+void
+CircularApertureAntennaModel::SetInclination(double theta)
+{
+    NS_LOG_FUNCTION(this << theta);
+    NS_ASSERT_MSG((0 <= theta && theta <= M_PI), "Setting invalid inclination(rad): " << theta);
+    m_antennaOrientation = Angles(m_antennaOrientation.GetAzimuth(), theta);
+}
+
+double
+CircularApertureAntennaModel::GetInclination() const
+{
+    return m_antennaOrientation.GetInclination();
+}
+
+void
+CircularApertureAntennaModel::SetAzimuth(double phi)
+{
+    NS_LOG_FUNCTION(this << phi);
+    NS_ASSERT_MSG((-M_PI <= phi && phi <= M_PI), "Setting invalid azimuth(rad): " << phi);
+    m_antennaOrientation = Angles(phi, m_antennaOrientation.GetInclination());
+}
+
+double
+CircularApertureAntennaModel::GetAzimuth() const
+{
+    return m_antennaOrientation.GetAzimuth();
+}
+
+void
+CircularApertureAntennaModel::SetApertureRadius(double r)
+{
+    NS_LOG_FUNCTION(this << r);
+    m_apertureRadius = r;
+}
+
+double
+CircularApertureAntennaModel::GetApertureRadius() const
+{
+    return m_apertureRadius;
+}
+
+void
+CircularApertureAntennaModel::SetOperatingFrequency(double f)
+{
+    NS_LOG_FUNCTION(this << f);
+    m_operatingFrequency = f;
+}
+
+double
+CircularApertureAntennaModel::GetOperatingFrequency() const
+{
+    return m_operatingFrequency;
+}
+
+void
+CircularApertureAntennaModel::SetMaxGain(double gain)
+{
+    NS_LOG_FUNCTION(this << gain);
+    m_maxGain = gain;
+}
+
+double
+CircularApertureAntennaModel::GetMaxGain() const
+{
+    return m_maxGain;
+}
+
+void
+CircularApertureAntennaModel::SetMinGain(double gain)
+{
+    NS_LOG_FUNCTION(this << gain);
+    m_minGain = gain;
+}
+
+double
+CircularApertureAntennaModel::GetMinGain() const
+{
+    return m_minGain;
+}
+
+double
+CircularApertureAntennaModel::GetGainDb(Angles a)
+{
+    NS_LOG_FUNCTION(this << a);
+
+    double theta1 = m_antennaOrientation.GetInclination();
+    double phi1 = m_antennaOrientation.GetAzimuth();
+    double theta2 = a.GetInclination();
+    double phi2 = a.GetAzimuth();
+
+    // For this class the azimuth angle phi is [-pi,pi], but the ISO convention suppose
+    // phi in [0,2*pi], so a conversion is needed
+    if (phi1 > -M_PI && phi1 < 0)
+    {
+        phi1 = 2 * M_PI - std::abs(phi1);
+    }
+    if (phi2 > -M_PI && phi2 < 0)
+    {
+        phi2 = 2 * M_PI - std::abs(phi2);
+    }
+
+    // Convert the spherical coordinates to Cartesian coordinates
+    double x1 = sin(theta1) * cos(phi1);
+    double y1 = sin(theta1) * sin(phi1);
+    double z1 = cos(theta1);
+
+    double x2 = sin(theta2) * cos(phi2);
+    double y2 = sin(theta2) * sin(phi2);
+    double z2 = cos(theta2);
+
+    // Calculate the angle between the incoming ray and the antenna bore sight
+    double theta =
+        acos((x1 * x2 + y1 * y2 + z1 * z2) / ((sqrt(pow(x1, 2) + pow(y1, 2) + pow(z1, 2))) *
+                                              (sqrt(pow(x2, 2) + pow(y2, 2) + pow(z2, 2)))));
+
+    double gain = 0;
+
+    if (theta == 0)
+    {
+        gain = m_maxGain;
+    }
+    else if (theta < -M_PI_2 || theta > M_PI_2)
+    {
+        gain = m_minGain; // This is an approximation. 3GPP TR38.811 does not give indications
+                          // on how the antenna field pattern is over it's 180 degrees FOV
+    }
+    else // theta =! 0 and -90deg<theta<90deg
+    {
+        // 3GPP TR 38.811 Section 6.4.1, first equation
+        double k = (2 * M_PI * m_operatingFrequency) / C;
+        double kasintheta = k * m_apertureRadius * sin(theta);
+        gain = std::cyl_bessel_j(1, kasintheta) / kasintheta;
+        gain *= 4 * gain;
+        gain = 10 * log10(gain) + m_maxGain;
+    }
+
+    return gain;
+}
+
+} // namespace ns3
diff --git a/src/antenna/model/circular-aperture-antenna-model.h b/src/antenna/model/circular-aperture-antenna-model.h
new file mode 100644
index 000000000..f2e542033
--- /dev/null
+++ b/src/antenna/model/circular-aperture-antenna-model.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2022 University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ */
+
+#ifndef CIRCULAR_APERTURE_ANTENNA_MODEL_H
+#define CIRCULAR_APERTURE_ANTENNA_MODEL_H
+
+#include "antenna-model.h"
+
+#include <ns3/object.h>
+
+constexpr double C = 299792458.0; // speed of light in vacuum, in m/s
+
+namespace ns3
+{
+/**
+ * \file
+ * \ingroup antenna
+ * Class CircularApertureAntennaModel declaration
+ * \brief Circular Aperture Antenna Model
+ *
+ * This class implements the circular aperture antenna as described in 3GPP 38.811 6.4.1
+ * https://www.3gpp.org/ftp/Specs/archive/38_series/38.811 without the cosine approximation, thanks
+ * to the Bessel functions introduced in C++17. Spherical coordinates are used, in particular of the
+ * azimuth and inclination angles. All working parameters can be set, namely: operating frequency,
+ * aperture radius, maximum and minimum gain.
+ */
+class CircularApertureAntennaModel : public AntennaModel
+{
+  public:
+    CircularApertureAntennaModel(); //!< Default constructor
+
+    ~CircularApertureAntennaModel() override; //!< Destructor
+
+    /**
+     * Register this type.
+     * \return The object TypeId.
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * \brief Set the antenna orientation using azimuth-inclination convention
+     *
+     * \param a the orientation angles of the antenna
+     */
+    void SetOrientation(Angles a);
+
+    /**
+     * \brief Set the antenna inclination using azimuth-inclination convention
+     *
+     * \param theta the inclination angle of the antenna in rad
+     */
+    void SetInclination(double theta);
+
+    /**
+     * \brief Return the antenna inclination using azimuth-inclination convention
+     *
+     * \return the inclination angle of the antenna in rad
+     */
+    double GetInclination() const;
+
+    /**
+     * \brief Set the antenna azimtuh using azimuth-inclination convention
+     *
+     * \param theta the azimuth angle of the antenna in rad
+     */
+    void SetAzimuth(double theta);
+
+    /**
+     * \brief Return the antenna azimuth using azimuth-inclination convention
+     *
+     * \return the azimuth angle of the antenna in rad
+     */
+    double GetAzimuth() const;
+
+    /**
+     * \brief Set the antenna aperture radius
+     *
+     * \param r the antenna radius in meters
+     */
+    void SetApertureRadius(double r);
+
+    /**
+     * \brief Return the antenna aperture radius
+     *
+     * \return the antenna radius in meters
+     */
+    double GetApertureRadius() const;
+
+    /**
+     * \brief Set the antenna operating frequency
+     *
+     * \param f the antenna operating freqyency, in Hz
+     */
+    void SetOperatingFrequency(double f);
+
+    /**
+     * \brief Return the antenna operating frequency
+     *
+     * \return the antenna operating freqyency, in Hz
+     */
+    double GetOperatingFrequency() const;
+
+    /**
+     * \brief Set the antenna max gain
+     *
+     * \param gain the antenna max gain in dB
+     */
+    void SetMaxGain(double gain);
+
+    /**
+     * \brief Return the antenna max gain
+     *
+     * \return the antenna max gain in dB
+     */
+    double GetMaxGain() const;
+
+    /**
+     * \brief Set the antenna min gain
+     *
+     * \param gain the antenna min gain in dB
+     */
+    void SetMinGain(double gain);
+
+    /**
+     * \brief Return the antenna min gain
+     *
+     * \return the antenna min gain in dB
+     */
+    double GetMinGain() const;
+
+    /**
+     * \brief Get the gain in dB, using Bessel equation of first kind and first order.
+     *
+     * \param a the angle at which the gain need to be calculated with respect to the antenna
+     * bore sight
+     *
+     * \return the antenna gain at the specified Angles a
+     */
+    double GetGainDb(Angles a) override;
+
+  private:
+    Angles m_antennaOrientation{
+        0.0,
+        0.0};                    //!< antenna orientation using the azimuth-inclination convention.
+    double m_apertureRadius;     //!< antenna aperture radius
+    double m_operatingFrequency; //!< antenna operating frequency
+    double m_maxGain;            //!< antenna gain in dB towards the main orientation
+    double m_minGain;            //!< antenna min gain in dB
+};
+
+} // namespace ns3
+
+#endif // CIRCULAR_APERTURE_ANTENNA_MODEL_H
diff --git a/src/antenna/test/test-circular-aperture-antenna.cc b/src/antenna/test/test-circular-aperture-antenna.cc
new file mode 100644
index 000000000..23a506a40
--- /dev/null
+++ b/src/antenna/test/test-circular-aperture-antenna.cc
@@ -0,0 +1,295 @@
+/*
+ *   Copyright (c) 2023 University of Padova, Dep. of Information Engineering, SIGNET lab.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License version 2 as
+ *   published by the Free Software Foundation;
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "cmath"
+#include "iostream"
+#include "sstream"
+#include "string"
+
+#include "ns3/circular-aperture-antenna-model.h"
+#include "ns3/double.h"
+#include "ns3/log.h"
+#include "ns3/pointer.h"
+#include "ns3/simulator.h"
+#include "ns3/test.h"
+#include "ns3/uinteger.h"
+
+using namespace ns3;
+
+NS_LOG_COMPONENT_DEFINE("TestCircularApertureAntennaModel");
+
+/**
+ * \ingroup antenna-tests
+ *
+ * \brief CircularApertureAntennaModel Test Case
+ */
+class CircularApertureAntennaModelTestCase : public TestCase
+{
+  public:
+    /**
+     * Generate a string containing all relevant parameters
+     * \param AntennaMaxGainDb the antenna maximum possible gain [dB]
+     * \param AntennaCircularApertureRadius the radius of the parabolic aperture [m]
+     * \param OperatingFrequency operating frequency [Hz]
+     * \param AntennaInclination antenna inclination [rad]
+     * \param AntennaAzimuth antenna azimuth [rad]
+     * \return the string containing all relevant parameters
+     */
+    static std::string BuildNameString(double AntennaMaxGainDb,
+                                       double AntennaCircularApertureRadius,
+                                       double OperatingFrequency,
+                                       double AntennaInclination,
+                                       double AntennaAzimuth);
+    /**
+     * The constructor of the test case
+     * \param AntennaMaxGainDb the antenna maximum possible gain [dB]
+     * \param AntennaCircularApertureRadius the radius of the parabolic aperture [m]
+     * \param OperatingFrequency operating frequency [Hz]
+     * \param AntennaInclination antenna inclination [rad]
+     * \param AntennaAzimuth antenna azimuth [rad]
+     * \param TestInclination the inclination to perform the gain test [rad]
+     * \param TestAzimuth the azimuth to perform the gain test [rad]
+     * \param expectedGainDb the expected antenna gain [dB]
+     */
+    CircularApertureAntennaModelTestCase(double AntennaMaxGainDb,
+                                         double AntennaCircularApertureRadius,
+                                         double OperatingFrequency,
+                                         double AntennaInclination,
+                                         double AntennaAzimuth,
+                                         double TestInclination,
+                                         double TestAzimuth,
+                                         double expectedGainDb);
+
+  private:
+    /**
+     * Run the test
+     */
+    void DoRun() override;
+    /**
+     * Compute the gain of the antenna
+     * \param a the antenna
+     * \param Inclination antenna inclination [rad]
+     * \param Azimuth antenna azimuth [rad]
+     * \return the gain of the antenna [dB]
+     */
+    double ComputeGain(Ptr<CircularApertureAntennaModel> a, double Inclination, double Azimuth);
+
+    double m_antennaMaxGainDb;              //!< the antenna maximum possible gain [dB]
+    double m_antennaCircularApertureRadius; //!< the radius of the parabolic aperture [m]
+    double m_operatingFrequency;            //!< operating frequency [Hz]
+    double m_antennaInclination;            //!< antenna inclination [rad]
+    double m_antennaAzimuth;                //!< antenna azimuth [rad]
+    double m_testInclination;               //!< test antenna inclination [rad]
+    double m_testAzimuth;                   //!< test antenna azimuth [rad]
+    double m_expectedGain;                  //!< the expected antenna gain [dB]
+};
+
+std::string
+CircularApertureAntennaModelTestCase::BuildNameString(double AntennaMaxGainDb,
+                                                      double AntennaCircularApertureRadius,
+                                                      double OperatingFrequency,
+                                                      double AntennaInclination,
+                                                      double AntennaAzimuth)
+{
+    std::ostringstream oss;
+    oss << "Gain=" << AntennaMaxGainDb << "dB"
+        << ", radius=" << AntennaCircularApertureRadius << "m"
+        << ", frequency" << OperatingFrequency << "Hz"
+        << ", inclination=" << RadiansToDegrees(AntennaInclination) << " deg"
+        << ", azimuth=" << RadiansToDegrees(AntennaAzimuth) << " deg";
+    return oss.str();
+}
+
+CircularApertureAntennaModelTestCase::CircularApertureAntennaModelTestCase(
+    double AntennaMaxGainDb,
+    double AntennaCircularApertureRadius,
+    double OperatingFrequency,
+    double AntennaInclination,
+    double AntennaAzimuth,
+    double TestInclination,
+    double TestAzimuth,
+    double expectedGainDb)
+    : TestCase(BuildNameString(AntennaMaxGainDb,
+                               AntennaCircularApertureRadius,
+                               OperatingFrequency,
+                               AntennaInclination,
+                               AntennaAzimuth)),
+      m_antennaMaxGainDb(AntennaMaxGainDb),
+      m_antennaCircularApertureRadius(AntennaCircularApertureRadius),
+      m_operatingFrequency(OperatingFrequency),
+      m_antennaInclination(AntennaInclination),
+      m_antennaAzimuth(AntennaAzimuth),
+      m_expectedGain(expectedGainDb)
+{
+}
+
+double
+CircularApertureAntennaModelTestCase::ComputeGain(Ptr<CircularApertureAntennaModel> a,
+                                                  double Inclination,
+                                                  double Azimuth)
+{
+    double theta1 = a->GetInclination();
+    double phi1 = a->GetAzimuth();
+    double theta2 = Inclination;
+    double phi2 = Azimuth;
+
+    double maxGain = a->GetMaxGain();
+    double apertureRadius = a->GetApertureRadius();
+    double operatingFrequency = a->GetOperatingFrequency();
+
+    // For this class the azimuth angle phi is [-pi,pi], but the ISO convention suppose
+    // phi in [0,2*pi], so a conversion is needed
+    if (phi1 > -M_PI && phi1 < 0)
+    {
+        phi1 = 2 * M_PI - std::abs(phi1);
+    }
+    if (phi2 > -M_PI && phi2 < 0)
+    {
+        phi2 = 2 * M_PI - std::abs(phi2);
+    }
+
+    // Convert the spherical coordinates to Cartesian coordinates
+    double x1 = sin(theta1) * cos(phi1);
+    double y1 = sin(theta1) * sin(phi1);
+    double z1 = cos(theta1);
+
+    double x2 = sin(theta2) * cos(phi2);
+    double y2 = sin(theta2) * sin(phi2);
+    double z2 = cos(theta2);
+
+    // Calculate the angle between the incoming ray and the antenna bore sight
+    double theta =
+        acos((x1 * x2 + y1 * y2 + z1 * z2) / ((sqrt(pow(x1, 2) + pow(y1, 2) + pow(z1, 2))) *
+                                              (sqrt(pow(x2, 2) + pow(y2, 2) + pow(z2, 2)))));
+
+    double gain = 0;
+
+    if (theta == 0)
+    {
+        gain = maxGain;
+    }
+    else if (theta < -M_PI_2 || theta > M_PI_2)
+    {
+        gain = maxGain - 100; // This is an approximation. 3GPP TR38.811 does not give indications
+                              // on how the antenna field pattern is over it's 180 degrees FOV
+    }
+    else // theta =! 0 and -90deg<theta<90deg
+    {
+        double k = (2 * M_PI * operatingFrequency) / 299792458;
+        double J_1 = std::cyl_bessel_j(1, (k * apertureRadius * sin(theta)));
+        double denominator = k * apertureRadius * sin(theta);
+        gain = 4 * pow(std::abs((J_1 / denominator)), 2);
+        gain = 10 * log10(gain) + maxGain;
+    }
+
+    return gain;
+}
+
+void
+CircularApertureAntennaModelTestCase::DoRun()
+{
+    NS_LOG_FUNCTION(this << BuildNameString(m_antennaMaxGainDb,
+                                            m_antennaCircularApertureRadius,
+                                            m_operatingFrequency,
+                                            m_antennaInclination,
+                                            m_antennaAzimuth));
+
+    Ptr<CircularApertureAntennaModel> a = CreateObject<CircularApertureAntennaModel>();
+    a->SetAttribute("AntennaMaxGainDb", DoubleValue(m_antennaMaxGainDb));
+    a->SetAttribute("AntennaCircularApertureRadius", DoubleValue(m_antennaCircularApertureRadius));
+    a->SetAttribute("OperatingFrequency", DoubleValue(m_operatingFrequency));
+    a->SetAttribute("AntennaInclination", DoubleValue(m_antennaInclination));
+    a->SetAttribute("AntennaAzimuth", DoubleValue(m_antennaAzimuth));
+
+    double actualGainDb = ComputeGain(a, m_testInclination, m_testAzimuth);
+    NS_TEST_EXPECT_MSG_EQ_TOL(actualGainDb,
+                              m_expectedGain,
+                              0.001,
+                              "wrong value of the radiation pattern");
+}
+
+/**
+ * \ingroup antenna-tests
+ *
+ * \brief UniformPlanarArray Test Suite
+ */
+class CircularApertureAntennaModelTestSuite : public TestSuite
+{
+  public:
+    CircularApertureAntennaModelTestSuite();
+};
+
+CircularApertureAntennaModelTestSuite::CircularApertureAntennaModelTestSuite()
+    : TestSuite("circular-aperture-antenna-test", UNIT)
+{
+    AddTestCase(new CircularApertureAntennaModelTestCase(30,
+                                                         0.5,
+                                                         2e9,
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         30),
+                TestCase::QUICK);
+    AddTestCase(new CircularApertureAntennaModelTestCase(30,
+                                                         2,
+                                                         20e9,
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         30),
+                TestCase::QUICK);
+    AddTestCase(new CircularApertureAntennaModelTestCase(30,
+                                                         0.5,
+                                                         2e9,
+                                                         DegreesToRadians(10),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         2.753840),
+                TestCase::QUICK);
+    AddTestCase(new CircularApertureAntennaModelTestCase(30,
+                                                         2,
+                                                         20e9,
+                                                         DegreesToRadians(10),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         -42.0104),
+                TestCase::QUICK);
+    AddTestCase(new CircularApertureAntennaModelTestCase(30,
+                                                         0.5,
+                                                         2e9,
+                                                         DegreesToRadians(180),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         -70),
+                TestCase::QUICK);
+    AddTestCase(new CircularApertureAntennaModelTestCase(30,
+                                                         2,
+                                                         20e9,
+                                                         DegreesToRadians(180),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         DegreesToRadians(0),
+                                                         -70),
+                TestCase::QUICK);
+}
+
+static CircularApertureAntennaModelTestSuite staticCircularApertureAntennaModelTestSuiteInstance;
diff --git a/src/mobility/CMakeLists.txt b/src/mobility/CMakeLists.txt
index 8722eeb32..f200b1b29 100644
--- a/src/mobility/CMakeLists.txt
+++ b/src/mobility/CMakeLists.txt
@@ -21,6 +21,7 @@ build_lib(
     model/steady-state-random-waypoint-mobility-model.cc
     model/waypoint-mobility-model.cc
     model/waypoint.cc
+    model/geocentric-constant-position-mobility-model.cc
   HEADER_FILES
     helper/group-mobility-helper.h
     helper/mobility-helper.h
@@ -42,6 +43,7 @@ build_lib(
     model/steady-state-random-waypoint-mobility-model.h
     model/waypoint-mobility-model.h
     model/waypoint.h
+    model/geocentric-constant-position-mobility-model.h
   LIBRARIES_TO_LINK ${libnetwork}
   TEST_SOURCES
     test/box-line-intersection-test.cc
diff --git a/src/mobility/doc/mobility.rst b/src/mobility/doc/mobility.rst
index 2830e5382..d54f7b7e0 100644
--- a/src/mobility/doc/mobility.rst
+++ b/src/mobility/doc/mobility.rst
@@ -52,26 +52,19 @@ Coordinate system
 #################
 
 There are many possible coordinate systems and possible translations between
-them.  |ns3| uses the Cartesian coordinate system only, at present.
-
-The question has arisen as to how to use the mobility models (supporting
-Cartesian coordinates) with different coordinate systems.  This is possible
-if the user performs conversion between the |ns3| Cartesian and the
-other coordinate system.  One possible library to assist is
-the `proj4 <https://proj.org>`_ library for projections and reverse
-projections.
-
-If we support converting between coordinate systems, we must adopt a
-reference.  It has been suggested to use the geocentric Cartesian coordinate
-system as a reference.  Contributions are welcome in this regard.
-
-The question has arisen about adding a new mobility model whose motion
-is natively implemented in a different coordinate system (such as an
-orbital mobility model implemented using spherical coordinate system).
-We advise to create a subclass with the APIs desired
-(such as Get/SetSphericalPosition), and new position allocators, and
-implement the motion however desired, but must also support the conversion to
-cartesian (by supporting the cartesian Get/SetPosition).
+them.  |ns3| uses the Cartesian coordinate system and the geocentric Cartesian coordinate system, at the moment.
+The GeocentricConstantPositionMobilityModel adopts the geocentric Cartesian coordinates, while still implementing the Get/SetPosition methods,
+which using the GeographicPosition class offers conversion to and form Cartesian coordinates.
+Furthermore, the user can set the position of a node by the means of geographical coordinates thanks to the methods
+Get/SetGeographicPosition. These different coordinates system are defined as follow:
+
+* **Cartesian coordinates**: They represent a point in 3D space using a set of coordinates, namely (x,y,z). This is the legacy positioning system of |ns3|, and it is the most convenient to use when representing a simulation space with reduced distances, i.e. less than 1km.
+
+  * **Topocentric coordinates**: This are Cartesian coordinates when a reference point (on Earth's surface) is given. Useful for conversions to and from Geocentric/Geographic coordinates.
+
+* **Geocentric Cartesian coordinates**: This is the simplest model to represent the Earth spherical shape. The implementation follow the description given in section 6.3 3GPP TR 38.811 [38811]_.
+
+* **Geographic coordinates**: This is the most commonly used system in the real world to represent a point on the surface or in the orbit of the Earth. A node position consists of three values: latitude, longitude and altitude. Implementation details are contained in the GeographicPosition class documentation.
 
 Coordinates
 ###########
@@ -112,6 +105,7 @@ MobilityModel Subclasses
 - RandomWaypoint
 - SteadyStateRandomWaypoint
 - Waypoint
+- GeocentricConstantPosition
 
 PositionAllocator
 #################
@@ -198,13 +192,14 @@ See below for additional usage instructions on this helper.
 Scope and Limitations
 =====================
 
-- only cartesian coordinates are presently supported
+- only cartesian, geocentric cartesian and geographic coordinates are presently supported
 
 References
 ==========
 
 .. [Camp2002] T. Camp, J. Boleng, V. Davies.  "A survey of mobility models for ad hoc network research",
    in Wireless Communications and Mobile Computing, 2002: vol. 2, pp. 2483-2502.
+.. [38811] 3GPP. 2018. TR 38.811, Study on New Radio (NR) to support non-terrestrial networks, V15.4.0. (2020-09).
 
 Usage
 *****
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.cc b/src/mobility/model/geocentric-constant-position-mobility-model.cc
new file mode 100644
index 000000000..1c30fbb67
--- /dev/null
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.cc
@@ -0,0 +1,261 @@
+/*
+ * Copyright (c) 2006,2007 INRIA
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ */
+#include "geocentric-constant-position-mobility-model.h"
+
+#include <math.h>
+
+namespace ns3
+{
+/**
+ *  \file
+ *  \ingroup mobility
+ *  Class GeocentricConstantPositionMobilityModel implementation.
+ */
+
+NS_OBJECT_ENSURE_REGISTERED(GeocentricConstantPositionMobilityModel);
+
+TypeId
+GeocentricConstantPositionMobilityModel::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::GeocentricConstantPositionMobilityModel")
+            .SetParent<MobilityModel>()
+            .SetGroupName("Mobility")
+            .AddConstructor<GeocentricConstantPositionMobilityModel>()
+            .AddAttribute(
+                "PositionLatLongAlt",
+                "The geographic position, in degrees, in the order: latitude, longitude and "
+                "altitude",
+                Vector3DValue({0, 0, 0}),
+                MakeVector3DAccessor(&GeocentricConstantPositionMobilityModel::m_position),
+                MakeVector3DChecker())
+            .AddAttribute(
+                "GeographicReferencePoint",
+                "The point taken as reference when converting from geographic to topographic.",
+                Vector3DValue({0, 0, 0}),
+                MakeVector3DAccessor(
+                    &GeocentricConstantPositionMobilityModel::m_geographicReferencePoint),
+                MakeVector3DChecker());
+    return tid;
+}
+
+GeocentricConstantPositionMobilityModel::GeocentricConstantPositionMobilityModel()
+{
+}
+
+GeocentricConstantPositionMobilityModel::~GeocentricConstantPositionMobilityModel()
+{
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::GetGeographicPosition() const
+{
+    return DoGetGeographicPosition();
+}
+
+void
+GeocentricConstantPositionMobilityModel::SetGeographicPosition(const Vector& latLonAlt)
+{
+    DoSetGeographicPosition(latLonAlt);
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::GetGeocentricPosition() const
+{
+    return DoGetGeocentricPosition();
+}
+
+void
+GeocentricConstantPositionMobilityModel::SetGeocentricPosition(const Vector& position)
+{
+    DoSetGeocentricPosition(position);
+}
+
+double
+GeocentricConstantPositionMobilityModel::GetElevationAngle(
+    Ptr<const GeocentricConstantPositionMobilityModel> other)
+{
+    return DoGetElevationAngle(other);
+}
+
+void
+GeocentricConstantPositionMobilityModel::SetCoordinateTranslationReferencePoint(
+    const Vector& position)
+{
+    DoSetCoordinateTranslationReferencePoint(position);
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::GetCoordinateTranslationReferencePoint() const
+{
+    return DoGetCoordinateTranslationReferencePoint();
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::GetPosition() const
+{
+    return DoGetPosition();
+}
+
+void
+GeocentricConstantPositionMobilityModel::SetPosition(const Vector& position)
+{
+    return DoSetPosition(position);
+}
+
+double
+GeocentricConstantPositionMobilityModel::GetDistanceFrom(
+    Ptr<const GeocentricConstantPositionMobilityModel> other) const
+{
+    return DoGetDistanceFrom(other);
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::DoGetPosition() const
+{
+    Vector topographicCoordinates =
+        GeographicPositions::GeographicToTopocentricCoordinates(m_position,
+                                                                m_geographicReferencePoint,
+                                                                GeographicPositions::SPHERE);
+    return topographicCoordinates;
+}
+
+void
+GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position)
+{
+    Vector geographicCoordinates =
+        GeographicPositions::TopocentricToGeographicCoordinates(position,
+                                                                m_geographicReferencePoint,
+                                                                GeographicPositions::SPHERE);
+    m_position = geographicCoordinates;
+    NotifyCourseChange();
+}
+
+double
+GeocentricConstantPositionMobilityModel::DoGetDistanceFrom(
+    Ptr<const GeocentricConstantPositionMobilityModel> other) const
+{
+    Vector cartesianCoordA =
+        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
+                                                              m_position.y,
+                                                              m_position.z,
+                                                              GeographicPositions::SPHERE);
+    Vector cartesianCoordB = other->DoGetGeocentricPosition();
+
+    double distance = sqrt(pow(cartesianCoordA.x - cartesianCoordB.x, 2) +
+                           pow(cartesianCoordA.y - cartesianCoordB.y, 2) +
+                           pow(cartesianCoordA.z - cartesianCoordB.z, 2));
+
+    return distance;
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::DoGetGeographicPosition() const
+{
+    return m_position;
+}
+
+void
+GeocentricConstantPositionMobilityModel::DoSetGeographicPosition(const Vector& latLonAlt)
+{
+    NS_ASSERT_MSG((latLonAlt.x >= -90) && (latLonAlt.x <= 90),
+                  "Latitude must be between -90 deg and +90 deg");
+    NS_ASSERT_MSG((latLonAlt.y >= -180) && (latLonAlt.y <= 180),
+                  "Longitude must be between -180 deg and +180 deg");
+    NS_ASSERT_MSG(latLonAlt.z >= 0, "Altitude must be higher or equal 0 meters");
+    m_position = latLonAlt;
+    NotifyCourseChange();
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::DoGetGeocentricPosition() const
+{
+    Vector geocentricCoordinates =
+        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
+                                                              m_position.y,
+                                                              m_position.z,
+                                                              GeographicPositions::SPHERE);
+    return geocentricCoordinates;
+}
+
+void
+GeocentricConstantPositionMobilityModel::DoSetGeocentricPosition(const Vector& position)
+{
+    Vector geographicCoordinates =
+        GeographicPositions::CartesianToGeographicCoordinates(position,
+                                                              GeographicPositions::SPHERE);
+    m_position = geographicCoordinates;
+    NotifyCourseChange();
+}
+
+double
+GeocentricConstantPositionMobilityModel::DoGetElevationAngle(
+    Ptr<const GeocentricConstantPositionMobilityModel> other)
+{
+    NS_ASSERT_MSG(m_position.z < 8000,
+                  "Altitude of the ground terminal needs to be lower than 8km");
+    NS_ASSERT_MSG(other->GetGeographicPosition().z >= 8000,
+                  "Altitude of the HAPS/Satellite needs to be higher than 8km");
+    NS_ASSERT_MSG(m_position.z < other->DoGetGeographicPosition().z,
+                  "Altitude of the argoument node needs to be higher than object node");
+
+    double elevAngle = 0;
+    Vector a = this->DoGetGeocentricPosition();
+    Vector b = other->DoGetGeocentricPosition();
+
+    double numerator = std::abs(a.x * (b.x - a.x) + a.y * (b.y - a.y) + a.z * (b.z - a.z));
+    double denominator = sqrt(pow(a.x, 2) + pow(a.y, 2) + pow(a.z, 2)) *
+                         sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2) + pow(b.z - a.z, 2));
+
+    double x = numerator / denominator;
+
+    // This is done to avoid the nan returned by the asin function when numbers are "almost" 1,
+    // for example 1.0000000000000002
+    if (x > 1)
+    {
+        x = 1;
+    }
+
+    elevAngle = abs((180.0 * M_1_PI) * asin(x)); // asin returns radians, we convert to degrees
+
+    NS_ASSERT_MSG(!(isnan(elevAngle)), "asin returned a NaN value");
+
+    return elevAngle;
+}
+
+void
+GeocentricConstantPositionMobilityModel::DoSetCoordinateTranslationReferencePoint(
+    const Vector& refPoint)
+{
+    m_geographicReferencePoint = refPoint;
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::DoGetCoordinateTranslationReferencePoint() const
+{
+    return m_geographicReferencePoint;
+}
+
+Vector
+GeocentricConstantPositionMobilityModel::DoGetVelocity() const
+{
+    return Vector(0.0, 0.0, 0.0);
+}
+
+} // namespace ns3
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.h b/src/mobility/model/geocentric-constant-position-mobility-model.h
new file mode 100644
index 000000000..fb538e72e
--- /dev/null
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2006,2007 INRIA
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ */
+#ifndef GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
+#define GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
+
+#include "geographic-positions.h"
+#include "mobility-model.h"
+
+namespace ns3
+{
+
+/**
+ * \file
+ * \ingroup mobility
+ * Class GeocentricConstantPositionMobilityModel declaration.
+ * \brief Mobility model using geocentric euclidean coordinates, as defined in 38.811 chapter 6.3
+ */
+class GeocentricConstantPositionMobilityModel : public MobilityModel
+{
+  public:
+    /**
+     * Register this type with the TypeId system.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+    /**
+     * Create a position located at coordinates (0,0,0)
+     */
+    GeocentricConstantPositionMobilityModel();
+    ~GeocentricConstantPositionMobilityModel() override;
+
+    /**
+     * \brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher.
+     * \param other pointer to the HAPS/Satellite mobility model
+     * \return the elevation angle in degrees
+     */
+    virtual double GetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
+
+    /**
+     * \brief Get the position using geographic (geodetic) coordinates
+     * \return Vector containing (latitude, longitude, altitude)
+     */
+    virtual Vector GetGeographicPosition() const;
+
+    /**
+     * \brief Set the position using geographic coordinates
+     * \param position pointer to a Vector containing (latitude, longitude, altitude)
+     */
+    virtual void SetGeographicPosition(const Vector& latLonAlt);
+
+    /**
+     * \brief Get the position using Geocentric Cartesian coordinates
+     * \return Vector containing (X, Y, Z)
+     */
+    virtual Vector GetGeocentricPosition() const;
+
+    /**
+     * \brief Set the position using Geocentric Cartesian coordinates
+     * \param position pointer to a Vector containing (X, Y, Z)
+     */
+    virtual void SetGeocentricPosition(const Vector& position);
+
+    /**
+     * \brief Set the reference point for coordinate translation
+     * \param refPoint vector containing the geographic reference point
+     */
+    virtual void SetCoordinateTranslationReferencePoint(const Vector& refPoint);
+
+    /**
+     * \brief Get the reference point for coordinate translation
+     * \return Vector containing geographic reference point
+     */
+    virtual Vector GetCoordinateTranslationReferencePoint() const;
+
+    // Inherited methods
+    virtual Vector GetPosition() const;
+    virtual void SetPosition(const Vector& position);
+    double GetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
+
+  private:
+    // Inherited methods
+    Vector DoGetPosition() const override;
+    void DoSetPosition(const Vector& position) override;
+    Vector DoGetVelocity() const override;
+    double DoGetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
+    /** \copydoc GetGeographicPosition() */
+    virtual Vector DoGetGeographicPosition() const;
+    /** \copydoc SetGeographicPosition() */
+    virtual void DoSetGeographicPosition(const Vector& latLonAlt);
+    /** \copydoc GetGeocentricPosition() */
+    virtual Vector DoGetGeocentricPosition() const;
+    /** \copydoc SetGeocentricPosition() */
+    virtual void DoSetGeocentricPosition(const Vector& position);
+    /** \copydoc GetElevationAngle() */
+    virtual double DoGetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
+    /** \copydoc SetCoordinateTranslationReferencePoint() */
+    virtual void DoSetCoordinateTranslationReferencePoint(const Vector& refPoint);
+    /** \copydoc GetCoordinateTranslationReferencePoint() */
+    virtual Vector DoGetCoordinateTranslationReferencePoint() const;
+
+    /**
+     * the constant Geographic position, in degrees, in the order:
+     * latitude
+     * longitude
+     * altitude
+     */
+    Vector m_position{0, 0, 0};
+
+    /**
+     * This is the point taken as reference when converting
+     * from geographic to topographic (aka planar Cartesian)
+     */
+    Vector m_geographicReferencePoint{0, 0, 0};
+};
+
+} // namespace ns3
+
+#endif /* GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H */
diff --git a/src/mobility/model/geographic-positions.cc b/src/mobility/model/geographic-positions.cc
index 36b7a4bea..529a5d079 100644
--- a/src/mobility/model/geographic-positions.cc
+++ b/src/mobility/model/geographic-positions.cc
@@ -43,13 +43,22 @@ static constexpr double EARTH_RADIUS = 6371e3;
  */
 
 /// Earth's semi-major axis in meters as defined by both GRS80 and WGS84
+/// https://en.wikipedia.org/wiki/World_Geodetic_System
 static constexpr double EARTH_SEMIMAJOR_AXIS = 6378137;
 
 /// Earth's first eccentricity as defined by GRS80
+/// https://en.wikipedia.org/wiki/Geodetic_Reference_System_1980
 static constexpr double EARTH_GRS80_ECCENTRICITY = 0.0818191910428158;
+/// Earth's first flattening as defined by GRS80
+/// https://en.wikipedia.org/wiki/Geodetic_Reference_System_1980
+static constexpr double EARTH_GRS80_FLATTENING = 0.003352810681183637418;
 
-/// Earth's first eccentricity as defined by WGS84
+/// Earth's first eccentricity as defined by
+/// https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84
 static constexpr double EARTH_WGS84_ECCENTRICITY = 0.0818191908426215;
+/// Earth's first flattening as defined by WGS84
+/// https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84
+static constexpr double EARTH_WGS84_FLATTENING = 0.00335281;
 
 /// Conversion factor: degrees to radians
 static constexpr double DEG2RAD = M_PI / 180.0;
@@ -68,18 +77,17 @@ GeographicPositions::GeographicToCartesianCoordinates(double latitude,
     double longitudeRadians = DEG2RAD * longitude;
     double a; // semi-major axis of earth
     double e; // first eccentricity of earth
-    if (sphType == SPHERE)
+    switch (sphType)
     {
+    case SPHERE:
         a = EARTH_RADIUS;
         e = 0;
-    }
-    else if (sphType == GRS80)
-    {
+        break;
+    case GRS80:
         a = EARTH_SEMIMAJOR_AXIS;
         e = EARTH_GRS80_ECCENTRICITY;
-    }
-    else // if sphType == WGS84
-    {
+        break;
+    default: // sphType == WGS84
         a = EARTH_SEMIMAJOR_AXIS;
         e = EARTH_WGS84_ECCENTRICITY;
     }
@@ -100,18 +108,17 @@ GeographicPositions::CartesianToGeographicCoordinates(Vector pos, EarthSpheroidT
 
     double a; // semi-major axis of earth
     double e; // first eccentricity of earth
-    if (sphType == SPHERE)
+    switch (sphType)
     {
+    case SPHERE:
         a = EARTH_RADIUS;
         e = 0;
-    }
-    else if (sphType == GRS80)
-    {
+        break;
+    case GRS80:
         a = EARTH_SEMIMAJOR_AXIS;
         e = EARTH_GRS80_ECCENTRICITY;
-    }
-    else // if sphType == WGS84
-    {
+        break;
+    default: // sphType == WGS84
         a = EARTH_SEMIMAJOR_AXIS;
         e = EARTH_WGS84_ECCENTRICITY;
     }
@@ -165,6 +172,119 @@ GeographicPositions::CartesianToGeographicCoordinates(Vector pos, EarthSpheroidT
     return lla;
 }
 
+Vector
+GeographicPositions::GeographicToTopocentricCoordinates(Vector pos,
+                                                        Vector refPoint,
+                                                        EarthSpheroidType sphType)
+{
+    NS_LOG_FUNCTION(pos << sphType);
+
+    double phi = DEG2RAD * pos.x;
+    double lambda = DEG2RAD * pos.y;
+    double h = pos.z;
+    double phi0 = DEG2RAD * refPoint.x;
+    double lambda0 = DEG2RAD * refPoint.y;
+    double h0 = refPoint.z;
+    double a; // semi-major axis of earth
+    double e; // first eccentricity of earth
+
+    switch (sphType)
+    {
+    case SPHERE:
+        a = EARTH_RADIUS;
+        e = 0;
+        break;
+    case GRS80:
+        a = EARTH_SEMIMAJOR_AXIS;
+        e = EARTH_GRS80_ECCENTRICITY;
+        break;
+    default: // sphType == WGS84
+        a = EARTH_SEMIMAJOR_AXIS;
+        e = EARTH_WGS84_ECCENTRICITY;
+    }
+
+    double v = a / (pow((1 - pow(e, 2) * pow(sin(phi), 2)),
+                        0.5)); // the radius of curvature in the prime vertical at latitude
+    double v0 = a / (pow((1 - pow(e, 2) * pow(sin(phi0), 2)),
+                         0.5)); // the radius of curvature in the prime vertical at latitude of the
+                                // reference point
+
+    double U = (v + h) * cos(phi) * sin(lambda - lambda0);
+    double V = (v + h) * (sin(phi) * cos(phi0) - cos(phi) * sin(phi0) * cos(lambda - lambda0)) +
+               pow(e, 2) * (v0 * sin(phi0) - v * sin(phi)) * cos(phi0);
+    double W = (v + h) * (sin(phi) * sin(phi0) + cos(phi) * cos(phi0) * cos(lambda - lambda0)) +
+               pow(e, 2) * (v0 * sin(phi0) - v * sin(phi)) * sin(phi0) - (v0 + h0);
+
+    Vector topocentricCoordinates = Vector(U, V, W);
+    return topocentricCoordinates;
+}
+
+Vector
+GeographicPositions::TopocentricToGeographicCoordinates(Vector pos,
+                                                        Vector refPoint,
+                                                        EarthSpheroidType sphType)
+{
+    NS_LOG_FUNCTION(pos << sphType);
+
+    double U = pos.x;
+    double V = pos.y;
+    double W = pos.z;
+    double phi0 = DEG2RAD * refPoint.x;
+    double lambda0 = DEG2RAD * refPoint.y;
+    double h0 = refPoint.z;
+    double a; // semi-major axis of earth
+    double e; // first eccentricity of earth
+    double f; // flattening
+
+    switch (sphType)
+    {
+    case SPHERE:
+        a = EARTH_RADIUS;
+        e = 0;
+        f = 0;
+        break;
+    case GRS80:
+        a = EARTH_SEMIMAJOR_AXIS;
+        e = EARTH_GRS80_ECCENTRICITY;
+        f = EARTH_GRS80_FLATTENING;
+        break;
+    default: // sphType == WGS84
+        a = EARTH_SEMIMAJOR_AXIS;
+        e = EARTH_WGS84_ECCENTRICITY;
+        f = EARTH_WGS84_FLATTENING;
+    }
+
+    double v0 = a / (pow((1 - pow(e, 2) * pow(sin(phi0), 2)),
+                         0.5)); // the radius of curvature in the prime vertical at latitude of the
+                                // reference point
+
+    double X0 = (v0 + h0) * cos(phi0) * cos(lambda0);
+    double Y0 = (v0 + h0) * cos(phi0) * sin(lambda0);
+    double Z0 = ((1 - pow(e, 2)) * v0 + h0) * sin(phi0);
+
+    double X = X0 - U * sin(lambda0) - V * sin(phi0) * cos(lambda0) + W * cos(phi0) * cos(lambda0);
+    double Y = Y0 + U * cos(lambda0) - V * sin(phi0) * sin(lambda0) + W * cos(phi0) * sin(lambda0);
+    double Z = Z0 + V * cos(phi0) + W * sin(phi0);
+
+    double epsilon = pow(e, 2) / (1 - pow(e, 2));
+    double b = a * (1 - f);
+    double p = sqrt(pow(X, 2) + pow(Y, 2));
+    double q = atan2((Z * a), (p * b));
+
+    double phi = atan2((Z + epsilon * b * pow(sin(q), 3)), (p - pow(e, 2) * a * pow(cos(q), 3)));
+    double lambda = atan2(Y, X);
+
+    double v = a / (pow((1 - pow(e, 2) * pow(sin(phi), 2)), 0.5));
+
+    double h = (p / cos(phi)) - v;
+
+    phi *= RAD2DEG;
+    lambda *= RAD2DEG;
+
+    Vector geographicCoordinates = Vector(phi, lambda, h);
+    return geographicCoordinates;
+}
+
 std::list<Vector>
 GeographicPositions::RandCartesianPointsAroundGeographicPoint(double originLatitude,
                                                               double originLongitude,
diff --git a/src/mobility/model/geographic-positions.h b/src/mobility/model/geographic-positions.h
index 279e07310..ddb814f76 100644
--- a/src/mobility/model/geographic-positions.h
+++ b/src/mobility/model/geographic-positions.h
@@ -91,6 +91,44 @@ class GeographicPositions
      */
     static Vector CartesianToGeographicCoordinates(Vector pos, EarthSpheroidType sphType);
 
+    /**
+     * Conversion from geographic to topocentric.
+     *
+     * Conversion taken from IOGP Report 373-07-02.
+     *
+     * @param pos a vector containing the Geographic coordinates (latitude, longitude, altitude)
+     * @param refPoint a vector containing the reference point. Default is (0,0,0)
+     * @param sphType earth spheroid model to use for conversion
+     *
+     * @return Vector position using planar Cartesian coordinates, same as NS-3
+     *
+     * IOGP. Geomatics guidance note 7, part 2: coordinate conversions & transformations including
+     * formulas. IOGP Publication 373-7-2, International Association For Oil And Gas Producers, 2018
+     * https://www.iogp.org/bookstore/product/coordinate-conversions-and-transformation-including-formulas/
+     */
+    static Vector GeographicToTopocentricCoordinates(Vector pos,
+                                                     Vector refPoint,
+                                                     EarthSpheroidType sphType);
+
+    /**
+     * Conversion from topocentric to geographic.
+     *
+     * Conversion taken from IOGP Report 373-07-02.
+     *
+     * @param pos a vector containing the topocentric coordinates (U, V, W)
+     * @param refPoint a vector containing the reference point. Default is (0,0,0)
+     * @param sphType earth spheroid model to use for conversion
+     *
+     * @return Vector position using geograpic coordinates
+     *
+     * IOGP. Geomatics guidance note 7, part 2: coordinate conversions & transformations including
+     * formulas. IOGP Publication 373-7-2, International Association For Oil And Gas Producers, 2018
+     * https://www.iogp.org/bookstore/product/coordinate-conversions-and-transformation-including-formulas/
+     */
+    static Vector TopocentricToGeographicCoordinates(Vector pos,
+                                                     Vector refPoint,
+                                                     EarthSpheroidType sphType);
+
     /**
      * Generates uniformly distributed random points (in ECEF Cartesian
      * coordinates) within a given altitude above earth's surface centered around
diff --git a/src/propagation/CMakeLists.txt b/src/propagation/CMakeLists.txt
index 62bb29116..960713a9e 100644
--- a/src/propagation/CMakeLists.txt
+++ b/src/propagation/CMakeLists.txt
@@ -41,5 +41,5 @@ build_lib(
     test/probabilistic-v2v-channel-condition-model-test.cc
     test/propagation-loss-model-test-suite.cc
     test/three-gpp-propagation-loss-model-test-suite.cc
-    test/three-gpp-propagation-loss-model-test-suite.cc
+    test/three-gpp-ntn-propagation-loss-model-test-suite.cc
 )
diff --git a/src/propagation/doc/propagation.rst b/src/propagation/doc/propagation.rst
index 1eb5ce137..278b5c25b 100644
--- a/src/propagation/doc/propagation.rst
+++ b/src/propagation/doc/propagation.rst
@@ -42,6 +42,10 @@ The following propagation loss models are implemented:
       * ThreeGppUMaPropagationLossModel
       * ThreeGppUmiStreetCanyonPropagationLossModel
       * ThreeGppIndoorOfficePropagationLossModel
+      * ThreeGppNTNDenseUrbanPropagationLossModel
+      * ThreeGppNTNUrbanPropagationLossModel
+      * ThreeGppNTNSuburbanPropagationLossModel
+      * ThreeGppNTNRuralPropagationLossModel
 
 Other models could be available thanks to other modules, e.g., the ``building`` module.
 
@@ -746,6 +750,47 @@ The test cases :cpp:class:`ThreeGppRmaPropagationLossModelTestCase`,
 :cpp:class:`ThreeGppIndoorOfficePropagationLossModelTestCase` compute the path loss between two nodes and compares it with the value obtained using the formulas in 3GPP TR 38.901 [38901]_, Table 7.4.1-1.
 The test case :cpp:class:`ThreeGppShadowingTestCase` checks if the shadowing is correctly computed by testing the deviation of the overall propagation loss from the path loss. The test is carried out for all the scenarios, both in LOS and NLOS condition.
 
+ThreeGppNTNPropagationLossModel
+============================
+
+Four different classes have been derived from the base class :cpp:class:`ThreeGppPropagationLossModel`
+to support Non-Terrestrial Networks, one for each scenario presented in 3GPP TR 38.811 [38811]_, i.e.,
+dense urban, urban, suburban and rural.
+
+*Implemented features:*
+
+  * Line of Sight and Not Line of Sight (LOS/NLOS) probability models (3GPP TR 38.811, Sec. 6.6.1)
+  * Path loss, shadowing models and clutter loss (3GPP TR 38.811, Sec. 6.6.2)
+  * Atmospheric absorption model (3GPP TR 38.811, Sec. 6.6.4)
+  * Ionospheric and tropospheric scintillation (3GPP TR 38.811, Sec. 6.6.6)
+  * All the features already implemented in `ThreeGppPropagationLossModel <index.html#threegpppropagationlossmodel>`_
+
+
+ThreeGppNTNDenseUrbanPropagationLossModel
+`````````````````````````````````````````
+This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
+TR 38.811 [38811]_, Table 6.6.2-1 for the Dense Urban scenario. It
+supports frequencies between 0.5 and 100 GHz.
+
+ThreeGppNTNUrbanPropagationLossModel
+````````````````````````````````````
+This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
+TR 38.811 [38811]_, Table 6.6.2-2 for the Urban scenario. It
+supports frequencies between 0.5 and 100 GHz.
+
+ThreeGppNTNSuburbanPropagationLossModel
+```````````````````````````````````````
+This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
+TR 38.811 [38811]_, Table 6.6.2-3 for the Suburban scenario. It
+supports frequencies between 0.5 and 100 GHz.
+
+ThreeGppNTNRuralPropagationLossModel
+````````````````````````````````````
+This implements the LOS/NLOS path loss and shadow fading models described in 3GPP
+TR 38.811 [38811]_, Table 6.6.2-3 for the Rural scenario. It
+supports frequencies between 0.5 and 100 GHz.
+
+
 ChannelConditionModel
 *********************
 
@@ -803,6 +848,36 @@ ThreeGppIndoorOpenOfficeChannelConditionModel
 `````````````````````````````````````````````
 This implements the statistical channel condition model described in 3GPP TR 38.901 [38901]_, Table 7.4.2-1, for the Indoor-Open office scenario.
 
+ThreeGppNTNChannelConditionModel
+================================
+This is the base class for the 3GPP NTN channel condition models.
+It provides the possibility to updated the condition of each channel periodically,
+after a given time period which can be configured through the attribute "UpdatePeriod".
+If "UpdatePeriod" is set to 0, the channel condition is never updated.
+It has four derived classes implementing the channel condition models described in 3GPP TR 38.811 [38811]_
+for different propagation scenarios.
+
+ThreeGppDenseUrbanChannelConditionModel
+```````````````````````````````````````
+This implements the statistical channel condition model described in 3GPP TR 38.811 [38811]_,
+Table 6.6.1-1, for the Dense Urban scenario.
+
+ThreeGppUrbanChannelConditionModel
+``````````````````````````````````
+This implements the statistical channel condition model described in 3GPP TR 38.811 [38811]_,
+Table 6.6.1-1, for the Urban scenario.
+
+ThreeGppSuburbanStreetCanyonChannelConditionModel
+`````````````````````````````````````````````````
+This implements the statistical channel condition model described in 3GPP TR 38.811 [38811]_,
+Table 6.6.1-1, for the Suburban scenario.
+
+ThreeGppRuralChannelConditionModel
+``````````````````````````````````
+This implements the statistical channel condition model described in 3GPP TR 38.811 [38811]_,
+Table 6.6.1-1, for the Rural office scenario.
+
+
 Testing
 =======
 The test suite :cpp:class:`ChannelConditionModelsTestSuite` contains a single test case:
@@ -1036,3 +1111,5 @@ References
 .. [Boban2016Modeling]  M. Boban,  X. Gong, and  W. Xu, “Modeling the evolution
    of line-of-sight blockage for V2V channels,” in IEEE 84th Vehicular Technology
    Conference (VTC-Fall), 2016.
+
+.. [38811] 3GPP. 2018. TR 38.811, Study on New Radio (NR) to support non-terrestrial networks, V15.4.0. (2020-09).
diff --git a/src/propagation/model/channel-condition-model.cc b/src/propagation/model/channel-condition-model.cc
index 34d9b0839..bc505d95e 100644
--- a/src/propagation/model/channel-condition-model.cc
+++ b/src/propagation/model/channel-condition-model.cc
@@ -20,9 +20,11 @@
 
 #include "ns3/boolean.h"
 #include "ns3/double.h"
+#include "ns3/geocentric-constant-position-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
+#include "ns3/pointer.h"
 #include "ns3/simulator.h"
 #include "ns3/string.h"
 
@@ -829,4 +831,293 @@ ThreeGppIndoorOpenOfficeChannelConditionModel::ComputePlos(Ptr<const MobilityMod
     return pLos;
 }
 
+// ------------------------------------------------------------------------- //
+// LOS probabilities from table 6.6.1-1 of 3GPP 38.811
+
+static const std::map<int, double> DenseUrbanLOSProb{
+    {10, {28.2}},
+    {20, {33.1}},
+    {30, {39.8}},
+    {40, {46.8}},
+    {50, {53.7}},
+    {60, {61.2}},
+    {70, {73.8}},
+    {80, {82.0}},
+    {90, {98.1}},
+};
+
+static const std::map<int, double> UrbanLOSProb{
+    {10, {24.6}},
+    {20, {38.6}},
+    {30, {49.3}},
+    {40, {61.3}},
+    {50, {72.6}},
+    {60, {80.5}},
+    {70, {91.9}},
+    {80, {96.8}},
+    {90, {99.2}},
+};
+
+static const std::map<int, double> SuburbanRuralLOSProb{
+    {10, {78.2}},
+    {20, {86.9}},
+    {30, {91.9}},
+    {40, {92.9}},
+    {50, {93.5}},
+    {60, {94.0}},
+    {70, {94.9}},
+    {80, {95.2}},
+    {90, {99.8}},
+};
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNDenseUrbanChannelConditionModel);
+
+TypeId
+ThreeGppNTNDenseUrbanChannelConditionModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNDenseUrbanChannelConditionModel")
+                            .SetParent<ThreeGppChannelConditionModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNDenseUrbanChannelConditionModel>();
+    return tid;
+}
+
+ThreeGppNTNDenseUrbanChannelConditionModel::ThreeGppNTNDenseUrbanChannelConditionModel()
+    : ThreeGppChannelConditionModel()
+{
+}
+
+ThreeGppNTNDenseUrbanChannelConditionModel::~ThreeGppNTNDenseUrbanChannelConditionModel()
+{
+}
+
+double
+ThreeGppNTNDenseUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
+                                                        Ptr<const MobilityModel> b) const
+{
+    double elevAngle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+    if (aNTNMob->GetGeographicPosition().z <
+        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    {
+        elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
+    }
+    else // a is the HAPS/Satellite
+    {
+        elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
+    }
+
+    int elevAngleQuantized =
+        (elevAngle < 10)
+            ? 10
+            : round(elevAngle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90.
+
+    // compute the LOS probability (see 3GPP TR 38.811, Table 6.6.1-1)
+    // Reference elevation angles are provided from 10° to 90° with a 10° step.
+    // For an UE-to-satellite or UE-to-HAPS link, the LOS probability is thus taken
+    // from the nearest reference elevation angle.
+    double pLos = 0.0;
+    pLos = DenseUrbanLOSProb.at((elevAngleQuantized));
+
+    return pLos;
+}
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNUrbanChannelConditionModel);
+
+TypeId
+ThreeGppNTNUrbanChannelConditionModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNUrbanChannelConditionModel")
+                            .SetParent<ThreeGppChannelConditionModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNUrbanChannelConditionModel>();
+    return tid;
+}
+
+ThreeGppNTNUrbanChannelConditionModel::ThreeGppNTNUrbanChannelConditionModel()
+    : ThreeGppChannelConditionModel()
+{
+}
+
+ThreeGppNTNUrbanChannelConditionModel::~ThreeGppNTNUrbanChannelConditionModel()
+{
+}
+
+double
+ThreeGppNTNUrbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
+                                                   Ptr<const MobilityModel> b) const
+{
+    double elevAngle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+    if (aNTNMob->GetGeographicPosition().z <
+        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    {
+        elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
+    }
+    else // a is the HAPS/Satellite
+    {
+        elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
+    }
+
+    int elevAngleQuantized =
+        (elevAngle < 10)
+            ? 10
+            : round(elevAngle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90.
+
+    // compute the LOS probability (see 3GPP TR 38.811, Table 6.6.1-1)
+    double pLos = 0.0;
+
+    pLos = UrbanLOSProb.at((elevAngleQuantized));
+
+    return pLos;
+}
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNSuburbanChannelConditionModel);
+
+TypeId
+ThreeGppNTNSuburbanChannelConditionModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNSuburbanChannelConditionModel")
+                            .SetParent<ThreeGppChannelConditionModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNSuburbanChannelConditionModel>();
+    return tid;
+}
+
+ThreeGppNTNSuburbanChannelConditionModel::ThreeGppNTNSuburbanChannelConditionModel()
+    : ThreeGppChannelConditionModel()
+{
+}
+
+ThreeGppNTNSuburbanChannelConditionModel::~ThreeGppNTNSuburbanChannelConditionModel()
+{
+}
+
+double
+ThreeGppNTNSuburbanChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
+                                                      Ptr<const MobilityModel> b) const
+{
+    double elevAngle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+    if (aNTNMob->GetGeographicPosition().z <
+        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    {
+        elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
+    }
+    else // a is the HAPS/Satellite
+    {
+        elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
+    }
+
+    int elevAngleQuantized =
+        (elevAngle < 10)
+            ? 10
+            : round(elevAngle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90.
+
+    // compute the LOS probability (see 3GPP TR 38.811, Table 6.6.1-1)
+    double pLos = 0.0;
+
+    pLos = SuburbanRuralLOSProb.at((elevAngleQuantized));
+
+    return pLos;
+}
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNRuralChannelConditionModel);
+
+TypeId
+ThreeGppNTNRuralChannelConditionModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNRuralChannelConditionModel")
+                            .SetParent<ThreeGppChannelConditionModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNRuralChannelConditionModel>();
+    return tid;
+}
+
+ThreeGppNTNRuralChannelConditionModel::ThreeGppNTNRuralChannelConditionModel()
+    : ThreeGppChannelConditionModel()
+{
+}
+
+ThreeGppNTNRuralChannelConditionModel::~ThreeGppNTNRuralChannelConditionModel()
+{
+}
+
+double
+ThreeGppNTNRuralChannelConditionModel::ComputePlos(Ptr<const MobilityModel> a,
+                                                   Ptr<const MobilityModel> b) const
+{
+    double elevAngle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+    if (aNTNMob->GetGeographicPosition().z <
+        bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+    {
+        elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
+    }
+    else // a is the HAPS/Satellite
+    {
+        elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
+    }
+
+    int elevAngleQuantized =
+        (elevAngle < 10)
+            ? 10
+            : round(elevAngle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90.
+
+    // compute the LOS probability (see 3GPP TR 38.811, Table 6.6.1-1)
+    double pLos = 0.0;
+
+    pLos = SuburbanRuralLOSProb.at((elevAngleQuantized));
+
+    return pLos;
+}
+
 } // end namespace ns3
diff --git a/src/propagation/model/channel-condition-model.h b/src/propagation/model/channel-condition-model.h
index 73865c075..82d156e98 100644
--- a/src/propagation/model/channel-condition-model.h
+++ b/src/propagation/model/channel-condition-model.h
@@ -24,6 +24,7 @@
 #include "ns3/random-variable-stream.h"
 #include "ns3/vector.h"
 
+#include <map>
 #include <unordered_map>
 
 namespace ns3
@@ -782,6 +783,166 @@ class ThreeGppIndoorOpenOfficeChannelConditionModel : public ThreeGppChannelCond
     double ComputePlos(Ptr<const MobilityModel> a, Ptr<const MobilityModel> b) const override;
 };
 
+/**
+ * \ingroup propagation
+ *
+ * \brief Computes the channel condition for the NTN Dense Urban Scenario
+ *
+ * Computes the channel condition following the specifications for the
+ * Indoor Mixed Office scenario reported in Table 6.6.1-1 of 3GPP TR 38.811
+ */
+class ThreeGppNTNDenseUrbanChannelConditionModel : public ThreeGppChannelConditionModel
+{
+  public:
+    /**
+     * Get the type ID.
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor for the ThreeGppNTNDenseUrbanChannelConditionModel class
+     */
+    ThreeGppNTNDenseUrbanChannelConditionModel();
+
+    /**
+     * Destructor for the ThreeGppNTNDenseUrbanChannelConditionModel class
+     */
+    ~ThreeGppNTNDenseUrbanChannelConditionModel() override;
+
+  private:
+    /**
+     * Compute the LOS probability as specified in Table 6.6.1-1 of 3GPP TR 38.811
+     * for the NTN Dense Urban scenario.
+     *
+     * \param a tx mobility model
+     * \param b rx mobility model
+     * \return the LOS probability
+     */
+    double ComputePlos(Ptr<const MobilityModel> a, Ptr<const MobilityModel> b) const override;
+};
+
+/**
+ * \ingroup propagation
+ *
+ * \brief Computes the channel condition for the NTN Urban Scenario
+ *
+ * Computes the channel condition following the specifications for the
+ * Indoor Mixed Office scenario reported in Table 6.6.1-1 of 3GPP TR 38.811
+ */
+class ThreeGppNTNUrbanChannelConditionModel : public ThreeGppChannelConditionModel
+{
+  public:
+    /**
+     * Get the type ID.
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor for the ThreeGppNTNUrbanChannelConditionModel class
+     */
+    ThreeGppNTNUrbanChannelConditionModel();
+
+    /**
+     * Destructor for the ThreeGppNTNUrbanChannelConditionModel class
+     */
+    ~ThreeGppNTNUrbanChannelConditionModel() override;
+
+  private:
+    /**
+     * Compute the LOS probability as specified in Table 6.6.1-1 of 3GPP TR 38.811
+     * for the NTN Dense Urban scenario.
+     *
+     * \param a tx mobility model
+     * \param b rx mobility model
+     * \return the LOS probability
+     */
+    double ComputePlos(Ptr<const MobilityModel> a, Ptr<const MobilityModel> b) const override;
+};
+
+/**
+ * \ingroup propagation
+ *
+ * \brief Computes the channel condition for the NTN Suburban Scenario
+ *
+ * Computes the channel condition following the specifications for the
+ * Indoor Mixed Office scenario reported in Table 6.6.1-1 of 3GPP TR 38.811
+ */
+class ThreeGppNTNSuburbanChannelConditionModel : public ThreeGppChannelConditionModel
+{
+  public:
+    /**
+     * Get the type ID.
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor for the ThreeGppNTNSuburbanChannelConditionModel class
+     */
+    ThreeGppNTNSuburbanChannelConditionModel();
+
+    /**
+     * Destructor for the ThreeGppNTNSuburbanChannelConditionModel class
+     */
+    ~ThreeGppNTNSuburbanChannelConditionModel() override;
+
+  private:
+    /**
+     * Compute the LOS probability as specified in Table 6.6.1-1 of 3GPP TR 38.811
+     * for the NTN Dense Urban scenario.
+     *
+     * \param a tx mobility model
+     * \param b rx mobility model
+     * \return the LOS probability
+     */
+    double ComputePlos(Ptr<const MobilityModel> a, Ptr<const MobilityModel> b) const override;
+};
+
+/**
+ * \ingroup propagation
+ *
+ * \brief Computes the channel condition for the NTN Rural Scenario
+ *
+ * Computes the channel condition following the specifications for the
+ * Indoor Mixed Office scenario reported in Table 6.6.1-1 of 3GPP TR 38.811
+ */
+class ThreeGppNTNRuralChannelConditionModel : public ThreeGppChannelConditionModel
+{
+  public:
+    /**
+     * Get the type ID.
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor for the ThreeGppNTNRuralChannelConditionModel class
+     */
+    ThreeGppNTNRuralChannelConditionModel();
+
+    /**
+     * Destructor for the ThreeGppNTNRuralChannelConditionModel class
+     */
+    ~ThreeGppNTNRuralChannelConditionModel() override;
+
+  private:
+    /**
+     * Compute the LOS probability as specified in Table 6.6.1-1 of 3GPP TR 38.811
+     * for the NTN Dense Urban scenario.
+     *
+     * \param a tx mobility model
+     * \param b rx mobility model
+     * \return the LOS probability
+     */
+    double ComputePlos(Ptr<const MobilityModel> a, Ptr<const MobilityModel> b) const override;
+};
+
 } // namespace ns3
 
 #endif /* CHANNEL_CONDITION_MODEL_H */
diff --git a/src/propagation/model/three-gpp-propagation-loss-model.cc b/src/propagation/model/three-gpp-propagation-loss-model.cc
index 6e25f2b2e..a351d52c9 100644
--- a/src/propagation/model/three-gpp-propagation-loss-model.cc
+++ b/src/propagation/model/three-gpp-propagation-loss-model.cc
@@ -22,6 +22,7 @@
 
 #include "ns3/boolean.h"
 #include "ns3/double.h"
+#include "ns3/geocentric-constant-position-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -165,17 +166,8 @@ ThreeGppPropagationLossModel::DoCalcRxPower(double txPowerDbm,
     NS_ASSERT_MSG(m_channelConditionModel, "First set the channel condition model");
     Ptr<ChannelCondition> cond = m_channelConditionModel->GetChannelCondition(a, b);
 
-    // compute the 2D distance between a and b
-    double distance2d = Calculate2dDistance(a->GetPosition(), b->GetPosition());
-
-    // compute the 3D distance between a and b
-    double distance3d = CalculateDistance(a->GetPosition(), b->GetPosition());
-
-    // compute hUT and hBS
-    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
-
     double rxPow = txPowerDbm;
-    rxPow -= GetLoss(cond, distance2d, distance3d, heights.first, heights.second);
+    rxPow -= GetLoss(cond, a, b);
 
     if (m_shadowingEnabled)
     {
@@ -214,25 +206,23 @@ ThreeGppPropagationLossModel::DoCalcRxPower(double txPowerDbm,
 
 double
 ThreeGppPropagationLossModel::GetLoss(Ptr<ChannelCondition> cond,
-                                      double distance2d,
-                                      double distance3d,
-                                      double hUt,
-                                      double hBs) const
+                                      Ptr<MobilityModel> a,
+                                      Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
     double loss = 0;
     if (cond->GetLosCondition() == ChannelCondition::LosConditionValue::LOS)
     {
-        loss = GetLossLos(distance2d, distance3d, hUt, hBs);
+        loss = GetLossLos(a, b);
     }
     else if (cond->GetLosCondition() == ChannelCondition::LosConditionValue::NLOSv)
     {
-        loss = GetLossNlosv(distance2d, distance3d, hUt, hBs);
+        loss = GetLossNlosv(a, b);
     }
     else if (cond->GetLosCondition() == ChannelCondition::LosConditionValue::NLOS)
     {
-        loss = GetLossNlos(distance2d, distance3d, hUt, hBs);
+        loss = GetLossNlos(a, b);
     }
     else
     {
@@ -402,10 +392,7 @@ ThreeGppPropagationLossModel::DoIsO2iLowPenetrationLoss(Ptr<const ChannelConditi
 }
 
 double
-ThreeGppPropagationLossModel::GetLossNlosv(double distance2D,
-                                           double distance3D,
-                                           double hUt,
-                                           double hBs) const
+ThreeGppPropagationLossModel::GetLossNlosv(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
     NS_FATAL_ERROR("Unsupported channel condition (NLOSv)");
@@ -590,15 +577,28 @@ ThreeGppRmaPropagationLossModel::DoIsO2iLowPenetrationLoss(Ptr<const ChannelCond
 }
 
 double
-ThreeGppRmaPropagationLossModel::GetLossLos(double distance2D,
-                                            double distance3D,
-                                            double hUt,
-                                            double hBs) const
+ThreeGppRmaPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
     NS_ASSERT_MSG(m_frequency <= 30.0e9,
                   "RMa scenario is valid for frequencies between 0.5 and 30 GHz.");
 
+    double hBs = 0;
+    double hUt = 0;
+    double distance2D = Calculate2dDistance(a->GetPosition(), b->GetPosition());
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
+
     // check if hBS and hUT are within the specified validity range
     if (hUt < 1.0 || hUt > 10.0)
     {
@@ -654,15 +654,28 @@ ThreeGppRmaPropagationLossModel::GetLossLos(double distance2D,
 }
 
 double
-ThreeGppRmaPropagationLossModel::GetLossNlos(double distance2D,
-                                             double distance3D,
-                                             double hUt,
-                                             double hBs) const
+ThreeGppRmaPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
     NS_ASSERT_MSG(m_frequency <= 30.0e9,
                   "RMa scenario is valid for frequencies between 0.5 and 30 GHz.");
 
+    double hBs = 0;
+    double hUt = 0;
+    double distance2D = Calculate2dDistance(a->GetPosition(), b->GetPosition());
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
+
     // check if hBs and hUt are within the validity range
     if (hUt < 1.0 || hUt > 10.0)
     {
@@ -699,7 +712,7 @@ ThreeGppRmaPropagationLossModel::GetLossNlos(double distance2D,
                     (43.42 - 3.1 * log10(hBs)) * (log10(distance3D) - 3.0) +
                     20.0 * log10(m_frequency / 1e9) - (3.2 * pow(log10(11.75 * hUt), 2) - 4.97);
 
-    double loss = std::max(GetLossLos(distance2D, distance3D, hUt, hBs), plNlos);
+    double loss = std::max(GetLossLos(a, b), plNlos);
 
     NS_LOG_DEBUG("Loss " << loss);
 
@@ -850,13 +863,26 @@ ThreeGppUmaPropagationLossModel::GetBpDistance(double hUt, double hBs, double di
 }
 
 double
-ThreeGppUmaPropagationLossModel::GetLossLos(double distance2D,
-                                            double distance3D,
-                                            double hUt,
-                                            double hBs) const
+ThreeGppUmaPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double hBs = 0;
+    double hUt = 0;
+    double distance2D = Calculate2dDistance(a->GetPosition(), b->GetPosition());
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
+
     // check if hBS and hUT are within the validity range
     if (hUt < 1.5 || hUt > 22.5)
     {
@@ -918,13 +944,26 @@ ThreeGppUmaPropagationLossModel::GetO2iDistance2dIn() const
 }
 
 double
-ThreeGppUmaPropagationLossModel::GetLossNlos(double distance2D,
-                                             double distance3D,
-                                             double hUt,
-                                             double hBs) const
+ThreeGppUmaPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double hBs = 0;
+    double hUt = 0;
+    double distance2D = Calculate2dDistance(a->GetPosition(), b->GetPosition());
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
+
     // check if hBS and hUT are within the vaalidity range
     if (hUt < 1.5 || hUt > 22.5)
     {
@@ -957,7 +996,7 @@ ThreeGppUmaPropagationLossModel::GetLossNlos(double distance2D,
     // compute the pathloss
     double plNlos =
         13.54 + 39.08 * log10(distance3D) + 20.0 * log10(m_frequency / 1e9) - 0.6 * (hUt - 1.5);
-    double loss = std::max(GetLossLos(distance2D, distance3D, hUt, hBs), plNlos);
+    double loss = std::max(GetLossLos(a, b), plNlos);
     NS_LOG_DEBUG("Loss " << loss);
 
     return loss;
@@ -1074,13 +1113,27 @@ ThreeGppUmiStreetCanyonPropagationLossModel::GetO2iDistance2dIn() const
 }
 
 double
-ThreeGppUmiStreetCanyonPropagationLossModel::GetLossLos(double distance2D,
-                                                        double distance3D,
-                                                        double hUt,
-                                                        double hBs) const
+ThreeGppUmiStreetCanyonPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
+                                                        Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double hBs = 0;
+    double hUt = 0;
+    double distance2D = Calculate2dDistance(a->GetPosition(), b->GetPosition());
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
+
     // check if hBS and hUT are within the validity range
     if (hUt < 1.5 || hUt >= 10.0)
     {
@@ -1135,13 +1188,27 @@ ThreeGppUmiStreetCanyonPropagationLossModel::GetLossLos(double distance2D,
 }
 
 double
-ThreeGppUmiStreetCanyonPropagationLossModel::GetLossNlos(double distance2D,
-                                                         double distance3D,
-                                                         double hUt,
-                                                         double hBs) const
+ThreeGppUmiStreetCanyonPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
+                                                         Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double hBs = 0;
+    double hUt = 0;
+    double distance2D = Calculate2dDistance(a->GetPosition(), b->GetPosition());
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
+
     // check if hBS and hUT are within the validity range
     if (hUt < 1.5 || hUt >= 10.0)
     {
@@ -1175,7 +1242,7 @@ ThreeGppUmiStreetCanyonPropagationLossModel::GetLossNlos(double distance2D,
     // compute the pathloss
     double plNlos =
         22.4 + 35.3 * log10(distance3D) + 21.3 * log10(m_frequency / 1e9) - 0.3 * (hUt - 1.5);
-    double loss = std::max(GetLossLos(distance2D, distance3D, hUt, hBs), plNlos);
+    double loss = std::max(GetLossLos(a, b), plNlos);
     NS_LOG_DEBUG("Loss " << loss);
 
     return loss;
@@ -1295,13 +1362,13 @@ ThreeGppIndoorOfficePropagationLossModel::GetO2iDistance2dIn() const
 }
 
 double
-ThreeGppIndoorOfficePropagationLossModel::GetLossLos(double /* distance2D */,
-                                                     double distance3D,
-                                                     double /* hUt */,
-                                                     double /* hBs */) const
+ThreeGppIndoorOfficePropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
+                                                     Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
     // check if the distance is outside the validity range
     if (distance3D < 1.0 || distance3D > 150.0)
     {
@@ -1319,13 +1386,13 @@ ThreeGppIndoorOfficePropagationLossModel::GetLossLos(double /* distance2D */,
 }
 
 double
-ThreeGppIndoorOfficePropagationLossModel::GetLossNlos(double distance2D,
-                                                      double distance3D,
-                                                      double hUt,
-                                                      double hBs) const
+ThreeGppIndoorOfficePropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
+                                                      Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
     // check if the distance is outside the validity range
     if (distance3D < 1.0 || distance3D > 150.0)
     {
@@ -1336,7 +1403,7 @@ ThreeGppIndoorOfficePropagationLossModel::GetLossNlos(double distance2D,
 
     // compute the pathloss
     double plNlos = 17.3 + 38.3 * log10(distance3D) + 24.9 * log10(m_frequency / 1e9);
-    double loss = std::max(GetLossLos(distance2D, distance3D, hUt, hBs), plNlos);
+    double loss = std::max(GetLossLos(a, b), plNlos);
 
     NS_LOG_DEBUG("Loss " << loss);
 
@@ -1393,4 +1460,1294 @@ ThreeGppIndoorOfficePropagationLossModel::GetShadowingCorrelationDistance(
     return correlationDistance;
 }
 
+// ------------------------------------------------------------------------- //
+/**
+ * The enumerator used for code clarity when performing parameter assignment in the GetLoss Methods
+ */
+enum SFCL_params
+{
+    S_LOS_sigF,
+    S_NLOS_sigF,
+    S_NLOS_CL,
+    Ka_LOS_sigF,
+    Ka_NLOS_sigF,
+    Ka_NLOS_CL,
+};
+
+/**
+ * The map containing the threegpp value reagarding Shadow Fading and Clutter Loss tables for the
+ * NTN Dense Urban scenario
+ */
+const std::map<int, std::vector<float>> SFCL_DenseUrban{
+    {10, {3.5, 15.5, 34.3, 2.9, 17.1, 44.3}},
+    {20, {3.4, 13.9, 30.9, 2.4, 17.1, 39.9}},
+    {30, {2.9, 12.4, 29.0, 2.7, 15.6, 37.5}},
+    {40, {3.0, 11.7, 27.7, 2.4, 14.6, 35.8}},
+    {50, {3.1, 10.6, 26.8, 2.4, 14.2, 34.6}},
+    {60, {2.7, 10.5, 26.2, 2.7, 12.6, 33.8}},
+    {70, {2.5, 10.1, 25.8, 2.6, 12.1, 33.3}},
+    {80, {2.3, 9.2, 25.5, 2.8, 12.3, 33.0}},
+    {90, {1.2, 9.2, 25.5, 0.6, 12.3, 32.9}},
+};
+
+/**
+ * The map containing the threegpp value reagarding Shadow Fading and Clutter Loss tables for the
+ * NTN Urban scenario
+ */
+const std::map<int, std::vector<float>> SFCL_Urban{
+    {10, {4, 6, 34.3, 4, 6, 44.3}},
+    {20, {4, 6, 30.9, 4, 6, 39.9}},
+    {30, {4, 6, 29.0, 4, 6, 37.5}},
+    {40, {4, 6, 27.7, 4, 6, 35.8}},
+    {50, {4, 6, 26.8, 4, 6, 34.6}},
+    {60, {4, 6, 26.2, 4, 6, 33.8}},
+    {70, {4, 6, 25.8, 4, 6, 33.3}},
+    {80, {4, 6, 25.5, 4, 6, 33.0}},
+    {90, {4, 6, 25.5, 4, 6, 32.9}},
+};
+
+/**
+ * The map containing the threegpp value reagarding Shadow Fading and Clutter Loss tables for the
+ * NTN Suburban and Rural scenarios
+ */
+const std::map<int, std::vector<float>> SFCL_SuburbanRural{
+    {10, {1.79, 8.93, 19.52, 1.9, 10.7, 29.5}},
+    {20, {1.14, 9.08, 18.17, 1.6, 10.0, 24.6}},
+    {30, {1.14, 8.78, 18.42, 1.9, 11.2, 21.9}},
+    {40, {0.92, 10.25, 18.28, 2.3, 11.6, 20.0}},
+    {50, {1.42, 10.56, 18.63, 2.7, 11.8, 18.7}},
+    {60, {1.56, 10.74, 17.68, 3.1, 10.8, 17.8}},
+    {70, {0.85, 10.17, 16.5, 3.0, 10.8, 17.2}},
+    {80, {0.72, 11.52, 16.3, 3.6, 10.8, 16.9}},
+    {90, {0.72, 11.52, 16.3, 0.4, 10.8, 16.8}},
+};
+
+/**
+ * Array containing the attenuation given by atmospheric absorption. 100 samples are selected for
+ * frequencies from 1GHz to 100GHz. In order to get the atmospheric absorption loss for a given
+ * frequency f: 1- round f to the closest integer between 0 and 100. 2- use the obtained integer to
+ * access the corresponding element in the array, that will give the attenuation at that frequency.
+ * Data is obtained form ITU-R P.676 Figure 6.
+ */
+const double atmosphericAbsorption[101] = {
+    0,        0.0300,   0.0350,  0.0380,  0.0390,  0.0410,  0.0420,  0.0450,  0.0480,   0.0500,
+    0.0530,   0.0587,   0.0674,  0.0789,  0.0935,  0.1113,  0.1322,  0.1565,  0.1841,   0.2153,
+    0.2500,   0.3362,   0.4581,  0.5200,  0.5200,  0.5000,  0.4500,  0.3850,  0.3200,   0.2700,
+    0.2500,   0.2517,   0.2568,  0.2651,  0.2765,  0.2907,  0.3077,  0.3273,  0.3493,   0.3736,
+    0.4000,   0.4375,   0.4966,  0.5795,  0.6881,  0.8247,  0.9912,  1.1900,  1.4229,   1.6922,
+    2.0000,   4.2654,   10.1504, 19.2717, 31.2457, 45.6890, 62.2182, 80.4496, 100.0000, 140.0205,
+    170.0000, 100.0000, 78.1682, 59.3955, 43.5434, 30.4733, 20.0465, 12.1244, 6.5683,   3.2397,
+    2.0000,   1.7708,   1.5660,  1.3858,  1.2298,  1.0981,  0.9905,  0.9070,  0.8475,   0.8119,
+    0.8000,   0.8000,   0.8000,  0.8000,  0.8000,  0.8000,  0.8000,  0.8000,  0.8000,   0.8000,
+    0.8000,   0.8029,   0.8112,  0.8243,  0.8416,  0.8625,  0.8864,  0.9127,  0.9408,   0.9701,
+    1.0000};
+
+/**
+ * Map containing the Tropospheric attenuation in dB with 99% probability at 20 GHz in Toulouse
+ * used for tropospheric scintillation losses. From Table 6.6.6.2.1-1 of 3GPP TR 38.811.
+ */
+const std::map<int, float> troposphericScintillationLoss{
+    {10, {1.08}},
+    {20, {0.48}},
+    {30, {0.30}},
+    {40, {0.22}},
+    {50, {0.17}},
+    {60, {0.13}},
+    {70, {0.12}},
+    {80, {0.12}},
+    {90, {0.12}},
+};
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNDenseUrbanPropagationLossModel);
+
+TypeId
+ThreeGppNTNDenseUrbanPropagationLossModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNDenseUrbanPropagationLossModel")
+                            .SetParent<ThreeGppPropagationLossModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNDenseUrbanPropagationLossModel>();
+    return tid;
+}
+
+ThreeGppNTNDenseUrbanPropagationLossModel::ThreeGppNTNDenseUrbanPropagationLossModel()
+    : ThreeGppPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+
+    // set a default channel condition model
+    m_channelConditionModel =
+        CreateObject<ThreeGppRmaChannelConditionModel>(); // TODO: Needs NTN channel condition model
+
+    m_SFCL_DenseUrban = &SFCL_DenseUrban;
+}
+
+ThreeGppNTNDenseUrbanPropagationLossModel::~ThreeGppNTNDenseUrbanPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+double
+ThreeGppNTNDenseUrbanPropagationLossModel::GetO2iDistance2dIn() const
+{
+    abort();
+}
+
+double
+ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
+                                                      Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
+                                                       Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Clutter Loss
+    if (m_frequency < 13.0e9)
+    {
+        loss += (*m_SFCL_DenseUrban)
+                    .at(elev_angle_quantized)[SFCL_params::S_NLOS_CL]; // Get the Clutter Loss for
+                                                                       // the S Band
+    }
+    else
+    {
+        loss += (*m_SFCL_DenseUrban)
+                    .at(elev_angle_quantized)[SFCL_params::Ka_NLOS_CL]; // Get the Clutter Loss for
+                                                                        // the Ka Band
+    }
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNDenseUrbanPropagationLossModel::GetShadowingStd(
+    Ptr<MobilityModel> a,
+    Ptr<MobilityModel> b,
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double shadowingStd;
+
+    std::string freq_band = (m_frequency < 13.0e9) ? "S" : "Ka";
+    double elev_angle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+
+    // Assign Shadwoing Standard Deviation according to table 6.6.2-1
+    if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_DenseUrban).at(elev_angle_quantized)[SFCL_params::S_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_DenseUrban).at(elev_angle_quantized)[SFCL_params::Ka_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_DenseUrban).at(elev_angle_quantized)[SFCL_params::S_NLOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_DenseUrban).at(elev_angle_quantized)[SFCL_params::Ka_NLOS_sigF];
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return shadowingStd;
+}
+
+double
+ThreeGppNTNDenseUrbanPropagationLossModel::GetShadowingCorrelationDistance(
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double correlationDistance;
+
+    // See 3GPP TR 38.811, Table 6.7.2-1a/b and Table 6.7.2-2a/b
+    if (cond == ChannelCondition::LosConditionValue::LOS)
+    {
+        correlationDistance = 37;
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS)
+    {
+        correlationDistance = 50;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return correlationDistance;
+}
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNUrbanPropagationLossModel);
+
+TypeId
+ThreeGppNTNUrbanPropagationLossModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNUrbanPropagationLossModel")
+                            .SetParent<ThreeGppPropagationLossModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNUrbanPropagationLossModel>();
+    return tid;
+}
+
+ThreeGppNTNUrbanPropagationLossModel::ThreeGppNTNUrbanPropagationLossModel()
+    : ThreeGppPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+
+    // set a default channel condition model
+    m_channelConditionModel =
+        CreateObject<ThreeGppRmaChannelConditionModel>(); // TODO: Needs NTN channel condition model
+
+    m_SFCL_Urban = &SFCL_Urban;
+}
+
+ThreeGppNTNUrbanPropagationLossModel::~ThreeGppNTNUrbanPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+double
+ThreeGppNTNUrbanPropagationLossModel::GetO2iDistance2dIn() const
+{
+    abort();
+}
+
+double
+ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Clutter Loss
+    if (m_frequency < 13.0e9)
+    {
+        loss +=
+            (*m_SFCL_Urban).at(elev_angle_quantized)[SFCL_params::S_NLOS_CL]; // Get the Clutter
+                                                                              // Loss for the S Band
+    }
+    else
+    {
+        loss += (*m_SFCL_Urban)
+                    .at(elev_angle_quantized)[SFCL_params::Ka_NLOS_CL]; // Get the Clutter Loss for
+                                                                        // the Ka Band
+    }
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNUrbanPropagationLossModel::GetShadowingStd(
+    Ptr<MobilityModel> a,
+    Ptr<MobilityModel> b,
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double shadowingStd;
+
+    std::string freq_band = (m_frequency < 13.0e9) ? "S" : "Ka";
+
+    double elev_angle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+
+    // Assign Shadwoing Standard Deviation according to table 6.6.2-1
+    if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_Urban).at(elev_angle_quantized)[SFCL_params::S_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_Urban).at(elev_angle_quantized)[SFCL_params::Ka_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_Urban).at(elev_angle_quantized)[SFCL_params::S_NLOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_Urban).at(elev_angle_quantized)[SFCL_params::Ka_NLOS_sigF];
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return shadowingStd;
+}
+
+double
+ThreeGppNTNUrbanPropagationLossModel::GetShadowingCorrelationDistance(
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double correlationDistance;
+
+    // See 3GPP TR 38.811, Table 6.7.2-3a/b and Table 6.7.2-3a/b
+    if (cond == ChannelCondition::LosConditionValue::LOS)
+    {
+        correlationDistance = 37;
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS)
+    {
+        correlationDistance = 50;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return correlationDistance;
+}
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNSuburbanPropagationLossModel);
+
+TypeId
+ThreeGppNTNSuburbanPropagationLossModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNSuburbanPropagationLossModel")
+                            .SetParent<ThreeGppPropagationLossModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNSuburbanPropagationLossModel>();
+    return tid;
+}
+
+ThreeGppNTNSuburbanPropagationLossModel::ThreeGppNTNSuburbanPropagationLossModel()
+    : ThreeGppPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+
+    // set a default channel condition model
+    m_channelConditionModel =
+        CreateObject<ThreeGppRmaChannelConditionModel>(); // TODO: Needs NTN channel condition model
+
+    m_SFCL_SuburbanRural = &SFCL_SuburbanRural;
+}
+
+ThreeGppNTNSuburbanPropagationLossModel::~ThreeGppNTNSuburbanPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+double
+ThreeGppNTNSuburbanPropagationLossModel::GetO2iDistance2dIn() const
+{
+    abort();
+}
+
+double
+ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
+                                                    Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+
+    return loss;
+}
+
+double
+ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
+                                                     Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Clutter Loss
+    if (m_frequency < 13.0e9)
+    {
+        loss += (*m_SFCL_SuburbanRural)
+                    .at(elev_angle_quantized)[SFCL_params::S_NLOS_CL]; // Get the Clutter Loss for
+                                                                       // the S Band
+    }
+    else
+    {
+        loss += (*m_SFCL_SuburbanRural)
+                    .at(elev_angle_quantized)[SFCL_params::Ka_NLOS_CL]; // Get the Clutter Loss for
+                                                                        // the Ka Band
+    }
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNSuburbanPropagationLossModel::GetShadowingStd(
+    Ptr<MobilityModel> a,
+    Ptr<MobilityModel> b,
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double shadowingStd;
+
+    std::string freq_band = (m_frequency < 13.0e9) ? "S" : "Ka";
+
+    double elev_angle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+
+    // Assign Shadwoing Standard Deviation according to table 6.6.2-1
+    if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::S_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::Ka_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::S_NLOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::Ka_NLOS_sigF];
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return shadowingStd;
+}
+
+double
+ThreeGppNTNSuburbanPropagationLossModel::GetShadowingCorrelationDistance(
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double correlationDistance;
+
+    // See 3GPP TR 38.811, Table 6.7.2-5a/b and Table 6.7.2-6a/b
+    if (cond == ChannelCondition::LosConditionValue::LOS)
+    {
+        correlationDistance = 37;
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS)
+    {
+        correlationDistance = 50;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return correlationDistance;
+}
+
+// ------------------------------------------------------------------------- //
+
+NS_OBJECT_ENSURE_REGISTERED(ThreeGppNTNRuralPropagationLossModel);
+
+TypeId
+ThreeGppNTNRuralPropagationLossModel::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::ThreeGppNTNRuralPropagationLossModel")
+                            .SetParent<ThreeGppPropagationLossModel>()
+                            .SetGroupName("Propagation")
+                            .AddConstructor<ThreeGppNTNRuralPropagationLossModel>();
+    return tid;
+}
+
+ThreeGppNTNRuralPropagationLossModel::ThreeGppNTNRuralPropagationLossModel()
+    : ThreeGppPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+
+    // set a default channel condition model
+    m_channelConditionModel =
+        CreateObject<ThreeGppRmaChannelConditionModel>(); // TODO: Needs NTN channel condition model
+
+    m_SFCL_SuburbanRural = &SFCL_SuburbanRural;
+}
+
+ThreeGppNTNRuralPropagationLossModel::~ThreeGppNTNRuralPropagationLossModel()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+double
+ThreeGppNTNRuralPropagationLossModel::GetO2iDistance2dIn() const
+{
+    abort();
+}
+
+double
+ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    NS_LOG_UNCOND("Elevation Angle: " << elev_angle);
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT_MSG(m_frequency <= 100.0e9,
+                  "NTN communications are valid for frequencies between 0.5 and 100 GHz.");
+    double elev_angle = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+    // Check 3D distance?
+    // Check hBS and hUE?
+    // Others checks?
+
+    // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
+    double loss = 0;
+    loss = 32.45 + 20 * log10(m_frequency / 1e9) + 20 * log10(distance3D); // Basic FSPL
+
+    // Apply Clutter Loss
+    if (m_frequency < 13.0e9)
+    {
+        loss += (*m_SFCL_SuburbanRural)
+                    .at(elev_angle_quantized)[SFCL_params::S_NLOS_CL]; // Get the Clutter Loss for
+                                                                       // the S Band
+    }
+    else
+    {
+        loss += (*m_SFCL_SuburbanRural)
+                    .at(elev_angle_quantized)[SFCL_params::Ka_NLOS_CL]; // Get the Clutter Loss for
+                                                                        // the Ka Band
+    }
+
+    // Apply Atmospheric Absorption Loss 3GPP 38.811 6.6.4
+    if ((elev_angle < 10 && m_frequency > 1e9) || m_frequency >= 10e9)
+    {
+        int m_rounded_frequency = round(m_frequency / 10e8);
+        loss += atmosphericAbsorption[m_rounded_frequency] / sin(elev_angle * (M_PI / 180));
+    }
+
+    // Apply Ionospheric Scintillation Loss 3GPP 28.811 6.6.6.1-4
+    if (m_frequency < 6e9)
+    {
+        loss += 6.22 / (pow(m_frequency / 1e9, 1.5));
+    }
+
+    // Apply Troposhperic Scintillation Loss 3GPP 28.811 6.6.6.2
+    if (m_frequency > 6e9)
+    {
+        loss += troposphericScintillationLoss.at(elev_angle_quantized);
+    }
+
+    NS_LOG_DEBUG("Loss " << loss);
+    return loss;
+}
+
+double
+ThreeGppNTNRuralPropagationLossModel::GetShadowingStd(
+    Ptr<MobilityModel> a,
+    Ptr<MobilityModel> b,
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double shadowingStd;
+
+    std::string freq_band = (m_frequency < 13.0e9) ? "S" : "Ka";
+
+    double elev_angle = 0;
+
+    Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
+    Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
+
+    if (DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(a)) &&
+        DynamicCast<GeocentricConstantPositionMobilityModel>(ConstCast<MobilityModel>(
+            b))) // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
+    {
+        Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+        Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+            DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+        if (aNTNMob->GetGeographicPosition().z <
+            bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+        {
+            elev_angle = aNTNMob->GetElevationAngle(bNTNMob);
+        }
+        else // a is the HAPS/Satellite
+        {
+            elev_angle = bNTNMob->GetElevationAngle(aNTNMob);
+        }
+    }
+    else
+    {
+        NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+    }
+
+    int elev_angle_quantized =
+        (elev_angle < 10)
+            ? 10
+            : round(elev_angle / 10) *
+                  10; // Round the elevation angle into a two-digits integer between 10 and 90..
+    NS_ASSERT_MSG((elev_angle_quantized >= 10) && (elev_angle_quantized <= 90),
+                  "Invalid elevation angle!");
+
+    // Assign Shadwoing Standard Deviation according to table 6.6.2-1
+    if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::S_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::LOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::Ka_LOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "S")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::S_NLOS_sigF];
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS && freq_band == "Ka")
+    {
+        shadowingStd = (*m_SFCL_SuburbanRural).at(elev_angle_quantized)[SFCL_params::Ka_NLOS_sigF];
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return shadowingStd;
+}
+
+double
+ThreeGppNTNRuralPropagationLossModel::GetShadowingCorrelationDistance(
+    ChannelCondition::LosConditionValue cond) const
+{
+    NS_LOG_FUNCTION(this);
+    double correlationDistance;
+
+    // See 3GPP TR 38.811, Table 6.7.2-7a/b and Table 6.7.2-8a/b
+    if (cond == ChannelCondition::LosConditionValue::LOS)
+    {
+        correlationDistance = 37;
+    }
+    else if (cond == ChannelCondition::LosConditionValue::NLOS)
+    {
+        correlationDistance = 120;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown channel condition");
+    }
+
+    return correlationDistance;
+}
+
 } // namespace ns3
diff --git a/src/propagation/model/three-gpp-propagation-loss-model.h b/src/propagation/model/three-gpp-propagation-loss-model.h
index 646b77dd2..d986944e2 100644
--- a/src/propagation/model/three-gpp-propagation-loss-model.h
+++ b/src/propagation/model/three-gpp-propagation-loss-model.h
@@ -105,31 +105,29 @@ class ThreeGppPropagationLossModel : public PropagationLossModel
     /**
      * \brief Computes the pathloss between a and b
      * \param cond the channel condition
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLoss(Ptr<ChannelCondition> cond,
-                   double distance2D,
-                   double distance3D,
-                   double hUt,
-                   double hBs) const;
+    double GetLoss(Ptr<ChannelCondition> cond, Ptr<MobilityModel> a, Ptr<MobilityModel> b) const;
 
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    virtual double GetLossLos(double distance2D,
-                              double distance3D,
-                              double hUt,
-                              double hBs) const = 0;
+    virtual double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const = 0;
+
+    /**
+     * \brief Computes the pathloss between a and b considering that the line of
+     *        sight is obstructed
+     * \param a tx mobility model
+     * \param b rx mobility model
+     * \return pathloss value in dB
+     */
+    virtual double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const = 0;
 
     /**
      * \brief Returns the minimum of the two independently generated distances
@@ -195,41 +193,15 @@ class ThreeGppPropagationLossModel : public PropagationLossModel
      */
     virtual bool DoIsO2iLowPenetrationLoss(Ptr<const ChannelCondition> cond) const;
 
-    /**
-     * \brief Computes the pathloss between a and b considering that the line of
-     *        sight is obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
-     * \return pathloss value in dB
-     */
-    virtual double GetLossNlos(double distance2D,
-                               double distance3D,
-                               double hUt,
-                               double hBs) const = 0;
-
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed by a vehicle. By default it raises an error to
      *        avoid misuse.
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    virtual double GetLossNlosv(double distance2D, double distance3D, double hUt, double hBs) const;
-
-    /**
-     * \brief Determines hUT and hBS. The default implementation assumes that
-     *        the tallest node is the BS and the smallest is the UT. The derived classes
-     * can change the default behavior by overriding this method.
-     * \param za the height of the first node in meters
-     * \param zb the height of the second node in meters
-     * \return std::pair of heights in meters, the first element is hUt and the second is hBs
-     */
-    virtual std::pair<double, double> GetUtAndBsHeights(double za, double zb) const;
+    virtual double GetLossNlosv(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const;
 
     /**
      * \brief Retrieves the shadowing value by looking at m_shadowingMap.
@@ -301,6 +273,16 @@ class ThreeGppPropagationLossModel : public PropagationLossModel
      */
     static double Calculate2dDistance(Vector a, Vector b);
 
+    /**
+     * \brief Determines hUT and hBS. The default implementation assumes that
+     *        the tallest node is the BS and the smallest is the UT. The derived classes
+     * can change the default behavior by overriding this method.
+     * \param za the height of the first node in meters
+     * \param zb the height of the second node in meters
+     * \return std::pair of heights in meters, the first element is hUt and the second is hBs
+     */
+    virtual std::pair<double, double> GetUtAndBsHeights(double za, double zb) const;
+
     Ptr<ChannelConditionModel> m_channelConditionModel; //!< pointer to the channel condition model
     double m_frequency;                                 //!< operating frequency in Hz
     bool m_shadowingEnabled;                            //!< enable/disable shadowing
@@ -374,13 +356,11 @@ class ThreeGppRmaPropagationLossModel : public ThreeGppPropagationLossModel
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossLos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the minimum of the two independently generated distances
@@ -407,13 +387,11 @@ class ThreeGppRmaPropagationLossModel : public ThreeGppPropagationLossModel
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossNlos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the shadow fading standard deviation
@@ -491,13 +469,11 @@ class ThreeGppUmaPropagationLossModel : public ThreeGppPropagationLossModel
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossLos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the minimum of the two independently generated distances
@@ -516,13 +492,11 @@ class ThreeGppUmaPropagationLossModel : public ThreeGppPropagationLossModel
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed.
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossNlos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the shadow fading standard deviation
@@ -590,13 +564,11 @@ class ThreeGppUmiStreetCanyonPropagationLossModel : public ThreeGppPropagationLo
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossLos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the minimum of the two independently generated distances
@@ -615,13 +587,11 @@ class ThreeGppUmiStreetCanyonPropagationLossModel : public ThreeGppPropagationLo
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed.
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossNlos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the shadow fading standard deviation
@@ -694,13 +664,11 @@ class ThreeGppIndoorOfficePropagationLossModel : public ThreeGppPropagationLossM
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossLos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the minimum of the two independently generated distances
@@ -719,13 +687,11 @@ class ThreeGppIndoorOfficePropagationLossModel : public ThreeGppPropagationLossM
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a tx mobility model
+     * \param b rx mobility model
      * \return pathloss value in dB
      */
-    double GetLossNlos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the shadow fading standard deviation
@@ -746,6 +712,260 @@ class ThreeGppIndoorOfficePropagationLossModel : public ThreeGppPropagationLossM
     double GetShadowingCorrelationDistance(ChannelCondition::LosConditionValue cond) const override;
 };
 
+/**
+ * \ingroup propagation
+ *
+ * \brief Implements the pathloss model defined in 3GPP TR 38.811, Table ????
+ *        for the NTN Dense Urban scenario.
+ */
+class ThreeGppNTNDenseUrbanPropagationLossModel : public ThreeGppPropagationLossModel
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor
+     */
+    ThreeGppNTNDenseUrbanPropagationLossModel();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNDenseUrbanPropagationLossModel() override;
+
+    /**
+     * \copydoc ThreeGppPropagationLossModel::GetO2iDistance2dIn
+     *  Does nothing in NTN scenarios.
+     */
+    double GetO2iDistance2dIn() const override;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     */
+    ThreeGppNTNDenseUrbanPropagationLossModel(const ThreeGppNTNDenseUrbanPropagationLossModel&) =
+        delete;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     * \returns the ThreeGppNTNDenseUrbanPropagationLossModel instance
+     */
+    ThreeGppNTNDenseUrbanPropagationLossModel& operator=(
+        const ThreeGppNTNDenseUrbanPropagationLossModel&) = delete;
+
+  private:
+    // Inherited
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetShadowingStd(Ptr<MobilityModel> a,
+                           Ptr<MobilityModel> b,
+                           ChannelCondition::LosConditionValue cond) const override;
+    double GetShadowingCorrelationDistance(ChannelCondition::LosConditionValue cond) const override;
+
+    /**
+     * \brief The nested map containing the Shadow Fading and
+     *        Clutter Loss values for the NTN Dense Urban scenario
+     */
+    const std::map<int, std::vector<float>>* m_SFCL_DenseUrban;
+};
+
+/**
+ * \ingroup propagation
+ *
+ * \brief Implements the pathloss model defined in 3GPP TR 38.811, Table ????
+ *        for the NTN Urban scenario.
+ */
+class ThreeGppNTNUrbanPropagationLossModel : public ThreeGppPropagationLossModel
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor
+     */
+    ThreeGppNTNUrbanPropagationLossModel();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNUrbanPropagationLossModel() override;
+
+    /**
+     * \copydoc ThreeGppPropagationLossModel::GetO2iDistance2dIn
+     *  Does nothing in NTN scenarios.
+     */
+    double GetO2iDistance2dIn() const override;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     */
+    ThreeGppNTNUrbanPropagationLossModel(const ThreeGppNTNUrbanPropagationLossModel&) = delete;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     * \returns the ThreeGppNTNUrbanPropagationLossModel instance
+     */
+    ThreeGppNTNUrbanPropagationLossModel& operator=(const ThreeGppNTNUrbanPropagationLossModel&) =
+        delete;
+
+  private:
+    // Inherited
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetShadowingStd(Ptr<MobilityModel> a,
+                           Ptr<MobilityModel> b,
+                           ChannelCondition::LosConditionValue cond) const override;
+    double GetShadowingCorrelationDistance(ChannelCondition::LosConditionValue cond) const override;
+
+    /**
+     * \brief The nested map containing the Shadow Fading and
+     *        Clutter Loss values for the NTN Urban scenario
+     */
+    const std::map<int, std::vector<float>>* m_SFCL_Urban;
+};
+
+/**
+ * \ingroup propagation
+ *
+ * \brief Implements the pathloss model defined in 3GPP TR 38.811, Table ????
+ *        for the NTN Suburban scenario.
+ */
+class ThreeGppNTNSuburbanPropagationLossModel : public ThreeGppPropagationLossModel
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor
+     */
+    ThreeGppNTNSuburbanPropagationLossModel();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNSuburbanPropagationLossModel() override;
+
+    /**
+     * \copydoc ThreeGppPropagationLossModel::GetO2iDistance2dIn
+     *  Does nothing in NTN scenarios.
+     */
+    double GetO2iDistance2dIn() const override;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     */
+    ThreeGppNTNSuburbanPropagationLossModel(const ThreeGppNTNSuburbanPropagationLossModel&) =
+        delete;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     * \returns the ThreeGppNTNSuburbanPropagationLossModel instance
+     */
+    ThreeGppNTNSuburbanPropagationLossModel& operator=(
+        const ThreeGppNTNSuburbanPropagationLossModel&) = delete;
+
+  private:
+    // Inherited
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetShadowingStd(Ptr<MobilityModel> a,
+                           Ptr<MobilityModel> b,
+                           ChannelCondition::LosConditionValue cond) const override;
+    double GetShadowingCorrelationDistance(ChannelCondition::LosConditionValue cond) const override;
+
+    /**
+     * \brief The nested map containing the Shadow Fading and
+     *        Clutter Loss values for the NTN Suburban and Rural scenario
+     */
+    const std::map<int, std::vector<float>>* m_SFCL_SuburbanRural;
+};
+
+/**
+ * \ingroup propagation
+ *
+ * \brief Implements the pathloss model defined in 3GPP TR 38.811, Table ????
+ *        for the NTN Rural scenario.
+ */
+class ThreeGppNTNRuralPropagationLossModel : public ThreeGppPropagationLossModel
+{
+  public:
+    /**
+     * \brief Get the type ID.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Constructor
+     */
+    ThreeGppNTNRuralPropagationLossModel();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNRuralPropagationLossModel() override;
+
+    /**
+     * \copydoc ThreeGppPropagationLossModel::GetO2iDistance2dIn
+     *  Does nothing in NTN scenarios.
+     */
+    double GetO2iDistance2dIn() const override;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     */
+    ThreeGppNTNRuralPropagationLossModel(const ThreeGppNTNRuralPropagationLossModel&) = delete;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Deleted in base class
+     * \returns the ThreeGppNTNRuralPropagationLossModel instance
+     */
+    ThreeGppNTNRuralPropagationLossModel& operator=(const ThreeGppNTNRuralPropagationLossModel&) =
+        delete;
+
+  private:
+    // Inherited
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
+    double GetShadowingStd(Ptr<MobilityModel> a,
+                           Ptr<MobilityModel> b,
+                           ChannelCondition::LosConditionValue cond) const override;
+    double GetShadowingCorrelationDistance(ChannelCondition::LosConditionValue cond) const override;
+
+    /**
+     * \brief The nested map containing the Shadow Fading and
+     *        Clutter Loss values for the NTN Suburban and Rural scenario
+     */
+    const std::map<int, std::vector<float>>* m_SFCL_SuburbanRural;
+};
+
 } // namespace ns3
 
 #endif /* THREE_GPP_PROPAGATION_LOSS_MODEL_H */
diff --git a/src/propagation/model/three-gpp-v2v-propagation-loss-model.cc b/src/propagation/model/three-gpp-v2v-propagation-loss-model.cc
index 2f1005204..5046de43f 100644
--- a/src/propagation/model/three-gpp-v2v-propagation-loss-model.cc
+++ b/src/propagation/model/three-gpp-v2v-propagation-loss-model.cc
@@ -66,13 +66,12 @@ ThreeGppV2vUrbanPropagationLossModel::~ThreeGppV2vUrbanPropagationLossModel()
 }
 
 double
-ThreeGppV2vUrbanPropagationLossModel::GetLossLos(double /* distance2D */,
-                                                 double distance3D,
-                                                 double /* hUt */,
-                                                 double /* hBs */) const
+ThreeGppV2vUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
     // compute the pathloss (see 3GPP TR 37.885, Table 6.2.1-1)
     double loss = 38.77 + 16.7 * log10(distance3D) + 18.2 * log10(m_frequency / 1e9);
 
@@ -88,26 +87,35 @@ ThreeGppV2vUrbanPropagationLossModel::GetO2iDistance2dIn() const
 }
 
 double
-ThreeGppV2vUrbanPropagationLossModel::GetLossNlosv(double distance2D,
-                                                   double distance3D,
-                                                   double hUt,
-                                                   double hBs) const
+ThreeGppV2vUrbanPropagationLossModel::GetLossNlosv(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
     // compute the pathloss (see 3GPP TR 37.885, Table 6.2.1-1)
-    double loss =
-        GetLossLos(distance2D, distance3D, hUt, hBs) + GetAdditionalNlosvLoss(distance3D, hUt, hBs);
+    double loss = GetLossLos(a, b) + GetAdditionalNlosvLoss(a, b);
 
     return loss;
 }
 
 double
-ThreeGppV2vUrbanPropagationLossModel::GetAdditionalNlosvLoss(double distance3D,
-                                                             double hUt,
-                                                             double hBs) const
+ThreeGppV2vUrbanPropagationLossModel::GetAdditionalNlosvLoss(Ptr<MobilityModel> a,
+                                                             Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
+    double hBs = 0;
+    double hUt = 0;
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+    std::pair<double, double> heights = GetUtAndBsHeights(a->GetPosition().z, b->GetPosition().z);
+    if (heights.first > heights.second)
+    {
+        hBs = heights.first;
+        hUt = heights.second;
+    }
+    else
+    {
+        hBs = heights.second;
+        hUt = heights.first;
+    }
     // From TR 37.885 v15.2.0
     // When a V2V link is in NLOSv, additional vehicle blockage loss is
     // added as follows:
@@ -166,13 +174,12 @@ ThreeGppV2vUrbanPropagationLossModel::GetAdditionalNlosvLoss(double distance3D,
 }
 
 double
-ThreeGppV2vUrbanPropagationLossModel::GetLossNlos(double /* distance2D */,
-                                                  double distance3D,
-                                                  double /* hUt */,
-                                                  double /* hBs */) const
+ThreeGppV2vUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
     double loss = 36.85 + 30 * log10(distance3D) + 18.9 * log10(m_frequency / 1e9);
 
     return loss;
@@ -266,13 +273,12 @@ ThreeGppV2vHighwayPropagationLossModel::~ThreeGppV2vHighwayPropagationLossModel(
 }
 
 double
-ThreeGppV2vHighwayPropagationLossModel::GetLossLos(double /* distance2D */,
-                                                   double distance3D,
-                                                   double /* hUt */,
-                                                   double /* hBs */) const
+ThreeGppV2vHighwayPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const
 {
     NS_LOG_FUNCTION(this);
 
+    double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
+
     // compute the pathloss (see 3GPP TR 37.885, Table 6.2.1-1)
     double loss = 32.4 + 20 * log10(distance3D) + 20 * log10(m_frequency / 1e9);
 
diff --git a/src/propagation/model/three-gpp-v2v-propagation-loss-model.h b/src/propagation/model/three-gpp-v2v-propagation-loss-model.h
index ecd67a84d..24cd416fc 100644
--- a/src/propagation/model/three-gpp-v2v-propagation-loss-model.h
+++ b/src/propagation/model/three-gpp-v2v-propagation-loss-model.h
@@ -21,6 +21,8 @@
 
 #include "three-gpp-propagation-loss-model.h"
 
+#include <ns3/mobility-model.h>
+
 namespace ns3
 {
 
@@ -49,8 +51,19 @@ class ThreeGppV2vUrbanPropagationLossModel : public ThreeGppPropagationLossModel
      */
     ~ThreeGppV2vUrbanPropagationLossModel() override;
 
-    // Delete copy constructor and assignment operator to avoid misuse
+    /**
+     * \brief Copy constructor
+     *
+     * Defined and unimplemented to avoid misuse
+     */
     ThreeGppV2vUrbanPropagationLossModel(const ThreeGppV2vUrbanPropagationLossModel&) = delete;
+
+    /**
+     * \brief Copy constructor
+     *
+     * Defined and unimplemented to avoid misuse
+     * \returns the ThreeGppRmaPropagationLossModel instance
+     */
     ThreeGppV2vUrbanPropagationLossModel& operator=(const ThreeGppV2vUrbanPropagationLossModel&) =
         delete;
 
@@ -58,13 +71,11 @@ class ThreeGppV2vUrbanPropagationLossModel : public ThreeGppPropagationLossModel
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a mobility model of one of the two communicating nodes
+     * \param b mobility model of one of the two communicating nodes
      * \return pathloss value in dB
      */
-    double GetLossLos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Returns the minimum of the two independently generated distances
@@ -86,41 +97,33 @@ class ThreeGppV2vUrbanPropagationLossModel : public ThreeGppPropagationLossModel
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed by a vehicle
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a mobility model of one of the two communicating nodes
+     * \param b mobility model of one of the two communicating nodes
      * \return pathloss value in dB
      */
-    double GetLossNlosv(double distance2D,
-                        double distance3D,
-                        double hUt,
-                        double hBs) const override;
+    double GetLossNlosv(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is obstructed by a building
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a mobility model of one of the two communicating nodes
+     * \param b mobility model of one of the two communicating nodes
      * \return pathloss value in dB
      */
-    double GetLossNlos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossNlos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 
     /**
      * \brief Computes the additional loss due to an obstruction caused by a vehicle
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a mobility model of one of the two communicating nodes
+     * \param b mobility model of one of the two communicating nodes
      * \return pathloss value in dB
      */
-    double GetAdditionalNlosvLoss(double distance3D, double hUt, double hBs) const;
+    double GetAdditionalNlosvLoss(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const;
 
     /**
      * \brief Returns the shadow fading standard deviation
-     * \param a tx mobility model
-     * \param b rx mobility model
+     * \param a mobility model of one of the two communicating nodes
+     * \param b mobility model of one of the two communicating nodes
      * \param cond the LOS/NLOS channel condition
      * \return shadowing std in dB
      */
@@ -171,13 +174,11 @@ class ThreeGppV2vHighwayPropagationLossModel : public ThreeGppV2vUrbanPropagatio
     /**
      * \brief Computes the pathloss between a and b considering that the line of
      *        sight is not obstructed
-     * \param distance2D the 2D distance between tx and rx in meters
-     * \param distance3D the 3D distance between tx and rx in meters
-     * \param hUt the height of the UT in meters
-     * \param hBs the height of the BS in meters
+     * \param a mobility model of one of the two communicating nodes
+     * \param b mobility model of one of the two communicating nodes
      * \return pathloss value in dB
      */
-    double GetLossLos(double distance2D, double distance3D, double hUt, double hBs) const override;
+    double GetLossLos(Ptr<MobilityModel> a, Ptr<MobilityModel> b) const override;
 };
 
 } // namespace ns3
diff --git a/src/propagation/test/three-gpp-ntn-propagation-loss-model-test-suite.cc b/src/propagation/test/three-gpp-ntn-propagation-loss-model-test-suite.cc
new file mode 100644
index 000000000..9d68de8e9
--- /dev/null
+++ b/src/propagation/test/three-gpp-ntn-propagation-loss-model-test-suite.cc
@@ -0,0 +1,753 @@
+/*
+ * Copyright (c) 2023 SIGNET Lab, Department of Information Engineering,
+ * University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ns3/abort.h"
+#include "ns3/boolean.h"
+#include "ns3/channel-condition-model.h"
+#include "ns3/config.h"
+#include "ns3/constant-position-mobility-model.h"
+#include "ns3/constant-velocity-mobility-model.h"
+#include "ns3/double.h"
+#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/log.h"
+#include "ns3/mobility-helper.h"
+#include "ns3/simulator.h"
+#include "ns3/test.h"
+#include "ns3/three-gpp-propagation-loss-model.h"
+#include "ns3/three-gpp-v2v-propagation-loss-model.h"
+
+using namespace ns3;
+
+NS_LOG_COMPONENT_DEFINE("ThreeGppNTNPropagationLossModelsTest");
+
+/**
+ * \ingroup propagation-tests
+ *
+ * Test case for the class ThreeGppNTNDenseUrbanPropagationLossModel.
+ * It computes the pathloss between two nodes and compares it with the value
+ * obtained using the results provided in 3GPP TR 38.821.
+ */
+class ThreeGppNTNDenseUrbanPropagationLossModelTestCase : public TestCase
+{
+  public:
+    /**
+     * Constructor
+     */
+    ThreeGppNTNDenseUrbanPropagationLossModelTestCase();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNDenseUrbanPropagationLossModelTestCase() override;
+
+  private:
+    /**
+     * Build the simulation scenario and run the tests
+     */
+    void DoRun() override;
+
+    /**
+     * Struct containing the parameters for each test
+     */
+    struct TestPoint
+    {
+        double m_distance;  //!< 2D distance between UT and BS in meters
+        bool m_isLos;       //!< if true LOS, if false NLOS
+        double m_frequency; //!< carrier frequency in Hz
+        double m_pwrTxDbm;  //!< transmitted power in dBm
+        double m_pwrRxDbm;  //!< received power in dBm
+
+        // TestPoint (double distance, bool isLos, double frequency, double pt, double pr)
+        // : m_distance(distance),
+        //   m_isLos(isLos),
+        //   m_frequency(frequency),
+        //   m_pwrTxDbm(pt),
+        //   m_pwrRxDbm(pr)
+        // {}
+    };
+
+    TestVectors<TestPoint> m_testPoints; //!< array containing all the test vectors
+    double m_tolerance;                  //!< tolerance
+};
+
+ThreeGppNTNDenseUrbanPropagationLossModelTestCase::
+    ThreeGppNTNDenseUrbanPropagationLossModelTestCase()
+    : TestCase("Test for the ThreeNTNDenseUrbanPropagationLossModel class"),
+      m_testPoints(),
+      m_tolerance(5e-2)
+{
+}
+
+ThreeGppNTNDenseUrbanPropagationLossModelTestCase::
+    ~ThreeGppNTNDenseUrbanPropagationLossModelTestCase()
+{
+}
+
+void
+ThreeGppNTNDenseUrbanPropagationLossModelTestCase::DoRun()
+{
+    TestPoint testPoint;
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -209.915;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -213.437;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -191.744;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -174.404;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -177.925;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -156.233;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -180.424;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -183.946;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -162.253;
+    m_testPoints.Add(testPoint);
+    // Create the nodes for BS and UT
+    NodeContainer nodes;
+    nodes.Create(2);
+
+    // Create the mobility models
+    Ptr<MobilityModel> a = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(0)->AggregateObject(a);
+    Ptr<MobilityModel> b = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(1)->AggregateObject(b);
+
+    // Use a deterministic channel condition model
+    Ptr<ChannelConditionModel> losCondModel = CreateObject<AlwaysLosChannelConditionModel>();
+    Ptr<ChannelConditionModel> nlosCondModel = CreateObject<NeverLosChannelConditionModel>();
+
+    // Create the propagation loss model
+    Ptr<ThreeGppNTNDenseUrbanPropagationLossModel> lossModel =
+        CreateObject<ThreeGppNTNDenseUrbanPropagationLossModel>();
+    lossModel->SetAttribute("ShadowingEnabled", BooleanValue(false)); // disable the shadow fading
+
+    for (std::size_t i = 0; i < m_testPoints.GetN(); i++)
+    {
+        TestPoint testPoint = m_testPoints.Get(i);
+
+        Vector posA = Vector(0.0, 0.0, 0.0);
+        Vector posB = Vector(0.0, 0.0, testPoint.m_distance);
+
+        // set the LOS or NLOS condition
+        if (testPoint.m_isLos)
+        {
+            lossModel->SetChannelConditionModel(losCondModel);
+        }
+        else
+        {
+            lossModel->SetChannelConditionModel(nlosCondModel);
+        }
+
+        a->SetPosition(posA);
+        b->SetPosition(posB);
+
+        lossModel->SetAttribute("Frequency", DoubleValue(testPoint.m_frequency));
+        NS_TEST_EXPECT_MSG_EQ_TOL(lossModel->CalcRxPower(testPoint.m_pwrTxDbm, a, b),
+                                  testPoint.m_pwrRxDbm,
+                                  m_tolerance,
+                                  "Got unexpected rcv power");
+    }
+
+    Simulator::Destroy();
+}
+
+/**
+ * \ingroup propagation-tests
+ *
+ * Test case for the class ThreeGppNTNUrbanPropagationLossModel.
+ * It computes the pathloss between two nodes and compares it with the value
+ * obtained using the results provided in 3GPP TR 38.821.
+ */
+class ThreeGppNTNUrbanPropagationLossModelTestCase : public TestCase
+{
+  public:
+    /**
+     * Constructor
+     */
+    ThreeGppNTNUrbanPropagationLossModelTestCase();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNUrbanPropagationLossModelTestCase() override;
+
+  private:
+    /**
+     * Build the simulation scenario and run the tests
+     */
+    void DoRun() override;
+
+    /**
+     * Struct containing the parameters for each test
+     */
+    struct TestVector
+    {
+        double m_distance;  //!< 2D distance between UT and BS in meters
+        bool m_isLos;       //!< if true LOS, if false NLOS
+        double m_frequency; //!< carrier frequency in Hz
+        double m_pwrTxDbm;  //!< transmitted power in dBm
+        double m_pwrRxDbm;  //!< received power in dBm
+    };
+
+    TestVectors<TestVector> m_testPoints; //!< array containing all the test vectors
+    double m_tolerance;                   //!< tolerance
+};
+
+ThreeGppNTNUrbanPropagationLossModelTestCase::ThreeGppNTNUrbanPropagationLossModelTestCase()
+    : TestCase("Test for the ThreeNTNDenseUrbanPropagationLossModel class"),
+      m_testPoints(),
+      m_tolerance(5e-2)
+{
+}
+
+ThreeGppNTNUrbanPropagationLossModelTestCase::~ThreeGppNTNUrbanPropagationLossModelTestCase()
+{
+}
+
+void
+ThreeGppNTNUrbanPropagationLossModelTestCase::DoRun()
+{
+    TestVector testPoint;
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -209.915;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -213.437;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -191.744;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -174.404;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -177.925;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -156.233;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -180.424;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -183.946;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -162.253;
+    m_testPoints.Add(testPoint);
+
+    // Create the nodes for BS and UT
+    NodeContainer nodes;
+    nodes.Create(2);
+
+    // Create the mobility models
+    Ptr<MobilityModel> a = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(0)->AggregateObject(a);
+    Ptr<MobilityModel> b = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(1)->AggregateObject(b);
+
+    // Use a deterministic channel condition model
+    Ptr<ChannelConditionModel> losCondModel = CreateObject<AlwaysLosChannelConditionModel>();
+    Ptr<ChannelConditionModel> nlosCondModel = CreateObject<NeverLosChannelConditionModel>();
+
+    // Create the propagation loss model
+    Ptr<ThreeGppNTNUrbanPropagationLossModel> lossModel =
+        CreateObject<ThreeGppNTNUrbanPropagationLossModel>();
+    lossModel->SetAttribute("ShadowingEnabled", BooleanValue(false)); // disable the shadow fading
+
+    for (std::size_t i = 0; i < m_testPoints.GetN(); i++)
+    {
+        TestVector testPoint = m_testPoints.Get(i);
+
+        Vector posA = Vector(0.0, 0.0, 0.0);
+        Vector posB = Vector(0.0, 0.0, testPoint.m_distance);
+
+        // set the LOS or NLOS condition
+        if (testPoint.m_isLos)
+        {
+            lossModel->SetChannelConditionModel(losCondModel);
+        }
+        else
+        {
+            lossModel->SetChannelConditionModel(nlosCondModel);
+        }
+
+        a->SetPosition(posA);
+        b->SetPosition(posB);
+
+        lossModel->SetAttribute("Frequency", DoubleValue(testPoint.m_frequency));
+        NS_TEST_EXPECT_MSG_EQ_TOL(lossModel->CalcRxPower(testPoint.m_pwrTxDbm, a, b),
+                                  testPoint.m_pwrRxDbm,
+                                  m_tolerance,
+                                  "Got unexpected rcv power");
+    }
+
+    Simulator::Destroy();
+}
+
+/**
+ * \ingroup propagation-tests
+ *
+ * Test case for the class ThreeGppNTNSuburbanPropagationLossModel.
+ * It computes the pathloss between two nodes and compares it with the value
+ * obtained using the results provided in 3GPP TR 38.821.
+ */
+class ThreeGppNTNSuburbanPropagationLossModelTestCase : public TestCase
+{
+  public:
+    /**
+     * Constructor
+     */
+    ThreeGppNTNSuburbanPropagationLossModelTestCase();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNSuburbanPropagationLossModelTestCase() override;
+
+  private:
+    /**
+     * Build the simulation scenario and run the tests
+     */
+    void DoRun() override;
+
+    /**
+     * Struct containing the parameters for each test
+     */
+    struct TestVector
+    {
+        double m_distance;  //!< 2D distance between UT and BS in meters
+        bool m_isLos;       //!< if true LOS, if false NLOS
+        double m_frequency; //!< carrier frequency in Hz
+        double m_pwrTxDbm;  //!< transmitted power in dBm
+        double m_pwrRxDbm;  //!< received power in dBm
+    };
+
+    TestVectors<TestVector> m_testPoints; //!< array containing all the test vectors
+    double m_tolerance;                   //!< tolerance
+};
+
+ThreeGppNTNSuburbanPropagationLossModelTestCase::ThreeGppNTNSuburbanPropagationLossModelTestCase()
+    : TestCase("Test for the ThreeNTNDenseUrbanPropagationLossModel class"),
+      m_testPoints(),
+      m_tolerance(5e-2)
+{
+}
+
+ThreeGppNTNSuburbanPropagationLossModelTestCase::~ThreeGppNTNSuburbanPropagationLossModelTestCase()
+{
+}
+
+void
+ThreeGppNTNSuburbanPropagationLossModelTestCase::DoRun()
+{
+    TestVector testPoint;
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -209.915;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -213.437;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -191.744;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -174.404;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -177.925;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -156.233;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -180.424;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -183.946;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -162.253;
+    m_testPoints.Add(testPoint);
+
+    // Create the nodes for BS and UT
+    NodeContainer nodes;
+    nodes.Create(2);
+
+    // Create the mobility models
+    Ptr<MobilityModel> a = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(0)->AggregateObject(a);
+    Ptr<MobilityModel> b = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(1)->AggregateObject(b);
+
+    // Use a deterministic channel condition model
+    Ptr<ChannelConditionModel> losCondModel = CreateObject<AlwaysLosChannelConditionModel>();
+    Ptr<ChannelConditionModel> nlosCondModel = CreateObject<NeverLosChannelConditionModel>();
+
+    // Create the propagation loss model
+    Ptr<ThreeGppNTNSuburbanPropagationLossModel> lossModel =
+        CreateObject<ThreeGppNTNSuburbanPropagationLossModel>();
+    lossModel->SetAttribute("ShadowingEnabled", BooleanValue(false)); // disable the shadow fading
+
+    for (std::size_t i = 0; i < m_testPoints.GetN(); i++)
+    {
+        TestVector testPoint = m_testPoints.Get(i);
+
+        Vector posA = Vector(0.0, 0.0, 0.0);
+        Vector posB = Vector(0.0, 0.0, testPoint.m_distance);
+
+        // set the LOS or NLOS condition
+        if (testPoint.m_isLos)
+        {
+            lossModel->SetChannelConditionModel(losCondModel);
+        }
+        else
+        {
+            lossModel->SetChannelConditionModel(nlosCondModel);
+        }
+
+        a->SetPosition(posA);
+        b->SetPosition(posB);
+
+        lossModel->SetAttribute("Frequency", DoubleValue(testPoint.m_frequency));
+        NS_TEST_EXPECT_MSG_EQ_TOL(lossModel->CalcRxPower(testPoint.m_pwrTxDbm, a, b),
+                                  testPoint.m_pwrRxDbm,
+                                  m_tolerance,
+                                  "Got unexpected rcv power");
+    }
+
+    Simulator::Destroy();
+}
+
+/**
+ * \ingroup propagation-tests
+ *
+ * Test case for the class ThreeGppNTNRuralPropagationLossModel.
+ * It computes the pathloss between two nodes and compares it with the value
+ * obtained using the results provided in 3GPP TR 38.821.
+ */
+class ThreeGppNTNRuralPropagationLossModelTestCase : public TestCase
+{
+  public:
+    /**
+     * Constructor
+     */
+    ThreeGppNTNRuralPropagationLossModelTestCase();
+
+    /**
+     * Destructor
+     */
+    ~ThreeGppNTNRuralPropagationLossModelTestCase() override;
+
+  private:
+    /**
+     * Build the simulation scenario and run the tests
+     */
+    void DoRun() override;
+
+    /**
+     * Struct containing the parameters for each test
+     */
+    struct TestVector
+    {
+        double m_distance;  //!< 2D distance between UT and BS in meters
+        bool m_isLos;       //!< if true LOS, if false NLOS
+        double m_frequency; //!< carrier frequency in Hz
+        double m_pwrTxDbm;  //!< transmitted power in dBm
+        double m_pwrRxDbm;  //!< received power in dBm
+    };
+
+    TestVectors<TestVector> m_testPoints; //!< array containing all the test vectors
+    double m_tolerance;                   //!< tolerance
+};
+
+ThreeGppNTNRuralPropagationLossModelTestCase::ThreeGppNTNRuralPropagationLossModelTestCase()
+    : TestCase("Test for the ThreeNTNDenseUrbanPropagationLossModel class"),
+      m_testPoints(),
+      m_tolerance(5e-2)
+{
+}
+
+ThreeGppNTNRuralPropagationLossModelTestCase::~ThreeGppNTNRuralPropagationLossModelTestCase()
+{
+}
+
+void
+ThreeGppNTNRuralPropagationLossModelTestCase::DoRun()
+{
+    TestVector testPoint;
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -209.915;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -213.437;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 35786000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -191.744;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -174.404;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -177.925;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 600000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -156.233;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 20.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -180.424;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 30.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -183.946;
+    m_testPoints.Add(testPoint);
+
+    testPoint.m_distance = 1200000;
+    testPoint.m_isLos = true;
+    testPoint.m_frequency = 2.0e9;
+    testPoint.m_pwrTxDbm = 0.0;
+    testPoint.m_pwrRxDbm = -162.253;
+    m_testPoints.Add(testPoint);
+
+    // Create the nodes for BS and UT
+    NodeContainer nodes;
+    nodes.Create(2);
+
+    // Create the mobility models
+    Ptr<MobilityModel> a = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(0)->AggregateObject(a);
+    Ptr<MobilityModel> b = CreateObject<GeocentricConstantPositionMobilityModel>();
+    nodes.Get(1)->AggregateObject(b);
+
+    // Use a deterministic channel condition model
+    Ptr<ChannelConditionModel> losCondModel = CreateObject<AlwaysLosChannelConditionModel>();
+    Ptr<ChannelConditionModel> nlosCondModel = CreateObject<NeverLosChannelConditionModel>();
+
+    // Create the propagation loss model
+    Ptr<ThreeGppNTNRuralPropagationLossModel> lossModel =
+        CreateObject<ThreeGppNTNRuralPropagationLossModel>();
+    lossModel->SetAttribute("ShadowingEnabled", BooleanValue(false)); // disable the shadow fading
+
+    for (std::size_t i = 0; i < m_testPoints.GetN(); i++)
+    {
+        TestVector testPoint = m_testPoints.Get(i);
+
+        Vector posA = Vector(0.0, 0.0, 0.0);
+        Vector posB = Vector(0.0, 0.0, testPoint.m_distance);
+
+        // set the LOS or NLOS condition
+        if (testPoint.m_isLos)
+        {
+            lossModel->SetChannelConditionModel(losCondModel);
+        }
+        else
+        {
+            lossModel->SetChannelConditionModel(nlosCondModel);
+        }
+
+        a->SetPosition(posA);
+        b->SetPosition(posB);
+
+        lossModel->SetAttribute("Frequency", DoubleValue(testPoint.m_frequency));
+        NS_TEST_EXPECT_MSG_EQ_TOL(lossModel->CalcRxPower(testPoint.m_pwrTxDbm, a, b),
+                                  testPoint.m_pwrRxDbm,
+                                  m_tolerance,
+                                  "Got unexpected rcv power");
+    }
+
+    Simulator::Destroy();
+}
+
+/**
+ * \ingroup propagation-tests
+ *
+ * \brief 3GPP NTN Propagation models TestSuite
+ *
+ * This TestSuite tests the following models:
+ *   - ThreeGppNTNDenseUrbanPropagationLossModel
+ *   - ThreeGppNTNUrbanPropagationLossModel
+ *   - ThreeGppNTNSuburbanPropagationLossModel
+ *   - ThreeGppNTNRuralPropagationLossModel
+ */
+class ThreeGppNTNPropagationLossModelsTestSuite : public TestSuite
+{
+  public:
+    ThreeGppNTNPropagationLossModelsTestSuite();
+};
+
+ThreeGppNTNPropagationLossModelsTestSuite::ThreeGppNTNPropagationLossModelsTestSuite()
+    : TestSuite("three-gpp-ntn-propagation-loss-model", UNIT)
+{
+    AddTestCase(new ThreeGppNTNDenseUrbanPropagationLossModelTestCase, TestCase::QUICK);
+    AddTestCase(new ThreeGppNTNUrbanPropagationLossModelTestCase, TestCase::QUICK);
+    AddTestCase(new ThreeGppNTNSuburbanPropagationLossModelTestCase, TestCase::QUICK);
+    AddTestCase(new ThreeGppNTNRuralPropagationLossModelTestCase, TestCase::QUICK);
+}
+
+/// Static variable for test initialization
+static ThreeGppNTNPropagationLossModelsTestSuite g_propagationLossModelsTestSuite;
diff --git a/src/spectrum/doc/spectrum.rst b/src/spectrum/doc/spectrum.rst
index 49e4df074..ec0aa4f4a 100644
--- a/src/spectrum/doc/spectrum.rst
+++ b/src/spectrum/doc/spectrum.rst
@@ -1097,3 +1097,49 @@ References
    Mattias Frenne, Farshid Ghasemzadeh, Måns Hagström et al. Advanced Antenna Systems
    for 5G Network Deployments: Bridging the Gap Between Theory and Practice.
    Academic Press, 2020.
+
+.. [TR38901] 3GPP. 2018. TR 38.901. Study on channel for frequencies from 0.5 to
+   100 GHz. V.15.0.0. (2018-06).
+
+
+3GPP TR 38.811 Non-Terrestrial Networks
+=======================================
+3GPP with [3GPPTR38811]_ has extended the channel model presented in [3GPPTR38901]_ to support the so called Non-Terrestrial Networks
+(NTN), i.e. communication scenarios where the propagation of the signal travels through the atmosphere.
+The channel spectrum estimation procedure is the same as the one described in [3GPPTR38901]_, with a new set of parameters.
+
+
+Use-cases
+#########
+The use-cases for this channel model includes simulations in 3D/vertical environments with communicating nodes placed
+in different types of orbit, in the atmosphere and/or on the ground.
+
+Implementation
+##############
+The channel spectrum estimation procedure is already implemented (as described in [ns3Zugno]_ ) into the classes
+ThreeGppChannelModel and ThreeGppSpectrumPropagationLossModel, that have been extended to support NTN through the
+introduction of the appropriate parameters.
+3GPP considers two frequencies of interest: S-band (2GHz) and Ka-band (20/30GHz). Many channel parameters are dependent
+on the frequency band in use, but no specific range of frequencies of these bands has been given by 3GPP. Hence, this
+implementation considers S-band anything below 13GHz, and Ka-band anything above it.
+Four propagation scenarios are identified, in decreasing order of building height and density: Dense Urban, Urban,
+Suburban and Rural. Channel estimation parameters are scenario-dependent.
+**Note**: For satellite, the parameters that describe the departure angle spread are 0. Thus, in the logarithmic scale
+at which these parameters are represented is :math:`-\infty`.
+
+
+Testing
+#######
+
+
+References
+##########
+
+.. [ns3Zugno] Zugno Tommaso, Michele Polese, Natale Patriciello, Biljana Bojović,
+   Sandra Lagen, Michele Zorzi. "Implementation of a spatial channel model for ns-3."
+   In Proceedings of the 2020 Workshop on ns-3, pp. 49-56. 2020.
+
+.. [3GPPTR38901] 3GPP. 2018. TR 38.901. Study on channel for frequencies from 0.5 to
+   100 GHz. V.15.0.0. (2018-06).
+
+.. [3GPPTR38811] 3GPP. 2018. TR 38.811, Study on New Radio (NR) to support non-terrestrial networks, V15.4.0. (2020-09).
diff --git a/src/spectrum/examples/CMakeLists.txt b/src/spectrum/examples/CMakeLists.txt
index 457466589..35fce4258 100644
--- a/src/spectrum/examples/CMakeLists.txt
+++ b/src/spectrum/examples/CMakeLists.txt
@@ -65,3 +65,13 @@ build_lib_example(
     ${libmobility}
     ${libspectrum}
 )
+
+build_lib_example(
+  NAME three-gpp-ntn-channel-example
+  SOURCE_FILES three-gpp-ntn-channel-example.cc
+  LIBRARIES_TO_LINK
+    ${libcore}
+    ${liblte}
+    ${libmobility}
+    ${libspectrum}
+)
diff --git a/src/spectrum/examples/three-gpp-ntn-channel-example.cc b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
new file mode 100644
index 000000000..aacf38e5c
--- /dev/null
+++ b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) 2023 SIGNET Lab, Department of Information Engineering,
+ * University of Padova
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/**
+ * This example is a modified version of "three-gpp-channel-example", to include
+ * the 3GPP NTN channel model.
+ * The preconfigured parameters are the one provided by 3GPP in TR 38.821,
+ * more specifically scenario 10 in down-link mode.
+ * Two static nodes, one on the ground and one in orbit, communicates using
+ * circular aperture antennas. The carrier frequency is set at 20GHz with 400MHz bandwidth.
+ * The result is the SNR of the signal and the pathloss, saved in the ntn-snr-trace.txt file.
+ */
+
+#include "ns3/channel-condition-model.h"
+#include "ns3/circular-aperture-antenna-model.h"
+#include "ns3/constant-position-mobility-model.h"
+#include "ns3/core-module.h"
+#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/isotropic-antenna-model.h"
+#include "ns3/lte-spectrum-value-helper.h"
+#include "ns3/mobility-model.h"
+#include "ns3/net-device.h"
+#include "ns3/node-container.h"
+#include "ns3/node.h"
+#include "ns3/parabolic-antenna-model.h"
+#include "ns3/simple-net-device.h"
+#include "ns3/spectrum-signal-parameters.h"
+#include "ns3/three-gpp-channel-model.h"
+#include "ns3/three-gpp-propagation-loss-model.h"
+#include "ns3/three-gpp-spectrum-propagation-loss-model.h"
+#include "ns3/uniform-planar-array.h"
+#include <ns3/antenna-model.h>
+
+#include <fstream>
+
+NS_LOG_COMPONENT_DEFINE("NTNChannelExample");
+
+using namespace ns3;
+
+static Ptr<ThreeGppPropagationLossModel>
+    m_propagationLossModel; //!< the PropagationLossModel object
+static Ptr<ThreeGppSpectrumPropagationLossModel>
+    m_spectrumLossModel; //!< the SpectrumPropagationLossModel object
+
+Ptr<SpectrumValue>
+CreateTxPowerSpectralDensity(double fc, double pwr, double BW, double RB_WIDTH)
+{
+    unsigned int numRbs = std::floor(BW / RB_WIDTH);
+    double f = fc - (numRbs * RB_WIDTH / 2.0);
+    double powerTx = pwr; // dBm power
+
+    Bands rbs;              // A vector representing each resource block
+    std::vector<int> rbsId; // A vector representing the resource block IDs
+    for (uint32_t numrb = 0; numrb < numRbs; ++numrb)
+    {
+        BandInfo rb;
+        rb.fl = f;
+        f += RB_WIDTH / 2;
+        rb.fc = f;
+        f += RB_WIDTH / 2;
+        rb.fh = f;
+
+        rbs.push_back(rb);
+        rbsId.push_back(numrb);
+    }
+    Ptr<SpectrumModel> model = Create<SpectrumModel>(rbs);
+    Ptr<SpectrumValue> txPsd = Create<SpectrumValue>(model);
+
+    double powerTxW = std::pow(10., (powerTx - 30) / 10); // Get Tx power in Watts
+    double txPowerDensity = (powerTxW / BW);
+
+    for (auto rbId : rbsId)
+    {
+        (*txPsd)[rbId] = txPowerDensity;
+    }
+
+    return txPsd; // [W/Hz]
+}
+
+Ptr<SpectrumValue>
+CreateNoisePowerSpectralDensity(double fc, double noiseFigure, double BW, double RB_WIDTH)
+{
+    unsigned int numRbs = std::floor(BW / RB_WIDTH);
+    double f = fc - (numRbs * RB_WIDTH / 2.0);
+    double noiseFigureDb = noiseFigure; // dB noise figure
+
+    Bands rbs;              // A vector representing each resource block
+    std::vector<int> rbsId; // A vector representing the resource block IDs
+    for (uint32_t numrb = 0; numrb < numRbs; ++numrb)
+    {
+        BandInfo rb;
+        rb.fl = f;
+        f += RB_WIDTH / 2;
+        rb.fc = f;
+        f += RB_WIDTH / 2;
+        rb.fh = f;
+
+        rbs.push_back(rb);
+        rbsId.push_back(numrb);
+    }
+    Ptr<SpectrumModel> model = Create<SpectrumModel>(rbs);
+    Ptr<SpectrumValue> txPsd = Create<SpectrumValue>(model);
+
+    // see "LTE - From theory to practice"
+    // Section 22.4.4.2 Thermal Noise and Receiver Noise Figure
+    const double kT_dBm_Hz = -174.0;                          // dBm/Hz
+    double kT_W_Hz = std::pow(10.0, (kT_dBm_Hz - 30) / 10.0); // W/Hz
+    double noiseFigureLinear = std::pow(10.0, noiseFigureDb / 10.0);
+
+    double noisePowerSpectralDensity = kT_W_Hz * noiseFigureLinear;
+
+    for (auto rbId : rbsId)
+    {
+        (*txPsd)[rbId] = noisePowerSpectralDensity;
+    }
+
+    return txPsd; // W/Hz
+}
+
+/**
+ * \brief A structure that holds the parameters for the
+ * ComputeSnr function. In this way the problem with the limited
+ * number of parameters of method Schedule is avoided.
+ */
+struct ComputeSnrParams
+{
+    Ptr<MobilityModel> txMob;        //!< the tx mobility model
+    Ptr<MobilityModel> rxMob;        //!< the rx mobility model
+    double txPow;                    //!< the tx power in dBm
+    double noiseFigure;              //!< the noise figure in dB
+    Ptr<PhasedArrayModel> txAntenna; //!< the tx antenna array
+    Ptr<PhasedArrayModel> rxAntenna; //!< the rx antenna array
+    double frequency;                //!< the carrier frequency in Hz
+    double bandwidth;                //!< the total bandwidth in Hz
+    double resourceBlockBandwidth;   //!< the Resource Block bandwidth in Hz
+
+    /**
+     * \brief Constructor
+     * \param pTxMob the tx mobility model
+     * \param pRxMob the rx mobility model
+     * \param pTxPow the tx power in dBm
+     * \param pNoiseFigure the noise figure in dB
+     * \param pTxAntenna the tx antenna array
+     * \param pRxAntenna the rx antenna array
+     * \param pFrequency the carrier frequency in Hz
+     * \param pBandwidth the total bandwidth in Hz
+     * \param pResourceBlockBandwidth the Resource Block bandwidth in Hz
+     */
+    ComputeSnrParams(Ptr<MobilityModel> pTxMob,
+                     Ptr<MobilityModel> pRxMob,
+                     double pTxPow,
+                     double pNoiseFigure,
+                     Ptr<PhasedArrayModel> pTxAntenna,
+                     Ptr<PhasedArrayModel> pRxAntenna,
+                     double pFrequency,
+                     double pBandwidth,
+                     double pResourceBlockBandwidth)
+    {
+        txMob = pTxMob;
+        rxMob = pRxMob;
+        txPow = pTxPow;
+        noiseFigure = pNoiseFigure;
+        txAntenna = pTxAntenna;
+        rxAntenna = pRxAntenna;
+        frequency = pFrequency;
+        bandwidth = pBandwidth;
+        resourceBlockBandwidth = pResourceBlockBandwidth;
+    }
+};
+
+/**
+ * Perform the beamforming using the DFT beamforming method
+ * \param thisDevice the device performing the beamforming
+ * \param thisAntenna the antenna object associated to thisDevice
+ * \param otherDevice the device towards which point the beam
+ */
+static void
+DoBeamforming(Ptr<NetDevice> thisDevice,
+              Ptr<PhasedArrayModel> thisAntenna,
+              Ptr<NetDevice> otherDevice)
+{
+    // retrieve the position of the two devices
+    Vector aPos = thisDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();
+    Vector bPos = otherDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();
+
+    // compute the azimuth and the elevation angles
+    Angles completeAngle(bPos, aPos);
+    double hAngleRadian = completeAngle.GetAzimuth();
+    double vAngleRadian = completeAngle.GetInclination(); // the elevation angle
+
+    // retrieve the number of antenna elements and resize the vector
+    uint64_t totNoArrayElements = thisAntenna->GetNumElems();
+    PhasedArrayModel::ComplexVector antennaWeights(totNoArrayElements);
+
+    // the total power is divided equally among the antenna elements
+    double power = 1.0 / sqrt(totNoArrayElements);
+
+    // compute the antenna weights
+    const double sinVAngleRadian = sin(vAngleRadian);
+    const double cosVAngleRadian = cos(vAngleRadian);
+    const double sinHAngleRadian = sin(hAngleRadian);
+    const double cosHAngleRadian = cos(hAngleRadian);
+
+    for (uint64_t ind = 0; ind < totNoArrayElements; ind++)
+    {
+        Vector loc = thisAntenna->GetElementLocation(ind);
+        double phase = -2 * M_PI *
+                       (sinVAngleRadian * cosHAngleRadian * loc.x +
+                        sinVAngleRadian * sinHAngleRadian * loc.y + cosVAngleRadian * loc.z);
+        antennaWeights[ind] = exp(std::complex<double>(0, phase)) * power;
+    }
+
+    // store the antenna weights
+    thisAntenna->SetBeamformingVector(antennaWeights);
+}
+
+/**
+ * Compute the average SNR
+ * \param params A structure that holds the parameters that are needed to perform calculations in
+ * ComputeSnr
+ */
+static void
+ComputeSnr(ComputeSnrParams& params)
+{
+    Ptr<SpectrumValue> txPsd = CreateTxPowerSpectralDensity(params.frequency,
+                                                            params.txPow,
+                                                            params.bandwidth,
+                                                            params.resourceBlockBandwidth);
+    Ptr<SpectrumValue> rxPsd = txPsd->Copy();
+    NS_LOG_DEBUG("Average tx power " << 10 * log10(Sum(*txPsd) * params.resourceBlockBandwidth)
+                                     << " dB");
+
+    // create the noise PSD
+    Ptr<SpectrumValue> noisePsd = CreateNoisePowerSpectralDensity(params.frequency,
+                                                                  params.noiseFigure,
+                                                                  params.bandwidth,
+                                                                  params.resourceBlockBandwidth);
+    NS_LOG_DEBUG("Average noise power "
+                 << 10 * log10(Sum(*noisePsd) * params.resourceBlockBandwidth) << " dB");
+
+    // apply the pathloss
+    double propagationGainDb = m_propagationLossModel->CalcRxPower(0, params.txMob, params.rxMob);
+    NS_LOG_DEBUG("Pathloss " << -propagationGainDb << " dB");
+    double propagationGainLinear = std::pow(10.0, (propagationGainDb) / 10.0);
+    *(rxPsd) *= propagationGainLinear;
+
+    NS_ASSERT_MSG(params.txAntenna, "params.txAntenna is nullptr!");
+    NS_ASSERT_MSG(params.rxAntenna, "params.rxAntenna is nullptr!");
+
+    Ptr<SpectrumSignalParameters> rxSsp = Create<SpectrumSignalParameters>();
+    rxSsp->psd = rxPsd;
+    rxSsp->txAntenna =
+        ConstCast<AntennaModel, const AntennaModel>(params.txAntenna->GetAntennaElement());
+
+    // apply the fast fading and the beamforming gain
+    rxSsp = m_spectrumLossModel->CalcRxPowerSpectralDensity(rxSsp,
+                                                            params.txMob,
+                                                            params.rxMob,
+                                                            params.txAntenna,
+                                                            params.rxAntenna);
+    NS_LOG_DEBUG("Average rx power " << 10 * log10(Sum(*rxSsp->psd) * params.bandwidth) << " dB");
+
+    // compute the SNR
+    NS_LOG_DEBUG("Average SNR " << 10 * log10(Sum(*rxSsp->psd) / Sum(*noisePsd)) << " dB");
+
+    // print the SNR and pathloss values in the ntn-snr-trace.txt file
+    std::ofstream f;
+    f.open("ntn-snr-trace.txt", std::ios::out | std::ios::app);
+    f << Simulator::Now().GetSeconds() << " " << 10 * log10(Sum(*rxSsp->psd) / Sum(*noisePsd))
+      << " " << propagationGainDb << std::endl;
+    f.close();
+}
+
+int
+main(int argc, char* argv[])
+{
+    uint32_t simTime = 1000; // simulation time in milliseconds
+    uint32_t timeRes = 10;   // time resolution in milliseconds
+
+    // SCENARIO 10 DL of TR 38.321
+    // This parameters can be set accordingly to 3GPP TR 38.821 or arbitrarily modified
+
+    std::string scenario = "NTN-Suburban"; // 3GPP propagation scenario
+    // All available NTN scenarios: DenseUrban, Urban, Suburban, Rural.
+
+    double frequency = 20e9;     // operating frequency in Hz
+    double bandwidth = 400e6;    // Hz
+    double RB_bandwidth = 120e3; // Hz
+
+    // Satellite parameters
+    double satEIRPDensity = 40;    // dBW/MHz
+    double satAntennaGain = 58.5;  // dB
+    double satAntennaDiameter = 5; // meters
+
+    // UE Parameters
+    double vsatAntennaGain = 39.7;       // dB
+    double vsatAntennaDiameter = 0.6;    // meters
+    double vsatAntennaNoiseFigure = 1.2; // dB
+
+    // Calculate transmission power in dBm using EIRPDensity + 10*log10(Bandwidth) - AntennaGain +
+    // 30
+    double txPow = (satEIRPDensity + 10 * log10(bandwidth / 1e6) - satAntennaGain) + 30;
+
+    NS_LOG_DEBUG("Transmitting power: " << txPow << "dBm, (" << pow(10., (txPow - 30) / 10)
+                                        << "W)");
+
+    Config::SetDefault("ns3::ThreeGppChannelModel::UpdatePeriod",
+                       TimeValue(MilliSeconds(1))); // update the channel at each iteration
+    Config::SetDefault("ns3::ThreeGppChannelConditionModel::UpdatePeriod",
+                       TimeValue(MilliSeconds(0.0))); // do not update the channel condition
+
+    RngSeedManager::SetSeed(1);
+    RngSeedManager::SetRun(1);
+
+    // create and configure the factories for the channel condition and propagation loss models
+    ObjectFactory propagationLossModelFactory;
+    ObjectFactory channelConditionModelFactory;
+
+    // propagationLossModelFactory.SetTypeId (ThreeGppRmaPropagationLossModel::GetTypeId ());
+    if (scenario == "NTN-DenseUrban")
+    {
+        propagationLossModelFactory.SetTypeId(
+            ThreeGppNTNDenseUrbanPropagationLossModel::GetTypeId());
+        channelConditionModelFactory.SetTypeId(
+            ThreeGppNTNDenseUrbanChannelConditionModel::GetTypeId());
+    }
+    else if (scenario == "NTN-Urban")
+    {
+        propagationLossModelFactory.SetTypeId(ThreeGppNTNUrbanPropagationLossModel::GetTypeId());
+        channelConditionModelFactory.SetTypeId(ThreeGppNTNUrbanChannelConditionModel::GetTypeId());
+    }
+    else if (scenario == "NTN-Suburban")
+    {
+        propagationLossModelFactory.SetTypeId(ThreeGppNTNSuburbanPropagationLossModel::GetTypeId());
+        channelConditionModelFactory.SetTypeId(
+            ThreeGppNTNSuburbanChannelConditionModel::GetTypeId());
+    }
+    else if (scenario == "NTN-Rural")
+    {
+        propagationLossModelFactory.SetTypeId(ThreeGppNTNRuralPropagationLossModel::GetTypeId());
+        channelConditionModelFactory.SetTypeId(ThreeGppNTNRuralChannelConditionModel::GetTypeId());
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unknown NTN scenario");
+    }
+
+    // create the propagation loss model
+    m_propagationLossModel = propagationLossModelFactory.Create<ThreeGppPropagationLossModel>();
+    m_propagationLossModel->SetAttribute("Frequency", DoubleValue(frequency));
+    m_propagationLossModel->SetAttribute("ShadowingEnabled", BooleanValue(true));
+
+    // create the spectrum propagation loss model
+    m_spectrumLossModel = CreateObject<ThreeGppSpectrumPropagationLossModel>();
+    m_spectrumLossModel->SetChannelModelAttribute("Frequency", DoubleValue(frequency));
+    m_spectrumLossModel->SetChannelModelAttribute("Scenario", StringValue(scenario));
+
+    // create the channel condition model and associate it with the spectrum and
+    // propagation loss model
+    Ptr<ChannelConditionModel> condModel =
+        channelConditionModelFactory.Create<ThreeGppChannelConditionModel>();
+    m_spectrumLossModel->SetChannelModelAttribute("ChannelConditionModel", PointerValue(condModel));
+    m_propagationLossModel->SetChannelConditionModel(condModel);
+
+    // create the tx and rx nodes
+    NodeContainer nodes;
+    nodes.Create(2);
+
+    // create the tx and rx devices
+    Ptr<SimpleNetDevice> txDev = CreateObject<SimpleNetDevice>();
+    Ptr<SimpleNetDevice> rxDev = CreateObject<SimpleNetDevice>();
+
+    // associate the nodes and the devices
+    nodes.Get(0)->AddDevice(txDev);
+    txDev->SetNode(nodes.Get(0));
+    nodes.Get(1)->AddDevice(rxDev);
+    rxDev->SetNode(nodes.Get(1));
+
+    // create the tx and rx mobility models, set the positions
+    Ptr<GeocentricConstantPositionMobilityModel> txMob =
+        CreateObject<GeocentricConstantPositionMobilityModel>();
+    Ptr<GeocentricConstantPositionMobilityModel> rxMob =
+        CreateObject<GeocentricConstantPositionMobilityModel>();
+
+    txMob->SetGeographicPosition(Vector(45.40869, 11.89448, 35786000)); // GEO over Padova
+    rxMob->SetGeographicPosition(Vector(45.40869, 11.89448, 14.0));     // Padova Coordinates
+
+    // This is not strictly necessary, but is useful to have "sensible" values when using
+    // GetPosition()
+    txMob->SetCoordinateTranslationReferencePoint(
+        Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
+    rxMob->SetCoordinateTranslationReferencePoint(
+        Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
+
+    NS_LOG_DEBUG("TX Position: " << txMob->GetPosition());
+    NS_LOG_DEBUG("RX Position: " << rxMob->GetPosition());
+
+    // assign the mobility models to the nodes
+    nodes.Get(0)->AggregateObject(txMob);
+    nodes.Get(1)->AggregateObject(rxMob);
+
+    // create the antenna objects and set their proprieties
+    Ptr<PhasedArrayModel> txAntenna = CreateObjectWithAttributes<UniformPlanarArray>(
+        "NumColumns",
+        UintegerValue(1),
+        "NumRows",
+        UintegerValue(1),
+        "AntennaElement",
+        PointerValue(CreateObjectWithAttributes<CircularApertureAntennaModel>(
+            "AntennaMaxGainDb",
+            DoubleValue(satAntennaGain),
+            "AntennaCircularApertureRadius",
+            DoubleValue(satAntennaDiameter / 2),
+            "OperatingFrequency",
+            DoubleValue(frequency),
+            "AntennaInclination",
+            DoubleValue(DegreesToRadians(180))) // Points the ground
+                     ));
+
+    Ptr<PhasedArrayModel> rxAntenna = CreateObjectWithAttributes<UniformPlanarArray>(
+        "NumColumns",
+        UintegerValue(1),
+        "NumRows",
+        UintegerValue(1),
+        "AntennaElement",
+        PointerValue(CreateObjectWithAttributes<CircularApertureAntennaModel>(
+            "AntennaMaxGainDb",
+            DoubleValue(vsatAntennaGain),
+            "AntennaCircularApertureRadius",
+            DoubleValue(vsatAntennaDiameter / 2),
+            "OperatingFrequency",
+            DoubleValue(frequency),
+            "AntennaInclination",
+            DoubleValue(DegreesToRadians(0))) // Points the sky
+                     ));
+
+    // set the beamforming vectors
+    DoBeamforming(rxDev, rxAntenna, txDev);
+    DoBeamforming(txDev, txAntenna, rxDev);
+
+    for (int i = 0; i < floor(simTime / timeRes); i++)
+    {
+        Simulator::Schedule(MilliSeconds(timeRes * i),
+                            &ComputeSnr,
+                            ComputeSnrParams(txMob,
+                                             rxMob,
+                                             txPow,
+                                             vsatAntennaNoiseFigure,
+                                             txAntenna,
+                                             rxAntenna,
+                                             frequency,
+                                             bandwidth,
+                                             RB_bandwidth));
+    }
+
+    Simulator::Run();
+    Simulator::Destroy();
+    return 0;
+}
diff --git a/src/spectrum/model/three-gpp-channel-model.cc b/src/spectrum/model/three-gpp-channel-model.cc
index bf0f3acee..1745247f5 100644
--- a/src/spectrum/model/three-gpp-channel-model.cc
+++ b/src/spectrum/model/three-gpp-channel-model.cc
@@ -22,6 +22,7 @@
 #include "three-gpp-channel-model.h"
 
 #include "ns3/double.h"
+#include "ns3/geocentric-constant-position-mobility-model.h"
 #include "ns3/integer.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
@@ -245,6 +246,1240 @@ static const double sqrtC_office_NLOS[6][6] = {
     {0, -0.069282, 0.295397, 0.430696, 0.468462, 0.709214},
 };
 
+/**
+ * The square root matrix for <em>NTN Dense Urban LOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-1 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const double sqrtC_NTN_DenseUrban_LOS[7][7] = {
+    {1, 0, 0, 0, 0, 0, 0},
+    {0, 1, 0, 0, 0, 0, 0},
+    {-0.4, -0.4, 0.824621, 0, 0, 0, 0},
+    {-0.5, 0, 0.242536, 0.83137, 0, 0, 0},
+    {-0.5, -0.2, 0.630593, -0.484671, 0.278293, 0, 0},
+    {0, 0, -0.242536, 0.672172, 0.642214, 0.27735, 0},
+    {-0.8, 0, -0.388057, -0.367926, 0.238537, -4.09997e-15, 0.130931},
+};
+
+/**
+ * The square root matrix for <em>NTN Dense Urban NLOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-2 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const double sqrtC_NTN_DenseUrban_NLOS[6][6] = {
+    {1, 0, 0, 0, 0, 0},
+    {-0.4, 0.916515, 0, 0, 0, 0},
+    {-0.6, 0.174574, 0.78072, 0, 0, 0},
+    {0, 0.654654, 0.365963, 0.661438, 0, 0},
+    {0, -0.545545, 0.762422, 0.118114, 0.327327, 0},
+    {-0.4, -0.174574, -0.396459, 0.392138, 0.49099, 0.507445},
+};
+
+/**
+ * The square root matrix for <em>NTN Urban LOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-3 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const double sqrtC_NTN_Urban_LOS[7][7] = {
+    {1, 0, 0, 0, 0, 0, 0},
+    {0, 1, 0, 0, 0, 0, 0},
+    {-0.4, -0.4, 0.824621, 0, 0, 0, 0},
+    {-0.5, 0, 0.242536, 0.83137, 0, 0, 0},
+    {-0.5, -0.2, 0.630593, -0.484671, 0.278293, 0, 0},
+    {0, 0, -0.242536, 0.672172, 0.642214, 0.27735, 0},
+    {-0.8, 0, -0.388057, -0.367926, 0.238537, -4.09997e-15, 0.130931},
+};
+
+/**
+ * The square root matrix for <em>NTN Urban NLOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-4 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The square root matrix is dependent on the elevation angle, thus requiring a map.
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const std::map<int, std::vector<std::vector<double>>> sqrtC_NTN_Urban_NLOS{
+    {10,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.21, 0.977701, 0, 0, 0, 0},
+         {-0.48, 0.459445, 0.747335, 0, 0, 0},
+         {-0.05, 0.377927, 0.28416, 0.879729, 0, 0},
+         {-0.02, 0.691213, 0.258017, 0.073265, 0.670734, 0},
+         {-0.31, -0.00521632, -0.115615, 0.0788023, 0.00218104, 0.940368},
+     }},
+    {20,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.25, 0.968246, 0, 0, 0, 0},
+         {-0.52, 0.35115, 0.778648, 0, 0, 0},
+         {-0.04, 0.371806, 0.345008, 0.860889, 0, 0},
+         {0, 0.743613, 0.281102, 0.0424415, 0.605161, 0},
+         {-0.32, 0.0206559, -0.0689057, 0.154832, 0.061865, 0.929852},
+     }},
+    {30,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.21, 0.977701, 0, 0, 0, 0},
+         {-0.52, 0.450853, 0.725487, 0, 0, 0},
+         {-0.04, 0.288023, 0.260989, 0.920504, 0, 0},
+         {0.01, 0.697657, 0.386856, 0.0418183, 0.601472, 0},
+         {-0.33, 0.0416283, -0.0694268, 0.166137, 0.139937, 0.915075},
+     }},
+    {40,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.26, 0.965609, 0, 0, 0, 0},
+         {-0.53, 0.395813, 0.749955, 0, 0, 0},
+         {-0.04, 0.299914, 0.320139, 0.897754, 0, 0},
+         {0.01, 0.696556, 0.372815, 0.0580784, 0.610202, 0},
+         {-0.33, 0.0457742, -0.0173584, 0.154417, 0.129332, 0.920941},
+     }},
+    {50,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.25, 0.968246, 0, 0, 0, 0},
+         {-0.57, 0.420864, 0.705672, 0, 0, 0},
+         {-0.03, 0.229797, 0.235501, 0.943839, 0, 0},
+         {0.03, 0.679063, 0.384466, 0.0681379, 0.6209, 0},
+         {-0.41, -0.147173, -0.229228, 0.270707, 0.293002, 0.773668},
+     }},
+    {60,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.2, 0.979796, 0, 0, 0, 0},
+         {-0.53, 0.473568, 0.703444, 0, 0, 0},
+         {-0.05, 0.204124, 0.109225, 0.971547, 0, 0},
+         {0.03, 0.68994, 0.411073, 0.0676935, 0.591202, 0},
+         {-0.4, -0.224537, -0.292371, 0.275609, 0.301835, 0.732828},
+     }},
+    {70,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.19, 0.981784, 0, 0, 0, 0},
+         {-0.5, 0.524555, 0.689088, 0, 0, 0},
+         {-0.03, 0.228462, 0.18163, 0.955989, 0, 0},
+         {-0.02, 0.637818, 0.428725, 0.00608114, 0.639489, 0},
+         {-0.36, -0.18171, -0.282523, 0.106726, 0.123808, 0.854894},
+     }},
+    {80,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.2, 0.979796, 0, 0, 0, 0},
+         {-0.49, 0.502145, 0.712566, 0, 0, 0},
+         {-0.01, 0.232702, 0.151916, 0.960558, 0, 0},
+         {-0.05, 0.612372, 0.376106, 0.0206792, 0.693265, 0},
+         {-0.37, -0.320475, -0.365405, -0.00376264, 0.0364343, 0.790907},
+     }},
+    {90,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.19, 0.981784, 0, 0, 0, 0},
+         {-0.38, 0.58852, 0.713613, 0, 0, 0},
+         {-0.03, 0.360874, 0.12082, 0.924269, 0, 0},
+         {-0.12, 0.526796, 0.34244, 0.0594196, 0.766348, 0},
+         {-0.33, -0.257389, -0.24372, -0.257035, -0.176521, 0.817451},
+     }},
+};
+
+/**
+ * The square root matrix for <em>NTN Suburban LOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-5 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const double sqrtC_NTN_Suburban_LOS[7][7] = {
+    {1, 0, 0, 0, 0, 0, 0},
+    {0, 1, 0, 0, 0, 0, 0},
+    {-0.4, -0.4, 0.824621, 0, 0, 0, 0},
+    {-0.5, 0, 0.242536, 0.83137, 0, 0, 0},
+    {-0.5, -0.2, 0.630593, -0.484671, 0.278293, 0, 0},
+    {0, 0, -0.242536, 0.672172, 0.642214, 0.27735, 0},
+    {-0.8, 0, -0.388057, -0.367926, 0.238537, -4.09997e-15, 0.130931},
+};
+
+/**
+ * The square root matrix for <em>NTN Suburban NLOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-6 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const double sqrtC_NTN_Suburban_NLOS[6][6] = {
+    {1, 0, 0, 0, 0, 0},
+    {-0.4, 0.916515, 0, 0, 0, 0},
+    {-0.6, 0.174574, 0.78072, 0, 0, 0},
+    {0, 0.654654, 0.365963, 0.661438, 0, 0},
+    {0, -0.545545, 0.762422, 0.118114, 0.327327, 0},
+    {-0.4, -0.174574, -0.396459, 0.392138, 0.49099, 0.507445},
+};
+
+/**
+ * The square root matrix for <em>NTN Rural LOS</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-7 and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const double sqrtC_NTN_Rural_LOS[7][7] = {
+    {1, 0, 0, 0, 0, 0, 0},
+    {0, 1, 0, 0, 0, 0, 0},
+    {-0.5, 0, 0.866025, 0, 0, 0, 0},
+    {0, 0, 0, 1, 0, 0, 0},
+    {0, 0, 0, 0, 1, 0, 0},
+    {0.01, 0, -0.0519615, 0.73, -0.2, 0.651383, 0},
+    {-0.17, -0.02, 0.21362, -0.14, 0.24, 0.142773, 0.909661},
+};
+
+/**
+ * The square root matrix for <em>NTN Rural NLOS S Band</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-8a and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The square root matrix is dependent on the elevation angle, thus requiring a map.
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const std::map<int, std::vector<std::vector<double>>> sqrtC_NTN_Rural_NLOS_S{
+    {10,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.36, 0.932952, 0, 0, 0, 0},
+         {0.45, 0.516639, 0.728412, 0, 0, 0},
+         {0.02, 0.329277, 0.371881, 0.867687, 0, 0},
+         {-0.06, 0.59853, 0.436258, -0.0324062, 0.668424, 0},
+         {-0.07, 0.0373009, 0.305087, -0.0280496, -0.225204, 0.921481},
+     }},
+    {20,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.39, 0.920815, 0, 0, 0, 0},
+         {0.52, 0.426579, 0.740021, 0, 0, 0},
+         {0, 0.347518, -0.0381664, 0.936896, 0, 0},
+         {-0.04, 0.710675, 0.172483, 0.116993, 0.670748, 0},
+         {-0.17, -0.0394216, 0.115154, 0.243458, -0.0702635, 0.944498},
+     }},
+    {30,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.41, 0.912086, 0, 0, 0, 0},
+         {0.54, 0.49491, 0.680782, 0, 0, 0},
+         {0, 0.350844, -0.152231, 0.923977, 0, 0},
+         {-0.04, 0.694672, 0.0702137, 0.0832998, 0.709903, 0},
+         {-0.19, -0.0854087, 0.0805978, 0.283811, -0.137441, 0.922318},
+     }},
+    {40,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.37, 0.929032, 0, 0, 0, 0},
+         {0.53, 0.480177, 0.698949, 0, 0, 0},
+         {0.01, 0.434538, 0.00864797, 0.900556, 0, 0},
+         {-0.05, 0.765851, -0.0303947, 0.0421641, 0.63896, 0},
+         {-0.17, -0.16458, 0.0989022, 0.158081, -0.150425, 0.941602},
+     }},
+    {50,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.4, 0.916515, 0, 0, 0, 0},
+         {0.55, 0.403703, 0.731111, 0, 0, 0},
+         {0.02, 0.499719, -0.0721341, 0.862947, 0, 0},
+         {-0.06, 0.835775, -0.156481, 0.0373835, 0.521534, 0},
+         {-0.19, -0.301141, 0.145082, 0.144564, -0.0238067, 0.911427},
+     }},
+    {60,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.41, 0.912086, 0, 0, 0, 0},
+         {0.56, 0.339442, 0.755764, 0, 0, 0},
+         {0.02, 0.436582, -0.0256617, 0.899076, 0, 0},
+         {-0.07, 0.856608, -0.12116, 0.0715303, 0.491453, 0},
+         {-0.2, -0.331109, 0.15136, 0.036082, 0.031313, 0.908391},
+     }},
+    {70,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.4, 0.916515, 0, 0, 0, 0},
+         {0.56, 0.386246, 0.732949, 0, 0, 0},
+         {0.04, 0.573913, -0.0601289, 0.815726, 0, 0},
+         {-0.11, 0.813953, -0.0720183, 0.0281118, 0.565158, 0},
+         {-0.19, -0.432071, 0.236423, -0.0247788, -0.0557206, 0.847113},
+     }},
+    {80,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.46, 0.887919, 0, 0, 0, 0},
+         {0.58, 0.469412, 0.665772, 0, 0, 0},
+         {0.01, 0.309262, -0.286842, 0.90663, 0, 0},
+         {-0.05, 0.762457, -0.268721, -0.0467443, 0.584605, 0},
+         {-0.23, -0.580909, 0.399665, 0.0403629, 0.326208, 0.584698},
+     }},
+    {90,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.3, 0.953939, 0, 0, 0, 0},
+         {0.47, 0.81871, 0.329868, 0, 0, 0},
+         {0.06, 0.0712834, -0.595875, 0.797654, 0, 0},
+         {-0.1, 0.408831, -0.0233859, 0.0412736, 0.905873, 0},
+         {-0.13, -0.407783, 0.439436, -0.0768289, -0.212875, 0.756631},
+     }},
+};
+
+/**
+ * The square root matrix for <em>NTN Rural NLOS Ka Band</em>, which is generated
+ * using the Cholesky decomposition according to 3GPP TR 38.811 v15.4.0 table 6.7.2-8b and follows
+ * the order of [SF, K, DS, ASD, ASA, ZSD, ZSA].
+ *
+ * The square root matrix is dependent on the elevation angle, which acts as the corresponding map's
+ * key..
+ *
+ * The Matlab file to generate the matrices can be found in
+ * https://github.com/nyuwireless-unipd/ns3-mmwave/blob/master/src/mmwave/model/BeamFormingMatrix/SqrtMatrix.m
+ */
+static const std::map<int, std::vector<std::vector<double>>> sqrtC_NTN_Rural_NLOS_Ka{
+    {10,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.36, 0.932952, 0, 0, 0, 0},
+         {0.45, 0.527358, 0.72069, 0, 0, 0},
+         {0.02, 0.350715, 0.355282, 0.866241, 0, 0},
+         {-0.07, 0.562515, 0.478504, 0.0162932, 0.670406, 0},
+         {-0.06, 0.0411597, 0.270982, 0.0121094, -0.159927, 0.946336},
+     }},
+    {20,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.38, 0.924986, 0, 0, 0, 0},
+         {0.52, 0.473088, 0.711188, 0, 0, 0},
+         {0, 0.367573, -0.0617198, 0.927944, 0, 0},
+         {-0.04, 0.68628, 0.149228, 0.115257, 0.701332, 0},
+         {-0.16, -0.0441088, 0.118207, 0.251641, -0.0752458, 0.943131},
+     }},
+    {30,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.42, 0.907524, 0, 0, 0, 0},
+         {0.54, 0.48131, 0.690464, 0, 0, 0},
+         {0, 0.363627, -0.137613, 0.921324, 0, 0},
+         {-0.04, 0.686704, 0.117433, 0.104693, 0.708581, 0},
+         {-0.19, -0.0438556, 0.0922685, 0.269877, -0.136292, 0.928469},
+     }},
+    {40,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.36, 0.932952, 0, 0, 0, 0},
+         {0.53, 0.483197, 0.696865, 0, 0, 0},
+         {0.01, 0.464761, -0.0285153, 0.88492, 0, 0},
+         {-0.05, 0.763169, 0.140255, 0.0562856, 0.626286, 0},
+         {-0.16, -0.126051, 0.0942905, 0.195354, -0.217188, 0.92967},
+     }},
+    {50,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.39, 0.920815, 0, 0, 0, 0},
+         {0.55, 0.406705, 0.729446, 0, 0, 0},
+         {0.01, 0.503793, -0.123923, 0.854831, 0, 0},
+         {-0.06, 0.821664, -0.207246, 0.0245302, 0.526988, 0},
+         {-0.19, -0.254231, 0.10679, 0.190931, -0.0665276, 0.920316},
+     }},
+    {60,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.42, 0.907524, 0, 0, 0, 0},
+         {0.56, 0.391395, 0.730213, 0, 0, 0},
+         {0.02, 0.427978, -0.0393147, 0.902712, 0, 0},
+         {-0.06, 0.820694, -0.119986, 0.105509, 0.545281, 0},
+         {-0.2, -0.279882, 0.180145, 0.0563477, -0.0121631, 0.919723},
+     }},
+    {70,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.36, 0.932952, 0, 0, 0, 0},
+         {0.54, 0.519212, 0.662434, 0, 0, 0},
+         {0.04, 0.412025, -0.0234416, 0.909992, 0, 0},
+         {-0.09, 0.758452, -0.0682296, 0.0214276, 0.64151, 0},
+         {-0.17, -0.387158, 0.306169, -0.0291255, -0.109344, 0.845378},
+     }},
+    {80,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.44, 0.897998, 0, 0, 0, 0},
+         {0.57, 0.43519, 0.696928, 0, 0, 0},
+         {0.01, 0.316705, -0.248988, 0.915207, 0, 0},
+         {-0.06, 0.805793, -0.296262, -0.0419182, 0.507514, 0},
+         {-0.22, -0.497551, 0.289742, 0.0785823, 0.328773, 0.711214},
+     }},
+    {90,
+     {
+         {1, 0, 0, 0, 0, 0},
+         {-0.27, 0.96286, 0, 0, 0, 0},
+         {0.46, 0.741748, 0.488067, 0, 0, 0},
+         {0.04, 0.0735309, -0.374828, 0.923308, 0, 0},
+         {-0.08, 0.517624, 0.128779, 0.0795063, 0.838308, 0},
+         {-0.11, -0.321646, 0.0802763, -0.131981, -0.193429, 0.907285},
+     }},
+};
+
+/**
+ * The enumerator used for code clarity when performing parameter assignment in GetThreeGppTable
+ */
+enum table3gppParams
+{
+    uLgDS,
+    sigLgDS,
+    uLgASD,
+    sigLgASD,
+    uLgASA,
+    sigLgASA,
+    uLgZSA,
+    sigLgZSA,
+    uLgZSD,
+    sigLgZSD,
+    uK,
+    sigK,
+    rTau,
+    uXpr,
+    sigXpr,
+    numOfCluster,
+    raysPerCluster,
+    cDS,
+    cASD,
+    cASA,
+    cZSA,
+    perClusterShadowingStd
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Dense Urban LOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNDenseUrbanLOS{
+    {"S",
+     {
+         {10,
+          {
+              -7.12, 0.8, -3.06, 0.48, 0.94, 0.7,  0.82, 0.03, -2.52, 0.5, 4.4,
+              3.3,   2.5, 24.4,  3.8,  3.0,  20.0, 3.9,  0.0,  11.0,  7.0, 3.0,
+          }},
+         {20,
+          {
+              -7.28, 0.67, -2.68, 0.36, 0.87, 0.66, 0.5, 0.09, -2.29, 0.53, 9.0,
+              6.6,   2.5,  23.6,  4.7,  3.0,  20.0, 3.9, 0.0,  11.0,  7.0,  3.0,
+          }},
+         {30,
+          {
+              -7.45, 0.68, -2.51, 0.38, 0.92, 0.68, 0.82, 0.05, -2.19, 0.58, 9.3,
+              6.1,   2.5,  23.2,  4.6,  3.0,  20.0, 3.9,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {40,
+          {
+              -7.73, 0.66, -2.4, 0.32, 0.79, 0.64, 1.23, 0.03, -2.24, 0.51, 7.9,
+              4.0,   2.5,  22.6, 4.9,  3.0,  20.0, 3.9,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {50,
+          {
+              -7.91, 0.62, -2.31, 0.33, 0.72, 0.63, 1.43, 0.06, -2.3, 0.46, 7.4,
+              3.0,   2.5,  21.8,  5.7,  3.0,  20.0, 3.9,  0.0,  11.0, 7.0,  3.0,
+          }},
+         {60,
+          {
+              -8.14, 0.51, -2.2, 0.39, 0.6, 0.54, 1.56, 0.05, -2.48, 0.35, 7.0,
+              2.6,   2.5,  20.5, 6.9,  3.0, 20.0, 3.9,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {70,
+          {
+              -8.23, 0.45, -2.0, 0.4, 0.55, 0.52, 1.66, 0.05, -2.64, 0.31, 6.9,
+              2.2,   2.5,  19.3, 8.1, 3.0,  20.0, 3.9,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {80,
+          {
+              -8.28, 0.31, -1.64, 0.32, 0.71, 0.53, 1.73, 0.02, -2.68, 0.39, 6.5,
+              2.1,   2.5,  17.4,  10.3, 3.0,  20.0, 3.9,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {90,
+          {
+              -8.36, 0.08, -0.63, 0.53, 0.81, 0.62, 1.79, 0.01, -2.61, 0.28, 6.8,
+              1.9,   2.5,  12.3,  15.2, 3.0,  20.0, 3.9,  0.0,  11.0,  7.0,  3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -7.43, 0.9, -3.43, 0.54, 0.65, 0.82, 0.82, 0.05, -2.75, 0.55, 6.1,
+              2.6,   2.5, 24.7,  2.1,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {20,
+          {
+              -7.62, 0.78, -3.06, 0.41, 0.53, 0.78, 0.47, 0.11, -2.64, 0.64, 13.7,
+              6.8,   2.5,  24.4,  2.8,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {30,
+          {
+              -7.76, 0.8, -2.91, 0.42, 0.6, 0.83, 0.8, 0.05, -2.49, 0.69, 12.9,
+              6.0,   2.5, 24.4,  2.7,  3.0, 20.0, 1.6, 0.0,  11.0,  7.0,  3.0,
+          }},
+         {40,
+          {
+              -8.02, 0.72, -2.81, 0.34, 0.43, 0.78, 1.23, 0.04, -2.51, 0.57, 10.3,
+              3.3,   2.5,  24.2,  2.7,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {50,
+          {
+              -8.13, 0.61, -2.74, 0.34, 0.36, 0.77, 1.42, 0.1, -2.54, 0.5, 9.2,
+              2.2,   2.5,  23.9,  3.1,  3.0,  20.0, 1.6,  0.0, 11.0,  7.0, 3.0,
+          }},
+         {60,
+          {
+              -8.3, 0.47, -2.72, 0.7, 0.16, 0.84, 1.56, 0.06, -2.71, 0.37, 8.4,
+              1.9,  2.5,  23.3,  3.9, 3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {70,
+          {
+              -8.34, 0.39, -2.46, 0.4, 0.18, 0.64, 1.65, 0.07, -2.85, 0.31, 8.0,
+              1.5,   2.5,  22.6,  4.8, 3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {80,
+          {
+              -8.39, 0.26, -2.3, 0.78, 0.24, 0.81, 1.73, 0.02, -3.01, 0.45, 7.4,
+              1.6,   2.5,  21.2, 6.8,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {90,
+          {
+              -8.45, 0.01, -1.11, 0.51, 0.36, 0.65, 1.79, 0.01, -3.08, 0.27, 7.6,
+              1.3,   2.5,  17.6,  12.7, 3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Dense Urban NLOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNDenseUrbanNLOS{
+    {"S",
+     {
+         {10,
+          {
+              -6.84, 0.82, -2.08, 0.87, 1.0,  1.6, 1.0, 0.63, -2.08, 0.58,
+              2.3,   23.8, 4.4,   4.0,  20.0, 3.9, 0.0, 15.0, 7.0,   3.0,
+          }},
+         {20,
+          {
+              -6.81, 0.61, -1.68, 0.73, 1.44, 0.87, 0.94, 0.65, -1.66, 0.5,
+              2.3,   21.9, 6.3,   4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {30,
+          {
+              -6.94, 0.49, -1.46, 0.53, 1.54, 0.64, 1.15, 0.42, -1.48, 0.4,
+              2.3,   19.7, 8.1,   4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {40,
+          {
+              -7.14, 0.49, -1.43, 0.5, 1.53, 0.56, 1.35, 0.28, -1.46, 0.37,
+              2.3,   18.1, 9.3,   4.0, 20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {50,
+          {
+              -7.34, 0.51, -1.44, 0.58, 1.48, 0.54, 1.44, 0.25, -1.53, 0.47,
+              2.3,   16.3, 11.5,  4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {60,
+          {
+              -7.53, 0.47, -1.33, 0.49, 1.39, 0.68, 1.56, 0.16, -1.61, 0.43,
+              2.3,   14.0, 13.3,  4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {70,
+          {
+              -7.67, 0.44, -1.31, 0.65, 1.42, 0.55, 1.64, 0.18, -1.77, 0.5,
+              2.3,   12.1, 14.9,  4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {80,
+          {
+              -7.82, 0.42, -1.11, 0.69, 1.38, 0.6, 1.7, 0.09, -1.9, 0.42,
+              2.3,   8.7,  17.0,  4.0,  20.0, 3.9, 0.0, 15.0, 7.0,  3.0,
+          }},
+         {90,
+          {
+              -7.84, 0.55, -0.11, 0.53, 1.23, 0.6, 1.7, 0.17, -1.99, 0.5,
+              2.3,   6.4,  12.3,  4.0,  20.0, 3.9, 0.0, 15.0, 7.0,   3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -6.86, 0.81, -2.12, 0.94, 1.02, 1.44, 1.01, 0.56, -2.11, 0.59,
+              2.3,   23.7, 4.5,   4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {20,
+          {
+              -6.84, 0.61, -1.74, 0.79, 1.44, 0.77, 0.96, 0.55, -1.69, 0.51,
+              2.3,   21.8, 6.3,   4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {30,
+          {
+              -7.0, 0.56, -1.56, 0.66, 1.48, 0.7, 1.13, 0.43, -1.52, 0.46,
+              2.3,  19.6, 8.2,   4.0,  20.0, 3.9, 0.0,  15.0, 7.0,   3.0,
+          }},
+         {40,
+          {
+              -7.21, 0.56, -1.54, 0.63, 1.46, 0.6, 1.3, 0.37, -1.51, 0.43,
+              2.3,   18.0, 9.4,   4.0,  20.0, 3.9, 0.0, 15.0, 7.0,   3.0,
+          }},
+         {50,
+          {
+              -7.42, 0.57, -1.45, 0.56, 1.4,  0.59, 1.4, 0.32, -1.54, 0.45,
+              2.3,   16.3, 11.5,  4.0,  20.0, 3.9,  0.0, 15.0, 7.0,   3.0,
+          }},
+         {60,
+          {
+              -7.86, 0.55, -1.64, 0.78, 0.97, 1.27, 1.41, 0.45, -1.84, 0.63,
+              2.3,   15.9, 12.4,  4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {70,
+          {
+              -7.76, 0.47, -1.37, 0.56, 1.33, 0.56, 1.63, 0.17, -1.86, 0.51,
+              2.3,   12.3, 15.0,  4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {80,
+          {
+              -8.07, 0.42, -1.29, 0.76, 1.12, 1.04, 1.68, 0.14, -2.16, 0.74,
+              2.3,   10.5, 15.7,  4.0,  20.0, 3.9,  0.0,  15.0, 7.0,   3.0,
+          }},
+         {90,
+          {
+              -7.95, 0.59, -0.41, 0.59, 1.04, 0.63, 1.7, 0.17, -2.21, 0.61,
+              2.3,   10.5, 15.7,  4.0,  20.0, 3.9,  0.0, 15.0, 7.0,   3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Urban LOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNUrbanLOS{
+    {"S",
+     {
+         {10,
+          {
+              -7.97, 1.0, -2.6, 0.79, 0.18, 0.74, -0.63, 2.6,  -2.54, 2.62, 31.83,
+              13.84, 2.5, 8.0,  4.0,  4.0,  20.0, 3.9,   0.09, 12.55, 1.25, 3.0,
+          }},
+         {20,
+          {
+              -8.12, 0.83, -2.48, 0.8, 0.42, 0.9,  -0.15, 3.31, -2.67, 2.96, 18.78,
+              13.78, 2.5,  8.0,   4.0, 3.0,  20.0, 3.9,   0.09, 12.76, 3.23, 3.0,
+          }},
+         {30,
+          {
+              -8.21, 0.68, -2.44, 0.91, 0.41, 1.3,  0.54, 1.1,  -2.03, 0.86, 10.49,
+              10.42, 2.5,  8.0,   4.0,  3.0,  20.0, 3.9,  0.12, 14.36, 4.39, 3.0,
+          }},
+         {40,
+          {
+              -8.31, 0.48, -2.6, 1.02, 0.18, 1.69, 0.35, 1.59, -2.28, 1.19, 7.46,
+              8.01,  2.5,  8.0,  4.0,  3.0,  20.0, 3.9,  0.16, 16.42, 5.72, 3.0,
+          }},
+         {50,
+          {
+              -8.37, 0.38, -2.71, 1.17, -0.07, 2.04, 0.27, 1.62, -2.48, 1.4,  6.52,
+              8.27,  2.5,  8.0,   4.0,  3.0,   20.0, 3.9,  0.2,  17.13, 6.17, 3.0,
+          }},
+         {60,
+          {
+              -8.39, 0.24, -2.76, 1.17, -0.43, 2.54, 0.26, 0.97, -2.56, 0.85, 5.47,
+              7.26,  2.5,  8.0,   4.0,  3.0,   20.0, 3.9,  0.28, 19.01, 7.36, 3.0,
+          }},
+         {70,
+          {
+              -8.38, 0.18, -2.78, 1.2, -0.64, 2.47, -0.12, 1.99, -2.96, 1.61, 4.54,
+              5.53,  2.5,  8.0,   4.0, 3.0,   20.0, 3.9,   0.44, 19.31, 7.3,  3.0,
+          }},
+         {80,
+          {
+              -8.35, 0.13, -2.65, 1.45, -0.91, 2.69, -0.21, 1.82, -3.08, 1.49, 4.03,
+              4.49,  2.5,  8.0,   4.0,  3.0,   20.0, 3.9,   0.9,  22.39, 7.7,  3.0,
+          }},
+         {90,
+          {
+              -8.34, 0.09, -2.27, 1.85, -0.54, 1.66, -0.07, 1.43, -3.0, 1.09, 3.68,
+              3.14,  2.5,  8.0,   4.0,  3.0,   20.0, 3.9,   2.87, 27.8, 9.25, 3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -8.52, 0.92, -3.18, 0.79, -0.4, 0.77, -0.67, 2.22, -2.61, 2.41, 40.18,
+              16.99, 2.5,  8.0,   4.0,  4.0,  20.0, 1.6,   0.09, 11.8,  1.14, 3.0,
+          }},
+         {20,
+          {
+              -8.59, 0.79, -3.05, 0.87, -0.15, 0.97, -0.34, 3.04, -2.82, 2.59, 23.62,
+              18.96, 2.5,  8.0,   4.0,  3.0,   20.0, 1.6,   0.09, 11.6,  2.78, 3.0,
+          }},
+         {30,
+          {
+              -8.51, 0.65, -2.98, 1.04, -0.18, 1.58, 0.07, 1.33, -2.48, 1.02, 12.48,
+              14.23, 2.5,  8.0,   4.0,  3.0,   20.0, 1.6,  0.11, 13.05, 3.87, 3.0,
+          }},
+         {40,
+          {
+              -8.49, 0.48, -3.11, 1.06, -0.31, 1.69, -0.08, 1.45, -2.76, 1.27, 8.56,
+              11.06, 2.5,  8.0,   4.0,  3.0,   20.0, 1.6,   0.15, 14.56, 4.94, 3.0,
+          }},
+         {50,
+          {
+              -8.48, 0.46, -3.19, 1.12, -0.58, 2.13, -0.21, 1.62, -2.93, 1.38, 7.42,
+              11.21, 2.5,  8.0,   4.0,  3.0,   20.0, 1.6,   0.18, 15.35, 5.41, 3.0,
+          }},
+         {60,
+          {
+              -8.44, 0.34, -3.25, 1.14, -0.9, 2.51, -0.25, 1.06, -3.05, 0.96, 5.97,
+              9.47,  2.5,  8.0,   4.0,  3.0,  20.0, 1.6,   0.27, 16.97, 6.31, 3.0,
+          }},
+         {70,
+          {
+              -8.4, 0.27, -3.33, 1.25, -1.16, 2.47, -0.61, 1.88, -3.45, 1.51, 4.88,
+              7.24, 2.5,  8.0,   4.0,  3.0,   20.0, 1.6,   0.42, 17.96, 6.66, 3.0,
+          }},
+         {80,
+          {
+              -8.37, 0.19, -3.22, 1.35, -1.48, 2.61, -0.79, 1.87, -3.66, 1.49, 4.22,
+              5.79,  2.5,  8.0,   4.0,  3.0,   20.0, 1.6,   0.86, 20.68, 7.31, 3.0,
+          }},
+         {90,
+          {
+              -8.35, 0.14, -2.83, 1.62, -1.14, 1.7,  -0.58, 1.19, -3.56, 0.89, 3.81,
+              4.25,  2.5,  8.0,   4.0,  3.0,   20.0, 1.6,   2.55, 25.08, 9.23, 3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Urban NLOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNUrbanNLOS{
+    {"S",
+     {
+         {10,
+          {
+              -7.24, 1.26, -1.58, 0.89, 0.13, 2.99, -1.13, 2.66, -2.87, 2.76, 0.0,
+              0.0,   2.3,  7.0,   3.0,  3.0,  20.0, 1.6,   0.08, 14.72, 1.57, 3.0,
+          }},
+         {20,
+          {
+              -7.7, 0.99, -1.67, 0.89, 0.19, 3.12, 0.49, 2.03, -2.68, 2.76, 0.0,
+              0.0,  2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.1,  14.62, 4.3,  3.0,
+          }},
+         {30,
+          {
+              -7.82, 0.86, -1.84, 1.3, 0.44, 2.69, 0.95, 1.54, -2.12, 1.54, 0.0,
+              0.0,   2.3,  7.0,   3.0, 3.0,  20.0, 1.6,  0.14, 16.4,  6.64, 3.0,
+          }},
+         {40,
+          {
+              -8.04, 0.75, -2.02, 1.15, 0.48, 2.45, 1.15, 1.02, -2.27, 1.77, 0.0,
+              0.0,   2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.22, 17.86, 9.21, 3.0,
+          }},
+         {50,
+          {
+              -8.08, 0.77, -2.06, 1.23, 0.56, 2.17, 1.14, 1.61, -2.5,  2.36,  0.0,
+              0.0,   2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.31, 19.74, 10.32, 3.0,
+          }},
+         {60,
+          {
+              -8.1, 0.76, -1.99, 1.02, 0.55, 1.93, 1.13, 1.84, -2.47, 2.33, 0.0,
+              0.0,  2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.49, 19.73, 10.3, 3.0,
+          }},
+         {70,
+          {
+              -8.16, 0.73, -2.19, 1.78, 0.48, 1.72, 1.16, 1.81, -2.83, 2.84, 0.0,
+              0.0,   2.3,  7.0,   3.0,  2.0,  20.0, 1.6,  0.97, 20.5,  10.2, 3.0,
+          }},
+         {80,
+          {
+              -8.03, 0.79, -1.88, 1.55, 0.53, 1.51, 1.28, 1.35, -2.82, 2.87,  0.0,
+              0.0,   2.3,  7.0,   3.0,  2.0,  20.0, 1.6,  1.52, 26.16, 12.27, 3.0,
+          }},
+         {90,
+          {
+              -8.33, 0.7, -2.0, 1.4, 0.32, 1.2,  1.42, 0.6,  -4.55, 4.27,  0.0,
+              0.0,   2.3, 7.0,  3.0, 2.0,  20.0, 1.6,  5.36, 25.83, 12.75, 3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -7.24, 1.26, -1.58, 0.89, 0.13, 2.99, -1.13, 2.66, -2.87, 2.76, 0.0,
+              0.0,   2.3,  7.0,   3.0,  3.0,  20.0, 1.6,   0.08, 14.72, 1.57, 3.0,
+          }},
+         {20,
+          {
+              -7.7, 0.99, -1.67, 0.89, 0.19, 3.12, 0.49, 2.03, -2.68, 2.76, 0.0,
+              0.0,  2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.1,  14.62, 4.3,  3.0,
+          }},
+         {30,
+          {
+              -7.82, 0.86, -1.84, 1.3, 0.44, 2.69, 0.95, 1.54, -2.12, 1.54, 0.0,
+              0.0,   2.3,  7.0,   3.0, 3.0,  20.0, 1.6,  0.14, 16.4,  6.64, 3.0,
+          }},
+         {40,
+          {
+              -8.04, 0.75, -2.02, 1.15, 0.48, 2.45, 1.15, 1.02, -2.27, 1.77, 0.0,
+              0.0,   2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.22, 17.86, 9.21, 3.0,
+          }},
+         {50,
+          {
+              -8.08, 0.77, -2.06, 1.23, 0.56, 2.17, 1.14, 1.61, -2.5,  2.36,  0.0,
+              0.0,   2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.31, 19.74, 10.32, 3.0,
+          }},
+         {60,
+          {
+              -8.1, 0.76, -1.99, 1.02, 0.55, 1.93, 1.13, 1.84, -2.47, 2.33, 0.0,
+              0.0,  2.3,  7.0,   3.0,  3.0,  20.0, 1.6,  0.49, 19.73, 10.3, 3.0,
+          }},
+         {70,
+          {
+              -8.16, 0.73, -2.19, 1.78, 0.48, 1.72, 1.16, 1.81, -2.83, 2.84, 0.0,
+              0.0,   2.3,  7.0,   3.0,  2.0,  20.0, 1.6,  0.97, 20.5,  10.2, 3.0,
+          }},
+         {80,
+          {
+              -8.03, 0.79, -1.88, 1.55, 0.53, 1.51, 1.28, 1.35, -2.82, 2.87,  0.0,
+              0.0,   2.3,  7.0,   3.0,  2.0,  20.0, 1.6,  1.52, 26.16, 12.27, 3.0,
+          }},
+         {90,
+          {
+              -8.33, 0.7, -2.0, 1.4, 0.32, 1.2,  1.42, 0.6,  -4.55, 4.27,  0.0,
+              0.0,   2.3, 7.0,  3.0, 2.0,  20.0, 1.6,  5.36, 25.83, 12.75, 3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Suburban LOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNSuburbanLOS{
+    {"S",
+     {
+         {10,
+          {
+              -8.16, 0.99, -3.57, 1.62, 0.05, 1.84, -1.78, 0.62, -1.06, 0.96, 11.4,
+              6.26,  2.2,  21.3,  7.6,  3.0,  20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {20,
+          {
+              -8.56, 0.96, -3.8, 1.74, -0.38, 1.94, -1.84, 0.81, -1.21, 0.95, 19.45,
+              10.32, 3.36, 21.0, 8.9,  3.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {30,
+          {
+              -8.72, 0.79, -3.77, 1.72, -0.56, 1.75, -1.67, 0.57, -1.28, 0.49, 20.8,
+              16.34, 3.5,  21.2,  8.5,  3.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {40,
+          {
+              -8.71, 0.81, -3.57, 1.6, -0.59, 1.82, -1.59, 0.86, -1.32, 0.79, 21.2,
+              15.63, 2.81, 21.1,  8.4, 3.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {50,
+          {
+              -8.72, 1.12, -3.42, 1.49, -0.58, 1.87, -1.55, 1.05, -1.39, 0.97, 21.6,
+              14.22, 2.39, 20.7,  9.2,  3.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {60,
+          {
+              -8.66, 1.23, -3.27, 1.43, -0.55, 1.92, -1.51, 1.23, -1.36, 1.17, 19.75,
+              14.19, 2.73, 20.6,  9.8,  3.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {70,
+          {
+              -8.38, 0.55, -3.08, 1.36, -0.28, 1.16, -1.27, 0.54, -1.08, 0.62, 12.0,
+              5.7,   2.07, 20.3,  10.8, 2.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {80,
+          {
+              -8.34, 0.63, -2.75, 1.26, -0.17, 1.09, -1.28, 0.67, -1.31, 0.76, 12.85,
+              9.91,  2.04, 19.8,  12.2, 2.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+         {90,
+          {
+              -8.34, 0.63, -2.75, 1.26, -0.17, 1.09, -1.28, 0.67, -1.31, 0.76, 12.85,
+              9.91,  2.04, 19.1,  13.0, 2.0,   20.0, 1.6,   0.0,  11.0,  7.0,  3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -8.07, 0.46, -3.55, 0.48, 0.89, 0.67, 0.63, 0.35, -3.37, 0.28, 8.9,
+              4.4,   2.5,  23.2,  5.0,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {20,
+          {
+              -8.61, 0.45, -3.69, 0.41, 0.31, 0.78, 0.76, 0.3, -3.28, 0.27, 14.0,
+              4.6,   2.5,  23.6,  4.5,  3.0,  20.0, 1.6,  0.0, 11.0,  7.0,  3.0,
+          }},
+         {30,
+          {
+              -8.72, 0.28, -3.59, 0.41, 0.02, 0.75, 1.11, 0.28, -3.04, 0.26, 11.3,
+              3.7,   2.5,  23.5,  4.7,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {40,
+          {
+              -8.63, 0.17, -3.38, 0.35, -0.1, 0.65, 1.37, 0.23, -2.88, 0.21, 9.0,
+              3.5,   2.5,  23.4,  5.2,  3.0,  20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {50,
+          {
+              -8.54, 0.14, -3.23, 0.35, -0.19, 0.55, 1.53, 0.23, -2.83, 0.18, 7.5,
+              3.0,   2.5,  23.2,  5.7,  3.0,   20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {60,
+          {
+              -8.48, 0.15, -3.19, 0.43, -0.54, 0.96, 1.65, 0.17, -2.86, 0.17, 6.6,
+              2.6,   2.5,  23.3,  5.9,  3.0,   20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {70,
+          {
+              -8.42, 0.09, -2.83, 0.33, -0.24, 0.43, 1.74, 0.11, -2.95, 0.1, 5.9,
+              1.7,   2.5,  23.4,  6.2,  2.0,   20.0, 1.6,  0.0,  11.0,  7.0, 3.0,
+          }},
+         {80,
+          {
+              -8.39, 0.05, -2.66, 0.44, -0.52, 0.93, 1.82, 0.05, -3.21, 0.07, 5.5,
+              0.7,   2.5,  23.2,  7.0,  2.0,   20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+         {90,
+          {
+              -8.37, 0.02, -1.22, 0.31, -0.15, 0.44, 1.87, 0.02, -3.49, 0.24, 5.4,
+              0.3,   2.5,  23.1,  7.6,  2.0,   20.0, 1.6,  0.0,  11.0,  7.0,  3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Suburban NLOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNSuburbanNLOS{
+    {"S",
+     {
+         {10,
+          {
+              -7.43, 0.5, -2.89, 0.41, 1.49, 0.4,  0.81, 0.36, -3.09, 0.32, 0.0,
+              0.0,   2.3, 22.5,  5.0,  4.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {20,
+          {
+              -7.63, 0.61, -2.76, 0.41, 1.24, 0.82, 1.06, 0.41, -2.93, 0.47, 0.0,
+              0.0,   2.3,  19.4,  8.5,  4.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {30,
+          {
+              -7.86, 0.56, -2.64, 0.41, 1.06, 0.71, 1.12, 0.4, -2.91, 0.46, 0.0,
+              0.0,   2.3,  15.5,  10.0, 4.0,  20.0, 1.6,  0.0, 15.0,  7.0,  3.0,
+          }},
+         {40,
+          {
+              -7.96, 0.58, -2.41, 0.52, 0.91, 0.55, 1.14, 0.39, -2.78, 0.54, 0.0,
+              0.0,   2.3,  13.9,  10.6, 4.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {50,
+          {
+              -7.98, 0.59, -2.42, 0.7,  0.98, 0.58, 1.29, 0.35, -2.7, 0.45, 0.0,
+              0.0,   2.3,  11.7,  10.0, 4.0,  20.0, 1.6,  0.0,  15.0, 7.0,  3.0,
+          }},
+         {60,
+          {
+              -8.45, 0.47, -2.53, 0.5, 0.49, 1.37, 1.38, 0.36, -3.03, 0.36, 0.0,
+              0.0,   2.3,  9.8,   9.1, 3.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {70,
+          {
+              -8.21, 0.36, -2.35, 0.58, 0.73, 0.49, 1.36, 0.29, -2.9, 0.42, 0.0,
+              0.0,   2.3,  10.3,  9.1,  3.0,  20.0, 1.6,  0.0,  15.0, 7.0,  3.0,
+          }},
+         {80,
+          {
+              -8.69, 0.29, -2.31, 0.73, -0.04, 1.48, 1.38, 0.2, -3.2, 0.3, 0.0,
+              0.0,   2.3,  15.6,  9.1,  3.0,   20.0, 1.6,  0.0, 15.0, 7.0, 3.0,
+          }},
+         {90,
+          {
+              -8.69, 0.29, -2.31, 0.73, -0.04, 1.48, 1.38, 0.2, -3.2, 0.3, 0.0,
+              0.0,   2.3,  15.6,  9.1,  3.0,   20.0, 1.6,  0.0, 15.0, 7.0, 3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -7.43, 0.5, -2.89, 0.41, 1.49, 0.4,  0.81, 0.36, -3.09, 0.32, 0.0,
+              0.0,   2.3, 22.5,  5.0,  4.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {20,
+          {
+              -7.63, 0.61, -2.76, 0.41, 1.24, 0.82, 1.06, 0.41, -2.93, 0.47, 0.0,
+              0.0,   2.3,  19.4,  8.5,  4.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {30,
+          {
+              -7.86, 0.56, -2.64, 0.41, 1.06, 0.71, 1.12, 0.4, -2.91, 0.46, 0.0,
+              0.0,   2.3,  15.5,  10.0, 4.0,  20.0, 1.6,  0.0, 15.0,  7.0,  3.0,
+          }},
+         {40,
+          {
+              -7.96, 0.58, -2.41, 0.52, 0.91, 0.55, 1.14, 0.39, -2.78, 0.54, 0.0,
+              0.0,   2.3,  13.9,  10.6, 4.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {50,
+          {
+              -7.98, 0.59, -2.42, 0.7,  0.98, 0.58, 1.29, 0.35, -2.7, 0.45, 0.0,
+              0.0,   2.3,  11.7,  10.0, 4.0,  20.0, 1.6,  0.0,  15.0, 7.0,  3.0,
+          }},
+         {60,
+          {
+              -8.45, 0.47, -2.53, 0.5, 0.49, 1.37, 1.38, 0.36, -3.03, 0.36, 0.0,
+              0.0,   2.3,  9.8,   9.1, 3.0,  20.0, 1.6,  0.0,  15.0,  7.0,  3.0,
+          }},
+         {70,
+          {
+              -8.21, 0.36, -2.35, 0.58, 0.73, 0.49, 1.36, 0.29, -2.9, 0.42, 0.0,
+              0.0,   2.3,  10.3,  9.1,  3.0,  20.0, 1.6,  0.0,  15.0, 7.0,  3.0,
+          }},
+         {80,
+          {
+              -8.69, 0.29, -2.31, 0.73, -0.04, 1.48, 1.38, 0.2, -3.2, 0.3, 0.0,
+              0.0,   2.3,  15.6,  9.1,  3.0,   20.0, 1.6,  0.0, 15.0, 7.0, 3.0,
+          }},
+         {90,
+          {
+              -8.69, 0.29, -2.31, 0.73, -0.04, 1.48, 1.38, 0.2, -3.2, 0.3, 0.0,
+              0.0,   2.3,  15.6,  9.1,  3.0,   20.0, 1.6,  0.0, 15.0, 7.0, 3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Rural LOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNRuralLOS{
+    {"S",
+     {
+         {10,
+          {
+              -9.55, 0.66, -3.42, 0.89, -9.45, 7.83, -4.2, 6.3,  -6.03, 5.19, 24.72,
+              5.07,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,  0.39, 10.81, 1.94, 3.0,
+          }},
+         {20,
+          {
+              -8.68, 0.44, -3.0, 0.63, -4.45, 6.86, -2.31, 5.04, -4.31, 4.18, 12.31,
+              5.75,  3.8,  12.0, 4.0,  2.0,   20.0, 0.0,   0.31, 8.09,  1.83, 3.0,
+          }},
+         {30,
+          {
+              -8.46, 0.28, -2.86, 0.52, -2.39, 5.14, -0.28, 0.81, -2.57, 0.61, 8.05,
+              5.46,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   0.29, 13.7,  2.28, 3.0,
+          }},
+         {40,
+          {
+              -8.36, 0.19, -2.78, 0.45, -1.28, 3.44, -0.38, 1.16, -2.59, 0.79, 6.21,
+              5.23,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   0.37, 20.05, 2.93, 3.0,
+          }},
+         {50,
+          {
+              -8.29, 0.14, -2.7, 0.42, -0.99, 2.59, -0.38, 0.82, -2.59, 0.65, 5.04,
+              3.95,  3.8,  12.0, 4.0,  2.0,   20.0, 0.0,   0.61, 24.51, 2.84, 3.0,
+          }},
+         {60,
+          {
+              -8.26, 0.1, -2.66, 0.41, -1.05, 2.42, -0.46, 0.67, -2.65, 0.52, 4.42,
+              3.75,  3.8, 12.0,  4.0,  2.0,   20.0, 0.0,   0.9,  26.35, 3.17, 3.0,
+          }},
+         {70,
+          {
+              -8.22, 0.1, -2.53, 0.42, -0.9, 1.78, -0.49, 1.0,  -2.69, 0.78, 3.92,
+              2.56,  3.8, 12.0,  4.0,  2.0,  20.0, 0.0,   1.43, 31.84, 3.88, 3.0,
+          }},
+         {80,
+          {
+              -8.2, 0.05, -2.21, 0.5, -0.89, 1.65, -0.53, 1.18, -2.65, 1.01, 3.65,
+              1.77, 3.8,  12.0,  4.0, 2.0,   20.0, 0.0,   2.87, 36.62, 4.17, 3.0,
+          }},
+         {90,
+          {
+              -8.19, 0.06, -1.78, 0.91, -0.81, 1.26, -0.46, 0.91, -2.65, 0.71, 3.59,
+              1.77,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   5.48, 36.77, 4.29, 3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -9.68, 0.46, -4.03, 0.91, -9.74, 7.52, -5.85, 6.51, -7.45, 5.3,  25.43,
+              7.04,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   0.36, 4.63,  0.75, 3.0,
+          }},
+         {20,
+          {
+              -8.86, 0.29, -3.55, 0.7, -4.88, 6.67, -3.27, 5.36, -5.25, 4.42, 12.72,
+              7.47,  3.8,  12.0,  4.0, 2.0,   20.0, 0.0,   0.3,  6.83,  1.25, 3.0,
+          }},
+         {30,
+          {
+              -8.59, 0.18, -3.45, 0.55, -2.6, 4.63, -0.88, 0.93, -3.16, 0.68, 8.4,
+              7.18,  3.8,  12.0,  4.0,  2.0,  20.0, 0.0,   0.25, 12.91, 1.93, 3.0,
+          }},
+         {40,
+          {
+              -8.46, 0.19, -3.38, 0.52, -1.92, 3.45, -0.93, 0.96, -3.15, 0.73, 6.52,
+              6.88,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   0.35, 18.9,  2.37, 3.0,
+          }},
+         {50,
+          {
+              -8.36, 0.14, -3.33, 0.46, -1.56, 2.44, -0.99, 0.97, -3.2,  0.77, 5.24,
+              5.28,  3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   0.53, 22.44, 2.66, 3.0,
+          }},
+         {60,
+          {
+              -8.3, 0.15, -3.29, 0.43, -1.66, 2.38, -1.04, 0.83, -3.27, 0.61, 4.57,
+              4.92, 3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   0.88, 25.69, 3.23, 3.0,
+          }},
+         {70,
+          {
+              -8.26, 0.13, -3.24, 0.46, -1.59, 1.67, -1.17, 1.01, -3.42, 0.74, 4.02,
+              3.4,   3.8,  12.0,  4.0,  2.0,   20.0, 0.0,   1.39, 27.95, 3.71, 3.0,
+          }},
+         {80,
+          {
+              -8.22, 0.03, -2.9, 0.44, -1.58, 1.44, -1.19, 1.01, -3.36, 0.79, 3.7,
+              2.22,  3.8,  12.0, 4.0,  2.0,   20.0, 0.0,   2.7,  31.45, 4.17, 3.0,
+          }},
+         {90,
+          {
+              -8.21, 0.07, -2.5, 0.82, -1.51, 1.13, -1.13, 0.85, -3.35, 0.65, 3.62,
+              2.28,  3.8,  12.0, 4.0,  2.0,   20.0, 0.0,   4.97, 28.01, 4.14, 3.0,
+          }},
+     }},
+};
+
+/**
+ * The nested map containing the threegpp value tables for the NTN Rural NLOS scenario
+ */
+static const std::map<std::string, std::map<int, std::vector<float>>> NTNRuralNLOS{
+    {"S",
+     {
+         {10,
+          {
+              -9.01, 1.59, -2.9, 1.34, -3.33, 6.22, -0.88, 3.26, -4.92, 3.96, 0.0,
+              0.0,   1.7,  7.0,  3.0,  3.0,   20.0, 0.0,   0.03, 18.16, 2.32, 3.0,
+          }},
+         {20,
+          {
+              -8.37, 0.95, -2.5, 1.18, -0.74, 4.22, -0.07, 3.29, -4.06, 4.07, 0.0,
+              0.0,   1.7,  7.0,  3.0,  3.0,   20.0, 0.0,   0.05, 26.82, 7.34, 3.0,
+          }},
+         {30,
+          {
+              -8.05, 0.92, -2.12, 1.08, 0.08, 3.02, 0.75, 1.92, -2.33, 1.7,  0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  0.07, 21.99, 8.28, 3.0,
+          }},
+         {40,
+          {
+              -7.92, 0.92, -1.99, 1.06, 0.32, 2.45, 0.72, 1.92, -2.24, 2.01, 0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  0.1,  22.86, 8.76, 3.0,
+          }},
+         {50,
+          {
+              -7.92, 0.87, -1.9, 1.05, 0.53, 1.63, 0.95, 1.45, -2.24, 2.0,  0.0,
+              0.0,   1.7,  7.0,  3.0,  2.0,  20.0, 0.0,  0.15, 25.93, 9.68, 3.0,
+          }},
+         {60,
+          {
+              -7.96, 0.87, -1.85, 1.06, 0.33, 2.08, 0.97, 1.62, -2.22, 1.82, 0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  0.22, 27.79, 9.94, 3.0,
+          }},
+         {70,
+          {
+              -7.91, 0.82, -1.69, 1.14, 0.55, 1.58, 1.1, 1.43, -2.19, 1.66, 0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0, 0.5,  28.5,  8.9,  3.0,
+          }},
+         {80,
+          {
+              -7.79, 0.86, -1.46, 1.16, 0.45, 2.01, 0.97, 1.88, -2.41, 2.58,  0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  1.04, 37.53, 13.74, 3.0,
+          }},
+         {90,
+          {
+              -7.74, 0.81, -1.32, 1.3, 0.4, 2.19, 1.35, 0.62, -2.45, 2.52,  0.0,
+              0.0,   1.7,  7.0,   3.0, 2.0, 20.0, 0.0,  2.11, 29.23, 12.16, 3.0,
+          }},
+     }},
+    {"Ka",
+     {
+         {10,
+          {
+              -9.13, 1.91, -2.9, 1.32, -3.4, 6.28, -1.19, 3.81, -5.47, 4.39, 0.0,
+              0.0,   1.7,  7.0,  3.0,  3.0,  20.0, 0.0,   0.03, 18.21, 2.13, 3.0,
+          }},
+         {20,
+          {
+              -8.39, 0.94, -2.53, 1.18, -0.51, 3.75, -0.11, 3.33, -4.06, 4.04, 0.0,
+              0.0,   1.7,  7.0,   3.0,  3.0,   20.0, 0.0,   0.05, 24.08, 6.52, 3.0,
+          }},
+         {30,
+          {
+              -8.1, 0.92, -2.16, 1.08, 0.06, 2.95, 0.72, 1.93, -2.32, 1.54, 0.0,
+              0.0,  1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  0.07, 22.06, 7.72, 3.0,
+          }},
+         {40,
+          {
+              -7.96, 0.94, -2.04, 1.09, 0.2, 2.65, 0.69, 1.91, -2.19, 1.73, 0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0, 20.0, 0.0,  0.09, 21.4,  8.45, 3.0,
+          }},
+         {50,
+          {
+              -7.99, 0.89, -1.99, 1.08, 0.4, 1.85, 0.84, 1.7,  -2.16, 1.5,  0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0, 20.0, 0.0,  0.16, 24.26, 8.92, 3.0,
+          }},
+         {60,
+          {
+              -8.05, 0.87, -1.95, 1.06, 0.32, 1.83, 0.99, 1.27, -2.24, 1.64, 0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  0.22, 24.15, 8.76, 3.0,
+          }},
+         {70,
+          {
+              -8.01, 0.82, -1.81, 1.17, 0.46, 1.57, 0.95, 1.86, -2.29, 1.66, 0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  0.51, 25.99, 9.0,  3.0,
+          }},
+         {80,
+          {
+              -8.05, 1.65, -1.56, 1.2, 0.33, 1.99, 0.92, 1.84, -2.65, 2.86, 0.0,
+              0.0,   1.7,  7.0,   3.0, 2.0,  20.0, 0.0,  0.89, 36.07, 13.6, 3.0,
+          }},
+         {90,
+          {
+              -7.91, 0.76, -1.53, 1.27, 0.24, 2.18, 1.29, 0.59, -2.23, 1.12,  0.0,
+              0.0,   1.7,  7.0,   3.0,  2.0,  20.0, 0.0,  1.68, 24.51, 10.56, 3.0,
+          }},
+     }},
+};
+
 ThreeGppChannelModel::ThreeGppChannelModel()
 {
     NS_LOG_FUNCTION(this);
@@ -255,6 +1490,15 @@ ThreeGppChannelModel::ThreeGppChannelModel()
     m_normalRv = CreateObject<NormalRandomVariable>();
     m_normalRv->SetAttribute("Mean", DoubleValue(0.0));
     m_normalRv->SetAttribute("Variance", DoubleValue(1.0));
+
+    m_NTNDenseUrbanLOS = &NTNDenseUrbanLOS;
+    m_NTNDenseUrbanNLOS = &NTNDenseUrbanNLOS;
+    m_NTNUrbanLOS = &NTNUrbanLOS;
+    m_NTNUrbanNLOS = &NTNUrbanNLOS;
+    m_NTNSuburbanLOS = &NTNSuburbanLOS;
+    m_NTNSuburbanNLOS = &NTNSuburbanNLOS;
+    m_NTNRuralLOS = &NTNRuralLOS;
+    m_NTNRuralNLOS = &NTNRuralNLOS;
 }
 
 ThreeGppChannelModel::~ThreeGppChannelModel()
@@ -291,7 +1535,8 @@ ThreeGppChannelModel::GetTypeId()
                           MakeDoubleChecker<double>())
             .AddAttribute(
                 "Scenario",
-                "The 3GPP scenario (RMa, UMa, UMi-StreetCanyon, InH-OfficeOpen, InH-OfficeMixed)",
+                "The 3GPP scenario (RMa, UMa, UMi-StreetCanyon, InH-OfficeOpen, InH-OfficeMixed, "
+                "NTN-DenseUrban, NTN-Urban, NTN-Suburban, NTN-Rural)",
                 StringValue("UMa"),
                 MakeStringAccessor(&ThreeGppChannelModel::SetScenario,
                                    &ThreeGppChannelModel::GetScenario),
@@ -377,9 +1622,12 @@ ThreeGppChannelModel::SetScenario(const std::string& scenario)
     NS_LOG_FUNCTION(this);
     NS_ASSERT_MSG(scenario == "RMa" || scenario == "UMa" || scenario == "UMi-StreetCanyon" ||
                       scenario == "InH-OfficeOpen" || scenario == "InH-OfficeMixed" ||
-                      scenario == "V2V-Urban" || scenario == "V2V-Highway",
+                      scenario == "V2V-Urban" || scenario == "V2V-Highway" ||
+                      scenario == "NTN-DenseUrban" || scenario == "NTN-Urban" ||
+                      scenario == "NTN-Suburban" || scenario == "NTN-Rural",
                   "Unknown scenario, choose between: RMa, UMa, UMi-StreetCanyon, "
-                  "InH-OfficeOpen, InH-OfficeMixed, V2V-Urban or V2V-Highway");
+                  "InH-OfficeOpen, InH-OfficeMixed, V2V-Urban, V2V-Highway, "
+                  "NTN-DenseUrban, NTN-Urban, NTN-Suburban or NTN-Rural");
     m_scenario = scenario;
 }
 
@@ -391,13 +1639,20 @@ ThreeGppChannelModel::GetScenario() const
 }
 
 Ptr<const ThreeGppChannelModel::ParamsTable>
-ThreeGppChannelModel::GetThreeGppTable(Ptr<const ChannelCondition> channelCondition,
-                                       double hBS,
-                                       double hUT,
-                                       double distance2D) const
+ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
+                                       const Ptr<const MobilityModel> bMob,
+                                       Ptr<const ChannelCondition> channelCondition) const
 {
     NS_LOG_FUNCTION(this);
 
+    // NOTE we assume hUT = min (height(a), height(b)) and
+    // hBS = max (height (a), height (b))
+    double hUT = std::min(aMob->GetPosition().z, bMob->GetPosition().z);
+    double hBS = std::max(aMob->GetPosition().z, bMob->GetPosition().z);
+
+    double distance2D = sqrt(pow(aMob->GetPosition().x - bMob->GetPosition().x, 2) +
+                             pow(aMob->GetPosition().y - bMob->GetPosition().y, 2));
+
     double fcGHz = m_frequency / 1.0e9;
     Ptr<ParamsTable> table3gpp = Create<ParamsTable>();
     // table3gpp includes the following parameters:
@@ -1045,6 +2300,651 @@ ThreeGppChannelModel::GetThreeGppTable(Ptr<const ChannelCondition> channelCondit
             NS_FATAL_ERROR("Unknown channel condition");
         }
     }
+    else if (m_scenario.substr(0, 3) == "NTN")
+    {
+        std::string freqBand = (fcGHz < 13) ? "S" : "Ka";
+
+        double elevAngle = 0;
+        bool isSatellite = false; // flag to indicate if one of the two nodes is a isSatellite
+                                  // if so, parameters will be set accordingly to NOTE 8 of
+                                  // Table 6.7.2 from 3GPP 38.811 V15.4.0 (2020-09)
+
+        Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(aMob);
+        Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(bMob);
+
+        if (DynamicCast<GeocentricConstantPositionMobilityModel>(
+                ConstCast<MobilityModel>(aMob)) && // Transform to NS_ASSERT
+            DynamicCast<GeocentricConstantPositionMobilityModel>(
+                ConstCast<MobilityModel>(bMob))) // check if aMob and bMob are of type
+                                                 // GeocentricConstantPositionMobilityModel
+        {
+            Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
+                DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
+            Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
+                DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+
+            if (aNTNMob->GetGeographicPosition().z <
+                bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+            {
+                elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
+                if (bNTNMob->GetGeographicPosition().z > 50000)
+                {
+                    isSatellite = true;
+                }
+            }
+            else // a is the HAPS/Satellite
+            {
+                elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
+                if (aNTNMob->GetGeographicPosition().z > 50000)
+                {
+                    isSatellite = true;
+                }
+            }
+        }
+        else
+        {
+            NS_FATAL_ERROR("Mobility Models needs to be of type Geocentric for NTN scenarios");
+        }
+
+        int elevAngleQuantized =
+            (elevAngle < 10)
+                ? 10
+                : round(elevAngle / 10) *
+                      10; // Round the elevation angle into a two-digits integer between 10 and 90.
+
+        if (m_scenario == "NTN-DenseUrban")
+        {
+            if (channelCondition->IsLos())
+            {
+                table3gpp->m_uLgDS = (*m_NTNDenseUrbanLOS)
+                                         .at(freqBand)
+                                         .at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS = (*m_NTNDenseUrbanLOS)
+                                           .at(freqBand)
+                                           .at(elevAngleQuantized)[table3gppParams::sigLgDS];
+
+                // table3gpp->m_uLgASD=-1.79769e+308;  //FOR SATELLITES
+                table3gpp->m_uLgASD = (*m_NTNDenseUrbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASD];
+                // table3gpp->m_sigLgASD=0; //FOR SATELLITES
+                table3gpp->m_sigLgASD = (*m_NTNDenseUrbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASD];
+
+                table3gpp->m_uLgASA = (*m_NTNDenseUrbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA = (*m_NTNDenseUrbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA = (*m_NTNDenseUrbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA = (*m_NTNDenseUrbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+
+                // table3gpp->m_uLgZSD=-1.79769e+308;  //FOR SATELLITES
+                table3gpp->m_uLgZSD = (*m_NTNDenseUrbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                // table3gpp->m_sigLgZSD= 0; //FOR SATELLITES
+                table3gpp->m_sigLgZSD = (*m_NTNDenseUrbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+
+                table3gpp->m_uK =
+                    (*m_NTNDenseUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK = (*m_NTNDenseUrbanLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau = (*m_NTNDenseUrbanLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr = (*m_NTNDenseUrbanLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr = (*m_NTNDenseUrbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNDenseUrbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNDenseUrbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNDenseUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD = (*m_NTNDenseUrbanLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA = (*m_NTNDenseUrbanLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA = (*m_NTNDenseUrbanLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNDenseUrbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 7; row++)
+                {
+                    for (uint8_t column = 0; column < 7; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] = sqrtC_NTN_DenseUrban_LOS[row][column];
+                    }
+                }
+            }
+            else if (channelCondition->IsNlos())
+            {
+                NS_LOG_UNCOND("Dense Urban NLOS");
+                table3gpp->m_uLgDS = (*m_NTNDenseUrbanNLOS)
+                                         .at(freqBand)
+                                         .at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS = (*m_NTNDenseUrbanNLOS)
+                                           .at(freqBand)
+                                           .at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD = (*m_NTNDenseUrbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD = (*m_NTNDenseUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA = (*m_NTNDenseUrbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA = (*m_NTNDenseUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA = (*m_NTNDenseUrbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA = (*m_NTNDenseUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD = (*m_NTNDenseUrbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD = (*m_NTNDenseUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_rTau = (*m_NTNDenseUrbanNLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr = (*m_NTNDenseUrbanNLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr = (*m_NTNDenseUrbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNDenseUrbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNDenseUrbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS = (*m_NTNDenseUrbanNLOS)
+                                       .at(freqBand)
+                                       .at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD = (*m_NTNDenseUrbanNLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA = (*m_NTNDenseUrbanNLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA = (*m_NTNDenseUrbanNLOS)
+                                        .at(freqBand)
+                                        .at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNDenseUrbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 6; row++)
+                {
+                    for (uint8_t column = 0; column < 6; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] = sqrtC_NTN_DenseUrban_NLOS[row][column];
+                    }
+                }
+            }
+        }
+        else if (m_scenario == "NTN-Urban")
+        {
+            if (channelCondition->IsLos())
+            {
+                table3gpp->m_uLgDS =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_uK =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNUrbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNUrbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA =
+                    (*m_NTNUrbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNUrbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 7; row++)
+                {
+                    for (uint8_t column = 0; column < 7; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] = sqrtC_NTN_Urban_LOS[row][column];
+                    }
+                }
+            }
+            else if (channelCondition->IsNlos())
+            {
+                table3gpp->m_uLgDS =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD = (*m_NTNUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA = (*m_NTNUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA = (*m_NTNUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD = (*m_NTNUrbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_uK =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNUrbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNUrbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA =
+                    (*m_NTNUrbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNUrbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 6; row++)
+                {
+                    for (uint8_t column = 0; column < 6; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] =
+                            sqrtC_NTN_Urban_NLOS.at(elevAngleQuantized)[row][column];
+                    }
+                }
+            }
+        }
+        else if (m_scenario == "NTN-Suburban")
+        {
+            if (channelCondition->IsLos())
+            {
+                table3gpp->m_uLgDS =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS = (*m_NTNSuburbanLOS)
+                                           .at(freqBand)
+                                           .at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD = (*m_NTNSuburbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD = (*m_NTNSuburbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA = (*m_NTNSuburbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA = (*m_NTNSuburbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA = (*m_NTNSuburbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA = (*m_NTNSuburbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD = (*m_NTNSuburbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD = (*m_NTNSuburbanLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_uK =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr = (*m_NTNSuburbanLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNSuburbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNSuburbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA =
+                    (*m_NTNSuburbanLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNSuburbanLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 7; row++)
+                {
+                    for (uint8_t column = 0; column < 7; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] = sqrtC_NTN_Suburban_LOS[row][column];
+                    }
+                }
+            }
+            else if (channelCondition->IsNlos())
+            {
+                table3gpp->m_uLgDS = (*m_NTNSuburbanNLOS)
+                                         .at(freqBand)
+                                         .at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS = (*m_NTNSuburbanNLOS)
+                                           .at(freqBand)
+                                           .at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD = (*m_NTNSuburbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD = (*m_NTNSuburbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA = (*m_NTNSuburbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA = (*m_NTNSuburbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA = (*m_NTNSuburbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA = (*m_NTNSuburbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD = (*m_NTNSuburbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD = (*m_NTNSuburbanNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_uK =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr = (*m_NTNSuburbanNLOS)
+                                          .at(freqBand)
+                                          .at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNSuburbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNSuburbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA =
+                    (*m_NTNSuburbanNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNSuburbanNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 6; row++)
+                {
+                    for (uint8_t column = 0; column < 6; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] = sqrtC_NTN_Suburban_NLOS[row][column];
+                    }
+                }
+            }
+        }
+        else if (m_scenario == "NTN-Rural")
+        {
+            if (channelCondition->IsLos())
+            {
+                table3gpp->m_uLgDS =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_uK =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNRuralLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNRuralLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA =
+                    (*m_NTNRuralLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNRuralLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                for (uint8_t row = 0; row < 7; row++)
+                {
+                    for (uint8_t column = 0; column < 7; column++)
+                    {
+                        table3gpp->m_sqrtC[row][column] = sqrtC_NTN_Rural_LOS[row][column];
+                    }
+                }
+            }
+            else if (channelCondition->IsNlos())
+            {
+                table3gpp->m_uLgDS =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgDS];
+                table3gpp->m_sigLgDS =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigLgDS];
+                table3gpp->m_uLgASD =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASD];
+                table3gpp->m_sigLgASD = (*m_NTNRuralNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASD];
+                table3gpp->m_uLgASA =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgASA];
+                table3gpp->m_sigLgASA = (*m_NTNRuralNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgASA];
+                table3gpp->m_uLgZSA =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSA];
+                table3gpp->m_sigLgZSA = (*m_NTNRuralNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSA];
+                table3gpp->m_uLgZSD =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uLgZSD];
+                table3gpp->m_sigLgZSD = (*m_NTNRuralNLOS)
+                                            .at(freqBand)
+                                            .at(elevAngleQuantized)[table3gppParams::sigLgZSD];
+                table3gpp->m_uK =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uK];
+                table3gpp->m_sigK =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigK];
+                table3gpp->m_rTau =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::rTau];
+                table3gpp->m_uXpr =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::uXpr];
+                table3gpp->m_sigXpr =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::sigXpr];
+                table3gpp->m_numOfCluster =
+                    (*m_NTNRuralNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::numOfCluster];
+                table3gpp->m_raysPerCluster =
+                    (*m_NTNRuralNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::raysPerCluster];
+                table3gpp->m_cDS =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cDS];
+                table3gpp->m_cASD =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASD];
+                table3gpp->m_cASA =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cASA];
+                table3gpp->m_cZSA =
+                    (*m_NTNRuralNLOS).at(freqBand).at(elevAngleQuantized)[table3gppParams::cZSA];
+                table3gpp->m_perClusterShadowingStd =
+                    (*m_NTNRuralNLOS)
+                        .at(freqBand)
+                        .at(elevAngleQuantized)[table3gppParams::perClusterShadowingStd];
+
+                if (freqBand == "S")
+                {
+                    for (uint8_t row = 0; row < 6; row++)
+                    {
+                        for (uint8_t column = 0; column < 6; column++)
+                        {
+                            table3gpp->m_sqrtC[row][column] =
+                                sqrtC_NTN_Rural_NLOS_S.at(elevAngleQuantized)[row][column];
+                        }
+                    }
+                }
+                else if (freqBand == "Ka")
+                {
+                    for (uint8_t row = 0; row < 6; row++)
+                    {
+                        for (uint8_t column = 0; column < 6; column++)
+                        {
+                            table3gpp->m_sqrtC[row][column] =
+                                sqrtC_NTN_Rural_NLOS_Ka.at(elevAngleQuantized)[row][column];
+                        }
+                    }
+                }
+            }
+        }
+        if (isSatellite) // Parameters that should be set to -inf are instead set to the minimum
+                         // value of double
+        {
+            table3gpp->m_uLgASD = std::numeric_limits<double>::min();
+            table3gpp->m_sigLgASD = 0;
+            table3gpp->m_uLgZSD = std::numeric_limits<double>::min();
+            table3gpp->m_sigLgZSD = 0;
+        }
+    }
     else
     {
         NS_FATAL_ERROR("unknown scenarios");
@@ -1126,17 +3026,8 @@ ThreeGppChannelModel::GetChannel(Ptr<const MobilityModel> aMob,
         notFoundParams = true;
     }
 
-    double x = aMob->GetPosition().x - bMob->GetPosition().x;
-    double y = aMob->GetPosition().y - bMob->GetPosition().y;
-    double distance2D = sqrt(x * x + y * y);
-
-    // NOTE we assume hUT = min (height(a), height(b)) and
-    // hBS = max (height (a), height (b))
-    double hUt = std::min(aMob->GetPosition().z, bMob->GetPosition().z);
-    double hBs = std::max(aMob->GetPosition().z, bMob->GetPosition().z);
-
     // get the 3GPP parameters
-    Ptr<const ParamsTable> table3gpp = GetThreeGppTable(condition, hBs, hUt, distance2D);
+    Ptr<const ParamsTable> table3gpp = GetThreeGppTable(aMob, bMob, condition);
 
     if (notFoundParams || updateParams)
     {
@@ -1391,8 +3282,15 @@ ThreeGppChannelModel::GenerateChannelParameters(const Ptr<const ChannelCondition
     double cNlos;
     // According to table 7.5-6, only cluster number equals to 8, 10, 11, 12, 19 and 20 is valid.
     // Not sure why the other cases are in Table 7.5-2.
+    // Added case 2 and 3 for the NTN according to table 6.7.2-1aa (28.811)
     switch (table3gpp->m_numOfCluster) // Table 7.5-2
     {
+    case 2:
+        cNlos = 0.501;
+        break;
+    case 3:
+        cNlos = 0.680;
+        break;
     case 4:
         cNlos = 0.779;
         break;
@@ -1438,8 +3336,18 @@ ThreeGppChannelModel::GenerateChannelParameters(const Ptr<const ChannelCondition
                  1e-4 * pow(kFactor, 3)); //(7.5-10))
     }
 
+    // Added case 2, 3 and 4 for the NTN according to table 6.7.2-1ab (28.811)
     switch (table3gpp->m_numOfCluster) // Table 7.5-4
     {
+    case 2:
+        cNlos = 0.430;
+        break;
+    case 3:
+        cNlos = 0.594;
+        break;
+    case 4:
+        cNlos = 0.697;
+        break;
     case 8:
         cNlos = 0.889;
         break;
diff --git a/src/spectrum/model/three-gpp-channel-model.h b/src/spectrum/model/three-gpp-channel-model.h
index fec908e59..4fad78593 100644
--- a/src/spectrum/model/three-gpp-channel-model.h
+++ b/src/spectrum/model/three-gpp-channel-model.h
@@ -245,16 +245,15 @@ class ThreeGppChannelModel : public MatrixBasedChannelModel
 
     /**
      * Get the parameters needed to apply the channel generation procedure
+     * \param aMob the mobility model of node A
+     * \param bMob the mobility model of node B
      * \param channelCondition the channel condition
-     * \param hBS the height of the BS
-     * \param hUT the height of the UT
-     * \param distance2D the 2D distance between tx and rx
      * \return the parameters table
      */
-    virtual Ptr<const ParamsTable> GetThreeGppTable(Ptr<const ChannelCondition> channelCondition,
-                                                    double hBS,
-                                                    double hUT,
-                                                    double distance2D) const;
+    virtual Ptr<const ParamsTable> GetThreeGppTable(
+        const Ptr<const MobilityModel> aMob,
+        const Ptr<const MobilityModel> bMob,
+        Ptr<const ChannelCondition> channelCondition) const;
 
     /**
      * Prepare 3gpp channel parameters among the nodes a and b.
@@ -371,6 +370,58 @@ class ThreeGppChannelModel : public MatrixBasedChannelModel
         2;                            //!< index of the THETA value in the m_nonSelfBlocking array
     static const uint8_t Y_INDEX = 3; //!< index of the Y value in the m_nonSelfBlocking array
     static const uint8_t R_INDEX = 4; //!< index of the R value in the m_nonSelfBlocking array
+
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNDenseUrbanLOS; //!< The nested map containing the 3GPP value tables for the NTN
+                            //!< Dense
+                            //!< Urban LOS scenario.
+                            //!< The outer key specifies the band (either "S" or "Ka"), while the
+                            //!< inner key represents the quantized elevation angle.
+                            //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNDenseUrbanNLOS; //!< The nested map containing the 3GPP value tables for the NTN
+                             // Dense Urban NLOS scenario.
+                             //!< The outer key specifies the band (either "S" or "Ka"), while the
+                             //!< inner key represents the quantized elevation angle.
+                             //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNUrbanLOS; //!< The nested map containing the 3GPP value tables for the NTN Urban
+                       //!< LOS
+                       // scenario
+                       //!< The outer key specifies the band (either "S" or "Ka"), while the
+                       //!< inner key represents the quantized elevation angle.
+                       //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNUrbanNLOS; //!< The nested map containing the 3GPP value tables for the NTN Urban
+                        // NLOS scenario
+                        //!< The outer key specifies the band (either "S" or "Ka"), while the
+                        //!< inner key represents the quantized elevation angle.
+                        //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNSuburbanLOS; //!< The nested map containing the 3GPP value tables for the NTN
+                          // Suburban LOS scenario
+                          //!< The outer key specifies the band (either "S" or "Ka"), while the
+                          //!< inner key represents the quantized elevation angle.
+                          //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNSuburbanNLOS; //!< The nested map containing the 3GPP value tables for the NTN
+                           // Suburban NLOS scenario
+                           //!< The outer key specifies the band (either "S" or "Ka"), while the
+                           //!< inner key represents the quantized elevation angle.
+                           //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNRuralLOS; //!< The nested map containing the 3GPP value tables for the NTN Rural
+                       //!< LOS
+                       // scenario
+                       //!< The outer key specifies the band (either "S" or "Ka"), while the
+                       //!< inner key represents the quantized elevation angle.
+                       //<! The inner vector collects the table3gpp values.
+    const std::map<std::string, std::map<int, std::vector<float>>>*
+        m_NTNRuralNLOS; //!< The nested map containing the 3GPP value tables for the NTN Rural
+                        // NLOS scenario
+                        //!< The outer key specifies the band (either "S" or "Ka"), while the
+                        //!< inner key represents the quantized elevation angle.
+                        //<! The inner vector collects the table3gpp values.
 };
 } // namespace ns3
 
-- 
2.42.0

